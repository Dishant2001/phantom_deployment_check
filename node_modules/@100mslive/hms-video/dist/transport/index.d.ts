import ITransportObserver from './ITransportObserver';
import ITransport from './ITransport';
import { HMSLocalTrack } from '../media/tracks';
import { HMSVideoTrackSettings, HMSAudioTrackSettings } from '../media/settings';
import { InitConfig, InitFlags } from '../signal/init/models';
import { HMSPeer, HMSRoleChangeRequest, HLSConfig, HMSRole, HLSTimedMetadata } from '../interfaces';
import { IStore } from '../sdk/store';
import { DeviceManager } from '../device-manager';
import { MultiTrackUpdateRequestParams, TrackUpdateRequestParams } from '../signal/interfaces';
import Message from '../sdk/models/HMSMessage';
import { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';
import { LocalTrackManager } from '../sdk/LocalTrackManager';
import { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';
import { EventBus } from '../events/EventBus';
import { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';
import { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';
import { AnalyticsTimer } from '../analytics/AnalyticsTimer';
export default class HMSTransport implements ITransport {
    private observer;
    private deviceManager;
    private store;
    private localTrackManager;
    private eventBus;
    private analyticsEventsService;
    private analyticsTimer;
    private state;
    private trackStates;
    private publishConnection;
    private subscribeConnection;
    private initConfig?;
    private endpoint;
    private joinParameters?;
    private retryScheduler;
    private trackDegradationController?;
    private webrtcInternals?;
    private maxSubscribeBitrate;
    private joinRetryCount;
    constructor(observer: ITransportObserver, deviceManager: DeviceManager, store: IStore, localTrackManager: LocalTrackManager, eventBus: EventBus, analyticsEventsService: AnalyticsEventsService, analyticsTimer: AnalyticsTimer);
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */
    private readonly callbacks;
    private signalObserver;
    private signal;
    private analyticsSignalTransport;
    private publishConnectionObserver;
    private subscribeConnectionObserver;
    getLocalScreen(videoSettings: HMSVideoTrackSettings, audioSettings?: HMSAudioTrackSettings): Promise<Array<HMSLocalTrack>>;
    getWebrtcInternals(): HMSWebrtcInternals | undefined;
    isFlagEnabled(flag: InitFlags): boolean;
    preview(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean): Promise<InitConfig | void>;
    join(authToken: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, initEndpoint: string, autoSubscribeVideo?: boolean): Promise<void>;
    connect(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean): Promise<InitConfig | void>;
    leave(): Promise<void>;
    handleLocalRoleUpdate: ({ oldRole, newRole }: {
        oldRole: HMSRole;
        newRole: HMSRole;
    }) => Promise<void>;
    publish(tracks: Array<HMSLocalTrack>): Promise<void>;
    unpublish(tracks: Array<HMSLocalTrack>): Promise<void>;
    sendMessage(message: Message): Promise<import("../signal/interfaces").BroadcastResponse>;
    /**
     * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and
     * source. The hack won't work if there are multiple tracks with same source and type.
     */
    trackUpdate(track: HMSLocalTrack): void;
    changeRole(forPeer: HMSPeer, toRole: string, force?: boolean): Promise<void>;
    acceptRoleChange(request: HMSRoleChangeRequest): Promise<void>;
    endRoom(lock: boolean, reason: string): Promise<void>;
    removePeer(peerId: string, reason: string): Promise<void>;
    startRTMPOrRecording(params: RTMPRecordingConfig): Promise<void>;
    stopRTMPOrRecording(): Promise<void>;
    startHLSStreaming(params?: HLSConfig): Promise<void>;
    stopHLSStreaming(params?: HLSConfig): Promise<void>;
    sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]): Promise<void>;
    changeName(name: string): Promise<void>;
    changeMetadata(metadata: string): Promise<void>;
    changeTrackState(trackUpdateRequest: TrackUpdateRequestParams): Promise<void>;
    changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams): Promise<void>;
    private publishTrack;
    private unpublishTrack;
    private waitForLocalRoleAvailability;
    private createConnectionsAndNegotiateJoin;
    private createPeerConnections;
    private negotiateJoinWithRetry;
    private negotiateJoin;
    private negotiateJoinWebRTC;
    private negotiateJoinNonWebRTC;
    /**
     * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer
     */
    private negotiateOnFirstPublish;
    private performPublishRenegotiation;
    private handleIceConnectionFailure;
    private internalConnect;
    private validateNotDisconnected;
    private openSignal;
    private initRtcStatsMonitor;
    /**
     * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything
     * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role
     */
    private doesRoleNeedWebRTC;
    private doesLocalPeerNeedWebRTC;
    private retryPublishIceFailedTask;
    private retrySubscribeIceFailedTask;
    private retrySignalDisconnectTask;
    private setTransportStateForConnect;
    private sendErrorAnalyticsEvent;
    getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties;
}
