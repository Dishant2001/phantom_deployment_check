{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/support.ts", "../src/utils/local-storage.ts", "../src/utils/logger.ts", "../src/utils/local-storage-polyfill.ts", "../src/interfaces/update-listener.ts", "../src/interfaces/room.ts", "../src/interfaces/simulcast-layers.ts", "../src/interfaces/track-settings.ts", "../src/interfaces/playlist.ts", "../src/connection/model.ts", "../src/utils/session-description.ts", "../src/error/ErrorCodes.ts", "../src/error/HMSException.ts", "../src/error/ErrorFactory.ts", "../src/utils/validations.ts", "../src/connection/index.ts", "../src/utils/constants.ts", "../src/connection/publish/index.ts", "../src/media/streams/HMSMediaStream.ts", "../src/media/streams/HMSRemoteStream.ts", "../src/connection/HMSDataChannel.ts", "../src/media/tracks/HMSTrack.ts", "../src/media/tracks/HMSTrackType.ts", "../src/media/tracks/HMSAudioTrack.ts", "../src/media/tracks/HMSRemoteAudioTrack.ts", "../src/media/tracks/HMSVideoTrack.ts", "../src/media/tracks/HMSRemoteVideoTrack.ts", "../src/connection/subscribe/index.ts", "../src/signal/init/index.ts", "../src/signal/jsonrpc/index.ts", "../src/signal/jsonrpc/models.ts", "../src/utils/queue.ts", "../src/utils/timer-utils.ts", "../src/media/settings/HMSAudioTrackSettings.ts", "../src/media/settings/HMSVideoTrackSettings.ts", "../src/media/settings/HMSTrackSettings.ts", "../src/notification-manager/HMSNotificationMethod.ts", "../src/notification-manager/managers/ActiveSpeakerManager.ts", "../src/sdk/models/HMSMessage.ts", "../src/sdk/models/peer/HMSPeer.ts", "../src/utils/id-factory.ts", "../src/sdk/models/peer/HMSLocalPeer.ts", "../src/sdk/models/peer/HMSRemotePeer.ts", "../src/notification-manager/managers/BroadcastManager.ts", "../src/notification-manager/managers/PeerListManager.ts", "../src/utils/date.ts", "../src/notification-manager/managers/PeerManager.ts", "../src/notification-manager/managers/PolicyChangeManager.ts", "../src/notification-manager/managers/RequestManager.ts", "../src/notification-manager/managers/RoomUpdateManager.ts", "../src/error/utils.ts", "../src/utils/track.ts", "../src/utils/track-audio-level-monitor.ts", "../src/plugins/audio/HMSAudioPlugin.ts", "../src/analytics/AnalyticsEvent.ts", "../src/analytics/AnalyticsEventDomains.ts", "../src/analytics/domain-analytics.ts", "../src/analytics/AnalyticsEventLevel.ts", "../src/analytics/MediaPluginsAnalyticsFactory.ts", "../src/plugins/audio/AudioPluginsAnalytics.ts", "../src/plugins/audio/HMSAudioPluginsManager.ts", "../src/device-manager/DeviceStorage.ts", "../src/media/tracks/HMSLocalAudioTrack.ts", "../src/plugins/video/HMSVideoPlugin.ts", "../src/utils/math.ts", "../src/plugins/video/VideoPluginsAnalytics.ts", "../src/plugins/video/HMSVideoPluginsManager.ts", "../src/media/streams/HMSLocalStream.ts", "../src/analytics/AnalyticsEventFactory.ts", "../src/utils/media.ts", "../src/analytics/AnalyticsTimer.ts", "../src/sdk/LocalTrackManager.ts", "../src/media/tracks/HMSLocalVideoTrack.ts", "../src/notification-manager/managers/TrackManager.ts", "../src/notification-manager/managers/ConnectionQualityManager.ts", "../src/notification-manager/NotificationManager.ts", "../src/notification-manager/HMSNotifications.ts", "../src/transport/models/TransportState.ts", "../src/transport/models/JoinParameters.ts", "../src/signal/init/models.ts", "../src/transport/models/TransportFailureCategory.ts", "../src/utils/promise.ts", "../src/transport/RetryScheduler.ts", "../src/sdk/store/IStore.ts", "../src/analytics/HTTPAnalyticsTransport.ts", "../src/analytics/AnalyticsTransport.ts", "../src/analytics/signal-transport/LocalStoageEvents.ts", "../src/analytics/signal-transport/SignalAnalyticsTransport.ts", "../src/degradation/TrackDegradationController.ts", "../src/rtc-stats/utils.ts", "../src/rtc-stats/HMSWebrtcStats.ts", "../src/rtc-stats/HMSWebrtcInternals.ts", "../src/utils/network-info.ts", "../src/transport/index.ts", "../src/utils/jwt.ts", "../src/sdk/models/HMSRoom.ts", "../src/audio-sink-manager/AudioSinkManager.ts", "../src/device-manager/DeviceManager.ts", "../src/device-manager/AudioOutputManager.ts", "../src/analytics/AnalyticsEventsService.ts", "../src/sdk/store/Comparator.ts", "../src/sdk/store/Store.ts", "../src/sdk/RoleChangeManager.ts", "../src/utils/typed-event-emitter.ts", "../src/playlist-manager/AudioContextManager.ts", "../src/playlist-manager/PlaylistAudioManager.ts", "../src/playlist-manager/PlaylistVideoManager.ts", "../src/playlist-manager/PlaylistManager.ts", "../src/events/EventBus.ts", "../src/events/HMSInternalEvent.ts", "../src/sdk/NetworkTestManager.ts", "../src/sdk/index.ts", "../src/utils/device-error.ts"],
  "sourcesContent": ["import adapter from 'webrtc-adapter';\nimport './utils/local-storage-polyfill';\nimport HMSLogger from './utils/logger';\n\nHMSLogger.i('adapter', `${adapter.browserDetails.browser} v${adapter.browserDetails.version}`);\n\nexport * from './sdk';\nexport * from './media/tracks';\nexport * from './utils/media';\nexport * from './utils/device-error';\nexport * from './utils/support';\nexport * from './error/HMSException';\nexport * from './interfaces';\nexport * from './rtc-stats';\nexport * from './plugins';\nexport * from './utils/logger';\n", "import { UAParser } from 'ua-parser-js';\nimport { v4 as uuid } from 'uuid';\nimport { LocalStorage } from './local-storage';\nimport { version } from './package.alias.json';\nimport HMSLogger from './logger';\n\nexport const parsedUserAgent = new UAParser();\n\nexport const isNode =\n  typeof window === 'undefined' && !parsedUserAgent.getBrowser().name?.toLowerCase().includes('electron');\n\nexport const isBrowser = typeof window !== 'undefined';\n\nconst checkIsSupported = () => {\n  if (isNode) {\n    return false;\n  }\n  // @TODO: Get this from preview/init API from server\n  return true;\n};\n\nexport const isSupported = checkIsSupported();\n\nfunction createUserAgent(): string {\n  if (isNode) {\n    return `hmsclient/${version} web_nodejs`;\n  }\n  const parsedOs = parsedUserAgent.getOS();\n  const parsedDevice = parsedUserAgent.getDevice();\n  const parsedBrowser = parsedUserAgent.getBrowser();\n\n  const sdk = `hmsclient/${version}`;\n  const osNameVersion = replaceSpaces(`${parsedOs.name}/${parsedOs.version}`);\n  const os = `web_${osNameVersion}`;\n  const browser = replaceSpaces(`${parsedBrowser.name}_${parsedBrowser.version}`);\n  let device = browser;\n  if (parsedDevice.type) {\n    const deviceVendor = replaceSpaces(`${parsedDevice.vendor}_${parsedDevice.type}`);\n    device = `${deviceVendor}/${browser}`;\n  }\n\n  return `${sdk} ${os} ${device}`;\n}\n\nfunction replaceSpaces(s: string) {\n  return s.replace(/ /g, '_');\n}\n\nexport const isMobile = () => parsedUserAgent.getDevice().type === 'mobile';\n\nexport const userAgent = createUserAgent();\nHMSLogger.d('[Util]', 'userAgent', userAgent);\n\nexport const getAnalyticsDeviceId = () => {\n  let id;\n  const storage = new LocalStorage<string>('hms-analytics-deviceId');\n  const storageId = storage.get();\n  if (storageId) {\n    id = storageId;\n  } else {\n    id = uuid();\n    storage.set(id);\n  }\n  return id;\n};\n\nexport const isPageHidden = () => typeof document !== 'undefined' && document.hidden;\n", "import { initializeLocalstoragePolyfill } from './local-storage-polyfill';\nimport { isBrowser } from './support';\n\nexport class LocalStorage<T> {\n  private storage: Storage | null = null;\n\n  constructor(public readonly key: string) {}\n\n  /**\n   * localstorage is not available in SSR, so get it only at time of use\n   */\n  getStorage() {\n    if (isBrowser && !this.storage) {\n      initializeLocalstoragePolyfill();\n      this.storage = window.localStorage;\n    }\n    return this.storage;\n  }\n\n  get(): T | undefined {\n    const stringItem = this.getStorage()?.getItem(this.key);\n    if (!stringItem) {\n      return;\n    }\n    const item = JSON.parse(stringItem) as T;\n    return item;\n  }\n\n  set(value: T) {\n    const stringValue = JSON.stringify(value);\n    this.getStorage()?.setItem(this.key, stringValue);\n  }\n\n  clear() {\n    this.getStorage()?.removeItem(this.key);\n  }\n}\n", "export enum HMSLogLevel {\n  VERBOSE,\n  DEBUG,\n  INFO,\n  WARN,\n  TIME,\n  TIMEEND,\n  ERROR,\n  NONE,\n}\n\n// @ts-ignore - window.expect is available only when in test environment\nconst isTestEnv = typeof window !== 'undefined' && typeof window.expect !== 'undefined';\n/**\n * TODO: fix this so logs show the real file and line numbers where they originated from instead of this class\n * https://stackoverflow.com/questions/13815640/a-proper-wrapper-for-console-log-with-correct-line-number\n */\nexport default class HMSLogger {\n  static level: HMSLogLevel = isTestEnv ? HMSLogLevel.NONE : HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, tag, ...data);\n  }\n\n  static i(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.INFO, tag, ...data);\n  }\n\n  static w(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.WARN, tag, ...data);\n  }\n\n  static e(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.ERROR, tag, ...data);\n  }\n\n  static time(mark: string) {\n    this.log(HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);\n  }\n\n  static timeEnd(mark: string) {\n    this.log(HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);\n  }\n\n  static cleanUp() {\n    performance.clearMarks();\n    performance.clearMeasures();\n  }\n\n  // eslint-disable-next-line complexity\n  private static log(level: HMSLogLevel, tag: string, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.TIME: {\n        performance.mark(data[0]);\n        break;\n      }\n      case HMSLogLevel.TIMEEND: {\n        const mark = data[0];\n        try {\n          const entry = performance.measure(mark, mark);\n          // @ts-ignore\n          this.log(HMSLogLevel.DEBUG, tag, mark, entry?.duration);\n          performance.clearMarks(mark);\n          performance.clearMeasures(mark);\n        } catch (error) {\n          this.log(HMSLogLevel.DEBUG, tag, mark, error);\n        }\n        break;\n      }\n    }\n  }\n}\n", "import { isBrowser } from './support';\n\nclass LocalStorage {\n  valuesMap = new Map();\n  getItem(key: string) {\n    if (this.valuesMap.has(key)) {\n      return String(this.valuesMap.get(key));\n    }\n    return null;\n  }\n\n  setItem(key: string, val: string) {\n    this.valuesMap.set(key, val);\n  }\n\n  removeItem(key: string) {\n    this.valuesMap.delete(key);\n  }\n\n  clear() {\n    this.valuesMap.clear();\n  }\n\n  key(i: number) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"); // this is a TypeError implemented on Chrome, Firefox throws Not enough arguments to Storage.key.\n    }\n    const arr = Array.from(this.valuesMap.keys());\n    return arr[i];\n  }\n\n  get length() {\n    return this.valuesMap.size;\n  }\n}\n\nexport const initializeLocalstoragePolyfill = () => {\n  if (isBrowser && typeof localStorage === undefined) {\n    window.localStorage = new LocalStorage();\n  }\n};\n", "import { HMSException } from '../error/HMSException';\nimport { HMSTrack } from '../media/tracks/HMSTrack';\nimport { HMSPeer } from '../sdk/models/peer';\nimport { HMSRoleChangeRequest } from './role-change-request';\nimport { HMSMessage } from './message';\nimport { HMSRoom } from './room';\nimport { HMSSpeaker } from './speaker';\nimport { DeviceChangeListener } from './device-change-listener';\nimport { HMSChangeMultiTrackStateRequest, HMSChangeTrackStateRequest } from './change-track-state';\nimport { HMSLeaveRoomRequest } from './leave-room-request';\nimport { HMSConnectionQuality } from './peer';\n\nexport enum HMSRoomUpdate {\n  RECORDING_STATE_UPDATED = 'RECORDING_STATE_UPDATED',\n  BROWSER_RECORDING_STATE_UPDATED = 'BROWSER_RECORDING_STATE_UPDATED',\n  SERVER_RECORDING_STATE_UPDATED = 'SERVER_RECORDING_STATE_UPDATED',\n  RTMP_STREAMING_STATE_UPDATED = 'RTMP_STREAMING_STATE_UPDATED',\n  HLS_STREAMING_STATE_UPDATED = 'HLS_STREAMING_STATE_UPDATED',\n}\n\nexport enum HMSPeerUpdate {\n  PEER_JOINED,\n  PEER_LEFT,\n  AUDIO_TOGGLED,\n  VIDEO_TOGGLED,\n  BECAME_DOMINANT_SPEAKER,\n  RESIGNED_DOMINANT_SPEAKER,\n  STARTED_SPEAKING,\n  STOPPED_SPEAKING,\n  ROLE_UPDATED,\n  PEER_LIST,\n  NAME_UPDATED,\n  METADATA_UPDATED,\n}\n\nexport enum HMSTrackUpdate {\n  TRACK_ADDED,\n  TRACK_REMOVED,\n  TRACK_MUTED,\n  TRACK_UNMUTED,\n  TRACK_DESCRIPTION_CHANGED,\n  TRACK_DEGRADED,\n  TRACK_RESTORED,\n}\n\nexport interface HMSAudioListener {\n  onAudioLevelUpdate(speakers: HMSSpeaker[]): void;\n}\n\nexport interface HMSConnectionQualityListener {\n  onConnectionQualityUpdate(qualityUpdates: HMSConnectionQuality[]): void;\n}\n\nexport interface HMSUpdateListener extends DeviceChangeListener {\n  onJoin(room: HMSRoom): void;\n  onRoomUpdate(type: HMSRoomUpdate, room: HMSRoom): void;\n  onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer | HMSPeer[] | null): void;\n  onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer): void;\n  onMessageReceived(message: HMSMessage): void;\n  onError(error: HMSException): void;\n  onReconnecting(error: HMSException): void;\n  onReconnected(): void;\n  onRoleChangeRequest(request: HMSRoleChangeRequest): void;\n  onRoleUpdate(newRole: string): void;\n  onChangeTrackStateRequest(request: HMSChangeTrackStateRequest): void;\n  onChangeMultiTrackStateRequest(request: HMSChangeMultiTrackStateRequest): void;\n  onRemovedFromRoom(request: HMSLeaveRoomRequest): void;\n  onNetworkQuality?(score: number): void;\n}\n", "import { HMSLocalPeer, HMSPeer } from '../sdk/models/peer';\nimport { ServerError } from './internal';\nimport { HMSException } from '../error/HMSException';\n\nexport enum HMSRoomType {\n  DEFAULT,\n}\n\nexport interface HMSRoom {\n  id: string;\n  name?: string;\n  sessionId?: string;\n  joinedAt?: Date;\n  startedAt?: Date;\n  localPeer: HMSLocalPeer;\n  peers: HMSPeer[];\n  shareableLink: string;\n  type: HMSRoomType;\n  hasWaitingRoom: boolean;\n  recording: HMSRecording;\n  rtmp: HMSRTMP;\n  hls: HMSHLS;\n  peerCount?: number;\n  templateId?: string;\n}\n\nexport interface HMSRecording {\n  browser: {\n    running: boolean;\n    startedAt?: Date;\n    error?: HMSException;\n  };\n  server: {\n    running: boolean;\n    startedAt?: Date;\n    error?: HMSException;\n  };\n  hls: HMSHLSRecording;\n}\n\nexport interface HMSHLSRecording {\n  running: boolean;\n  startedAt?: Date;\n  error?: ServerError;\n  /**\n   * if the final output is one file or one file per hls layer\n   */\n  singleFilePerLayer?: boolean;\n  /**\n   * if video on demand needs to be turned on, false by default\n   */\n  hlsVod?: boolean;\n}\n\nexport interface HMSRTMP {\n  running: boolean;\n  /**\n   * @alpha\n   **/\n  startedAt?: Date;\n  error?: HMSException;\n}\n\nexport interface HMSHLS {\n  running: boolean;\n  variants: Array<HLSVariant>;\n  error?: HMSException;\n}\n\nexport interface HLSVariant {\n  url: string;\n  meetingURL?: string;\n  metadata?: string;\n  startedAt?: Date;\n}\n", "export enum HMSSimulcastLayer {\n  NONE = 'none',\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n}\n\nexport interface SimulcastLayer {\n  rid: string;\n  scaleResolutionDownBy?: number;\n  maxBitrate: number;\n  maxFramerate: number;\n}\n\nexport interface SimulcastDimensions {\n  width?: number;\n  height?: number;\n}\n\nexport interface SimulcastLayers extends SimulcastDimensions {\n  layers: SimulcastLayer[];\n}\n\nexport interface SimulcastLayerDefinition {\n  layer: Exclude<HMSSimulcastLayer, HMSSimulcastLayer.NONE>;\n  resolution: SimulcastDimensions;\n}\n\nexport type RID = 'f' | 'h' | 'q';\n\nexport const simulcastMapping = {\n  f: HMSSimulcastLayer.HIGH,\n  h: HMSSimulcastLayer.MEDIUM,\n  q: HMSSimulcastLayer.LOW,\n};\n", "export enum HMSVideoCodec {\n  VP8 = 'vp8',\n  VP9 = 'vp9',\n  H264 = 'h264',\n}\n\nexport enum HMSAudioCodec {\n  OPUS = 'opus',\n}\n\nexport interface HMSAudioTrackSettings {\n  volume?: number;\n  codec?: HMSAudioCodec;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced?: Array<MediaTrackConstraintSet>;\n}\n\nexport interface HMSVideoTrackSettings {\n  width?: number;\n  height?: number;\n  codec?: HMSVideoCodec;\n  maxFramerate?: number;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced?: Array<MediaTrackConstraintSet>;\n}\n\nexport interface ScreenShareConfig {\n  audioOnly: boolean;\n  videoOnly: boolean;\n}\n", "export enum HMSPlaylistType {\n  audio = 'audio',\n  video = 'video',\n}\n\nexport interface HMSPlaylistItem<T> {\n  /**\n   * uniquely identifies a playlist item\n   */\n  id: string;\n  name: string;\n  type: HMSPlaylistType;\n  /**\n   * the url to play from, local files are not supported currently.\n   */\n  url: string;\n  /**\n   * any additional info, for eg. composer, musician etc.\n   */\n  metadata?: T;\n  /**\n   * duration in seconds\n   */\n  duration?: number;\n}\n\nexport interface HMSPlaylistProgressEvent {\n  type: HMSPlaylistType;\n  progress: number;\n}\n\nexport interface HMSPlaylistManager {\n  getList<T>(type: HMSPlaylistType): HMSPlaylistItem<T>[];\n  setList<T>(list: HMSPlaylistItem<T>[]): void;\n  clearList(type: HMSPlaylistType): Promise<void>;\n  playNext(type: HMSPlaylistType): Promise<void>;\n  playPrevious(type: HMSPlaylistType): Promise<void>;\n  removeItem(id: string, type: HMSPlaylistType): Promise<boolean>;\n  /**\n   * Seek forward/backward on selected type relative to currentTime\n   * @param value - number in seconds to go forward(if negative, it goes backwards)\n   * @param {HMSPlaylistType} type\n   */\n  seek(value: number, type: HMSPlaylistType): void;\n  /**\n   * Seek forward/backward on selected type - absolute value\n   * @param value - point in playlist item to go to\n   * @param {HMSPlaylistType} type\n   */\n  seekTo(value: number, type: HMSPlaylistType): void;\n  /**\n   * set volume on the selected type\n   * @param value - number between 0-100\n   * @param type\n   */\n  setVolume(value: number, type: HMSPlaylistType): void;\n  /**\n   * Get volume of selected type, between 0-100\n   * @param type\n   */\n  getVolume(type: HMSPlaylistType): number;\n  isPlaying(type: HMSPlaylistType): boolean;\n  getCurrentIndex(type: HMSPlaylistType): number;\n  getCurrentSelection<T>(type: HMSPlaylistType): HMSPlaylistItem<T> | undefined;\n  /**\n   * Returns a value between 0-100\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentProgress(type: HMSPlaylistType): number;\n  /**\n   * Get the currentTime of audio/video based on type\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentTime(type: HMSPlaylistType): number;\n  setEnabled(enabled: boolean, info: { id: string; type: HMSPlaylistType }): Promise<void>;\n  stop(type: HMSPlaylistType): Promise<void>;\n  /**\n   * Subscriber to progress event with a callback\n   * @param fn\n   */\n  onProgress(fn: (event: HMSPlaylistProgressEvent) => void): void;\n  /**\n   * This will be called when a new track is played\n   * @param fn\n   */\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void): void;\n  onCurrentTrackEnded<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n  /**\n   * Function to autoplay status i.e. whether next item in playlist after the current one ends\n   * @param {HMSPlaylistType} type\n   * @param {boolean} autoplay\n   */\n  setIsAutoplayOn(type: HMSPlaylistType, autoplay: boolean): void;\n  /**\n   * Get the current playback rate of audio/video playlist\n   * @param {HMSPlaylistType} type\n   */\n  getPlaybackRate(type: HMSPlaylistType): number;\n  /**\n   * set the current playback rate of audio/video playlist\n   * @param {HMSPlaylistType}type\n   * @param {number}value - number between 0.25 and 2.0\n   */\n  setPlaybackRate(type: HMSPlaylistType, value: number): void;\n}\n", "// Sent in trickle messages as target - biz understands only 0 and 1\nexport enum HMSConnectionRole {\n  Publish = 0,\n  Subscribe = 1,\n}\n\nexport interface HMSTrickle {\n  candidate: RTCIceCandidateInit;\n  target: HMSConnectionRole;\n}\n", "import * as sdpTransform from 'sdp-transform';\nimport { TrackState } from '../notification-manager';\nimport { isPresent } from './validations';\n\n/**\n * @DISCUSS: Should we have a wrapper over RTCSessionDescriptionInit(SDP) and have these methods in it?\n */\n\nexport function fixMsid(desc: RTCSessionDescriptionInit, tracks?: Map<string, TrackState>): RTCSessionDescriptionInit {\n  const parsedSdp = sdpTransform.parse(desc.sdp!);\n\n  if (!parsedSdp.origin?.username.startsWith('mozilla')) {\n    // This isn't firefox, so we return the original offer without doing anything\n    return desc;\n  }\n\n  const mediaTracks = tracks ? Array.from(tracks.values()) : [];\n\n  parsedSdp.media.forEach(m => {\n    const streamId = m.msid?.split(' ')[0];\n    // check for both type and streamid as both video and screenshare have same type but different stream_id\n    const trackId = mediaTracks.find(val => val.type === m.type && val.stream_id === streamId)?.track_id;\n    if (trackId) {\n      m.msid = m.msid?.replace(/\\s(.+)/, ` ${trackId}`);\n    }\n  });\n\n  return { type: desc.type, sdp: sdpTransform.write(parsedSdp) };\n}\n\n/**\n * Get the track ID from the SDP using the transceiver's mid from RTCTrackEvent\n * @TODO: This could take more processing time in a large room and when the SDP is big.\n * Consider using this for Firefox only?\n */\nexport function getSdpTrackIdForMid(\n  desc?: RTCSessionDescriptionInit | null,\n  mid?: RTCRtpTransceiver['mid'],\n): string | undefined {\n  if (!desc?.sdp || !mid) {\n    return undefined;\n  }\n  const parsedSdp = sdpTransform.parse(desc.sdp);\n  const trackSection = parsedSdp.media.find(media => isPresent(media.mid) && parseInt(media.mid!) === parseInt(mid));\n  const trackId = trackSection?.msid?.split(' ')[1];\n  return trackId;\n}\n\nexport function enableOpusDtx(desc: RTCSessionDescriptionInit): RTCSessionDescriptionInit {\n  if (desc.sdp!.includes('usedtx=1')) {\n    return desc;\n  }\n\n  return { type: desc.type, sdp: desc.sdp!.replace('useinbandfec=1', 'useinbandfec=1;usedtx=1') };\n}\n", "/*\n * ErrorCodes.ts\n *\n * Created by codegen\n * Copyright \u00A9 2021 100ms. All rights reserved.\n */\n\nexport const ErrorCodes = {\n  WebSocketConnectionErrors: {\n    // Error connecting to ws or init config not available\n    FAILED_TO_CONNECT: 1000,\n\n    // Network connection lost\n    WEBSOCKET_CONNECTION_LOST: 1003,\n  },\n\n  InitAPIErrors: {\n    // [INIT]: Server error\n    SERVER_ERRORS: 2000,\n    //init config not available\n    INIT_CONFIG_NOT_AVAILABLE: 2002,\n\n    // Endpoint is not reachable.\n    ENDPOINT_UNREACHABLE: 2003,\n\n    // Token is not in proper JWT format\n    INVALID_TOKEN_FORMAT: 2004,\n  },\n\n  TracksErrors: {\n    // [PUBLISH]: Error with getusermedia request\n    GENERIC_TRACK: 3000,\n\n    // [PUBLISH]: No permission to access capture device - {device_type}\n    CANT_ACCESS_CAPTURE_DEVICE: 3001,\n\n    // [PUBLISH]: Capture device is no longer available - {device_type}\n    DEVICE_NOT_AVAILABLE: 3002,\n\n    // [PUBLISH]: Capture device is in use by another application - {device_type}\n    DEVICE_IN_USE: 3003,\n\n    // Lost access to capture device midway - {device_type}\n    DEVICE_LOST_MIDWAY: 3008,\n\n    // There is no media to return. Please select either video or audio or both.\n    NOTHING_TO_RETURN: 3005,\n\n    // Cannot enable simulcast when no video settings are provided\n    INVALID_VIDEO_SETTINGS: 3006,\n\n    // Codec can't be changed mid call.\n    CODEC_CHANGE_NOT_PERMITTED: 3007,\n\n    // When the browser throws autoplay exception if something is played before interacting\n    AUTOPLAY_ERROR: 3008,\n\n    // Over constrained error - device hardware unable to satisfy requested constraints\n    OVER_CONSTRAINED: 3009,\n\n    // No audio detected from track, indicates problem with device hardware\n    NO_AUDIO_DETECTED: 3010,\n\n    // Operating System denied permission\n    SYSTEM_DENIED_PERMISSION: 3011,\n  },\n\n  WebrtcErrors: {\n    // [{action}]: Failed to create offer.\n    CREATE_OFFER_FAILED: 4001,\n\n    // [{action}]: Failed to create answer.\n    CREATE_ANSWER_FAILED: 4002,\n\n    // [{action}]: Failed to set offer.\n    SET_LOCAL_DESCRIPTION_FAILED: 4003,\n\n    // [{action}]: Failed to set answer.\n    SET_REMOTE_DESCRIPTION_FAILED: 4004,\n\n    // [{action}]: Ice connection state FAILED\n    ICE_FAILURE: 4005,\n  },\n\n  WebsocketMethodErrors: {\n    // [JOIN]: {server_error}\n    SERVER_ERRORS: 5000,\n\n    // [JOIN]: You have already joined this room.\n    ALREADY_JOINED: 5001,\n\n    // [JOIN]: Cannot join if preview is in progress\n    CANNOT_JOIN_PREVIEW_IN_PROGRESS: 5002,\n  },\n\n  GenericErrors: {\n    // Client is not connected\n    NOT_CONNECTED: 6000,\n\n    // Unknown signalling error: {action} {error_info}\n    SIGNALLING: 6001,\n\n    // Unknown exception: {error_info}\n    UNKNOWN: 6002,\n\n    // WebRTC engine is not ready yet\n    NOT_READY: 6003,\n\n    // Failed to parse JSON message - {json_message}\n    JSON_PARSING_FAILED: 6004,\n\n    // Track Metadata Missing\n    TRACK_METADATA_MISSING: 6005,\n\n    // RTC Track missing\n    RTC_TRACK_MISSING: 6006,\n\n    // Peer Metadata Missing\n    PEER_METADATA_MISSING: 6007,\n\n    // Joined with invalid role\n    INVALID_ROLE: 6008,\n\n    PREVIEW_IN_PROGRESS: 6009,\n\n    MISSING_MEDIADEVICES: 6010,\n\n    MISSING_RTCPEERCONNECTION: 6011,\n  },\n\n  PlaylistErrors: {\n    NO_ENTRY_TO_PLAY: 8001,\n    NO_ENTRY_IS_PLAYING: 8002,\n  },\n};\n", "import { IAnalyticsPropertiesProvider } from '../analytics/IAnalyticsPropertiesProvider';\nimport { HMSSignalMethod } from '../signal/jsonrpc/models';\nimport { HMSAction } from './ErrorFactory';\n\nexport class HMSException extends Error implements IAnalyticsPropertiesProvider {\n  action: string;\n  nativeError?: Error;\n\n  constructor(\n    public readonly code: number,\n    public name: string,\n    action: HMSAction | HMSSignalMethod,\n    public message: string,\n    public description: string,\n    public isTerminal: boolean = false,\n  ) {\n    super(message);\n\n    // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, HMSException.prototype);\n    this.action = action.toString();\n  }\n\n  toAnalyticsProperties() {\n    return {\n      error_name: this.name,\n      error_code: this.code,\n      error_message: this.message,\n      error_description: this.description,\n      action: this.action,\n      is_terminal: this.isTerminal,\n    };\n  }\n\n  addNativeError(error: Error) {\n    this.nativeError = error;\n  }\n}\n", "/*\n * ErrorFactory.ts\n *\n * Created by codegen\n * Copyright \u00A9 2021 100ms. All rights reserved.\n */\n\nimport { HMSSignalMethod } from '../signal/jsonrpc/models';\nimport { ErrorCodes } from './ErrorCodes';\nimport { HMSException } from './HMSException';\n\nexport enum HMSAction {\n  NONE = 'NONE',\n  TRACK = 'TRACK',\n  INIT = 'INIT',\n  PUBLISH = 'PUBLISH',\n  UNPUBLISH = 'UNPUBLISH',\n  JOIN = 'JOIN',\n  SUBSCRIBE = 'SUBSCRIBE',\n  DATA_CHANNEL_SEND = 'DATA_CHANNEL_SEND',\n  RESTART_ICE = 'RESTART_ICE',\n  VIDEO_PLUGINS = 'VIDEO_PLUGINS',\n  AUDIO_PLUGINS = 'AUDIO_PLUGINS',\n  AUTOPLAY = 'AUTOPLAY',\n  RECONNECT_SIGNAL = 'RECONNECT_SIGNAL',\n  VALIDATION = 'VALIDATION',\n  PLAYLIST = 'PLAYLIST',\n  PREVIEW = 'PREVIEW',\n}\n\nexport const ErrorFactory = {\n  WebSocketConnectionErrors: {\n    FailedToConnect(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.FAILED_TO_CONNECT,\n        'WebsocketFailedToConnect',\n        action,\n        `[WS]: ${description}`,\n        `[WS]: ${description}`,\n      );\n    },\n\n    WebSocketConnectionLost(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n        'WebSocketConnectionLost',\n        action,\n        `Network connection lost `,\n        description,\n      );\n    },\n  },\n\n  InitAPIErrors: {\n    ServerErrors(code: number, action: HMSAction, description = '') {\n      return new HMSException(code, 'ServerErrors', action, `[INIT]: Server error ${description}`, description, true);\n    },\n\n    EndpointUnreachable(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.InitAPIErrors.ENDPOINT_UNREACHABLE,\n        'EndpointUnreachable',\n        action,\n        `Endpoint is not reachable - ${description}`,\n        description,\n      );\n    },\n\n    InvalidTokenFormat(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.InitAPIErrors.INVALID_TOKEN_FORMAT,\n        'InvalidTokenFormat',\n        action,\n        `Token is not in proper JWT format - ${description}`,\n        description,\n        true,\n      );\n    },\n\n    InitConfigNotAvailable(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.InitAPIErrors.INIT_CONFIG_NOT_AVAILABLE,\n        'InitError',\n        action,\n        `[INIT]: ${description}`,\n        `[INIT]: ${description}`,\n      );\n    },\n  },\n\n  TracksErrors: {\n    GenericTrack(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.GENERIC_TRACK,\n        'GenericTrack',\n        action,\n        `[TRACK]: ${description}`,\n        `[TRACK]: ${description}`,\n      );\n    },\n\n    CantAccessCaptureDevice(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n        'CantAccessCaptureDevice',\n        action,\n        `User denied permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceNotAvailable(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        'DeviceNotAvailable',\n        action,\n        `[TRACK]: Capture device is no longer available - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceInUse(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_IN_USE,\n        'DeviceInUse',\n        action,\n        `[TRACK]: Capture device is in use by another application - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceLostMidway(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_LOST_MIDWAY,\n        'DeviceLostMidway',\n        action,\n        `Lost access to capture device midway - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NothingToReturn(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.NOTHING_TO_RETURN,\n        'NothingToReturn',\n        action,\n        `There is no media to return. Please select either video or audio or both.`,\n        description,\n      );\n    },\n\n    InvalidVideoSettings(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.INVALID_VIDEO_SETTINGS,\n        'InvalidVideoSettings',\n        action,\n        `Cannot enable simulcast when no video settings are provided`,\n        description,\n      );\n    },\n\n    AutoplayBlocked(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.AUTOPLAY_ERROR,\n        'AutoplayBlocked',\n        action,\n        \"Autoplay blocked because the user didn't interact with the document first\",\n        description,\n      );\n    },\n\n    CodecChangeNotPermitted(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CODEC_CHANGE_NOT_PERMITTED,\n        'CodecChangeNotPermitted',\n        action,\n        `Codec can't be changed mid call.`,\n        description,\n      );\n    },\n\n    OverConstrained(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.OVER_CONSTRAINED,\n        'OverConstrained',\n        action,\n        `[TRACK]: Requested constraints cannot be satisfied with the device hardware - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NoAudioDetected(action: HMSAction, description = 'Please check the mic or use another audio input') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.NO_AUDIO_DETECTED,\n        'NoAudioDetected',\n        action,\n        'No audio input detected from microphone',\n        description,\n      );\n    },\n\n    SystemDeniedPermission(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.SYSTEM_DENIED_PERMISSION,\n        'SystemDeniedPermission',\n        action,\n        `Operating System denied permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n  },\n\n  WebrtcErrors: {\n    CreateOfferFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.CREATE_OFFER_FAILED,\n        'CreateOfferFailed',\n        action,\n        `[${action.toString()}]: Failed to create offer. `,\n        description,\n      );\n    },\n\n    CreateAnswerFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.CREATE_ANSWER_FAILED,\n        'CreateAnswerFailed',\n        action,\n        `[${action.toString()}]: Failed to create answer. `,\n        description,\n      );\n    },\n\n    SetLocalDescriptionFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.SET_LOCAL_DESCRIPTION_FAILED,\n        'SetLocalDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set offer. `,\n        description,\n      );\n    },\n\n    SetRemoteDescriptionFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.SET_REMOTE_DESCRIPTION_FAILED,\n        'SetRemoteDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set answer. `,\n        description,\n      );\n    },\n\n    ICEFailure(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.ICE_FAILURE,\n        'ICEFailure',\n        action,\n        `[${action.toString()}]: Ice connection state FAILED`,\n        description,\n      );\n    },\n  },\n\n  WebsocketMethodErrors: {\n    ServerErrors(code: number, action: HMSAction | HMSSignalMethod, description: string) {\n      return new HMSException(code, 'ServerErrors', action, description, description, true);\n    },\n\n    AlreadyJoined(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebsocketMethodErrors.ALREADY_JOINED,\n        'AlreadyJoined',\n        action,\n        `[JOIN]: You have already joined this room.`,\n        description,\n      );\n    },\n\n    CannotJoinPreviewInProgress(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebsocketMethodErrors.CANNOT_JOIN_PREVIEW_IN_PROGRESS,\n        'CannotJoinPreviewInProgress',\n        action,\n        `[JOIN]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n  },\n\n  GenericErrors: {\n    NotConnected(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.NOT_CONNECTED,\n        'NotConnected',\n        action,\n        `Client is not connected`,\n        description,\n      );\n    },\n\n    Signalling(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.SIGNALLING,\n        'Signalling',\n        action,\n        `Unknown signalling error: ${action.toString()} ${description} `,\n        description,\n      );\n    },\n\n    Unknown(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.UNKNOWN,\n        'Unknown',\n        action,\n        `Unknown exception: ${description}`,\n        description,\n      );\n    },\n\n    NotReady(action: HMSAction, description = '') {\n      return new HMSException(ErrorCodes.GenericErrors.NOT_READY, 'NotReady', action, description, description);\n    },\n\n    JsonParsingFailed(action: HMSAction, jsonMessage: string, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.JSON_PARSING_FAILED,\n        'JsonParsingFailed',\n        action,\n        `Failed to parse JSON message - ${jsonMessage}`,\n        description,\n      );\n    },\n\n    TrackMetadataMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.TRACK_METADATA_MISSING,\n        'TrackMetadataMissing',\n        action,\n        `Track Metadata Missing`,\n        description,\n      );\n    },\n\n    RTCTrackMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.RTC_TRACK_MISSING,\n        'RTCTrackMissing',\n        action,\n        `RTC Track missing`,\n        description,\n      );\n    },\n\n    PeerMetadataMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.PEER_METADATA_MISSING,\n        'PeerMetadataMissing',\n        action,\n        `Peer Metadata Missing`,\n        description,\n      );\n    },\n\n    ValidationFailed(message: string, entity?: any) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'ValidationFailed',\n        HMSAction.VALIDATION,\n        message,\n        entity ? JSON.stringify(entity) : '',\n      );\n    },\n\n    InvalidRole(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'InvalidRole',\n        action,\n        `Invalid role. Join with valid role`,\n        description,\n        true,\n      );\n    },\n\n    PreviewAlreadyInProgress(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.PREVIEW_IN_PROGRESS,\n        'PreviewAlreadyInProgress',\n        action,\n        `[Preview]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n\n    MissingMediaDevices() {\n      return new HMSException(\n        ErrorCodes.GenericErrors.MISSING_MEDIADEVICES,\n        'MissingMediaDevices',\n        HMSAction.JOIN,\n        `navigator.mediaDevices is undefined. 100ms SDK won't work on this website as WebRTC is not supported on HTTP endpoints(missing navigator.mediaDevices). Please ensure you're using the SDK either on localhost or a valid HTTPS endpoint.`,\n        '',\n        true,\n      );\n    },\n\n    MissingRTCPeerConnection() {\n      return new HMSException(\n        ErrorCodes.GenericErrors.MISSING_RTCPEERCONNECTION,\n        'MissingRTCPeerConnection',\n        HMSAction.JOIN,\n        `RTCPeerConnection which is a core requirement for WebRTC call was not found, this could be due to an unsupported browser or browser extensions blocking WebRTC`,\n        '',\n        true,\n      );\n    },\n  },\n\n  MediaPluginErrors: {\n    PlatformNotSupported(action: HMSAction, description = '') {\n      return new HMSException(\n        7001,\n        'PlatformNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported platforms',\n        description,\n      );\n    },\n\n    InitFailed(action: HMSAction, description = '') {\n      return new HMSException(7002, 'InitFailed', action, 'Plugin init failed', description);\n    },\n\n    ProcessingFailed(action: HMSAction, description = '') {\n      return new HMSException(7003, 'ProcessingFailed', action, 'Plugin processing failed', description);\n    },\n\n    AddAlreadyInProgress(action: HMSAction, description = '') {\n      return new HMSException(7004, 'AddAlreadyInProgress', action, 'Plugin add already in progress', description);\n    },\n\n    DeviceNotSupported(action: HMSAction, description = '') {\n      return new HMSException(\n        7005,\n        'DeviceNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported devices',\n        description,\n      );\n    },\n  },\n\n  PlaylistErrors: {\n    NoEntryToPlay(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_TO_PLAY,\n        'NoEntryToPlay',\n        action,\n        'Reached end of playlist',\n        description,\n      );\n    },\n    NoEntryPlaying(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_IS_PLAYING,\n        'NoEntryIsPlaying',\n        action,\n        'No entry is playing at this time',\n        description,\n      );\n    },\n  },\n};\n", "import { ErrorFactory } from '../error/ErrorFactory';\nimport HMSLogger from './logger';\n\nconst TAG = `VALIDATIONS`;\n\n/**\n * Check only for presence(not truthy) of a value.\n * Use in places where 0, false need to be considered valid.\n */\nexport function isPresent(value: any) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * checks if RTCPeerConnection constructor is available\n */\nexport const validateRTCPeerConnection = () => {\n  if (!isPresent(RTCPeerConnection)) {\n    const error = ErrorFactory.GenericErrors.MissingRTCPeerConnection();\n    HMSLogger.e(TAG, error);\n    throw error;\n  }\n};\n\n/**\n * navigator.mediaDevices is undefined in insecure contexts served over HTTP protocol\n */\nexport const validateMediaDevicesExistence = () => {\n  if (!isPresent(navigator.mediaDevices)) {\n    const error = ErrorFactory.GenericErrors.MissingMediaDevices();\n    HMSLogger.e(TAG, error);\n    throw error;\n  }\n};\n", "import { HMSConnectionRole } from './model';\nimport { ISignal } from '../signal/ISignal';\nimport HMSLogger from '../utils/logger';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { enableOpusDtx, fixMsid } from '../utils/session-description';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { TrackState } from '../notification-manager';\n\nconst TAG = 'HMSConnection';\nexport default abstract class HMSConnection {\n  readonly role: HMSConnectionRole;\n  protected readonly signal: ISignal;\n\n  abstract readonly nativeConnection: RTCPeerConnection;\n  /**\n   * We keep a list of pending IceCandidates received\n   * from the signalling server. When the peer-connection\n   * is initialized we call [addIceCandidate] for each.\n   *\n   * WARN:\n   *  - [HMSPublishConnection] keeps the complete list of candidates (for\n   *      ice-connection failed/disconnect) forever.\n   *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]\n   */\n  readonly candidates = new Array<RTCIceCandidateInit>();\n\n  protected constructor(role: HMSConnectionRole, signal: ISignal) {\n    this.role = role;\n    this.signal = signal;\n  }\n\n  public get iceConnectionState(): RTCIceConnectionState {\n    return this.nativeConnection.iceConnectionState;\n  }\n\n  public get connectionState(): RTCPeerConnectionState {\n    return this.nativeConnection.connectionState;\n  }\n\n  private get action(): HMSAction {\n    return this.role === HMSConnectionRole.Publish ? HMSAction.PUBLISH : HMSAction.SUBSCRIBE;\n  }\n\n  addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver {\n    return this.nativeConnection.addTransceiver(track, init);\n  }\n\n  async createOffer(tracks?: Map<string, TrackState>, options?: RTCOfferOptions): Promise<RTCSessionDescriptionInit> {\n    try {\n      const offer = await this.nativeConnection.createOffer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createOffer offer=${JSON.stringify(offer, null, 1)}`);\n      return enableOpusDtx(fixMsid(offer, tracks));\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateOfferFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async createAnswer(options: RTCOfferOptions | undefined = undefined): Promise<RTCSessionDescriptionInit> {\n    try {\n      const answer = await this.nativeConnection.createAnswer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createAnswer answer=${JSON.stringify(answer, null, 1)}`);\n      return answer;\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateAnswerFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setLocalDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setLocalDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setLocalDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetLocalDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setRemoteDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setRemoteDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetRemoteDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    HMSLogger.d(TAG, `[role=${this.role}] addIceCandidate candidate=${JSON.stringify(candidate, null, 1)}`);\n    await this.nativeConnection.addIceCandidate(candidate);\n  }\n\n  public get remoteDescription(): RTCSessionDescription | null {\n    return this.nativeConnection.remoteDescription;\n  }\n\n  getSenders(): Array<RTCRtpSender> {\n    return this.nativeConnection.getSenders();\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    this.nativeConnection.removeTrack(sender);\n  }\n\n  async setMaxBitrate(maxBitrate: number, track: HMSLocalTrack) {\n    const sender = this.getSenders().find(s => s?.track?.id === track.getTrackIDBeingSent());\n\n    if (sender) {\n      const params = sender.getParameters();\n      if (params.encodings.length > 0) {\n        params.encodings[0].maxBitrate = maxBitrate * 1000;\n      }\n      await sender.setParameters(params);\n    } else {\n      HMSLogger.w(\n        TAG,\n        `no sender found to setMaxBitrate for track - ${track.trackId}, sentTrackId - ${track.getTrackIDBeingSent()}`,\n      );\n    }\n  }\n\n  async getStats() {\n    return await this.nativeConnection.getStats();\n  }\n\n  async close() {\n    this.nativeConnection.close();\n  }\n}\n", "export const RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';\nexport const API_DATA_CHANNEL = 'ion-sfu';\nexport const ANALYTICS_BUFFER_SIZE = 100;\n\n/**\n * Maximum number of retries that transport-layer will try\n * before giving up on the connection and returning a failure\n *\n * Refer https://100ms.atlassian.net/browse/HMS-2369\n */\nexport const MAX_TRANSPORT_RETRIES = 5;\nexport const MAX_TRANSPORT_RETRY_DELAY = 60;\n\nexport const DEFAULT_SIGNAL_PING_TIMEOUT = 12000;\nexport const DEFAULT_SIGNAL_PING_INTERVAL = 1000;\nexport const PONG_RESPONSE_TIMES_SIZE = 5;\n\nexport const SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID = 'SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID';\nexport const SUBSCRIBE_TIMEOUT = 60000;\n\nexport const RTC_STATS_MONITOR_INTERVAL = 1000;\n\nexport const MAINTAIN_TRACK_HISTORY = false;\n\nexport const CLIENT_ANAYLTICS_PROD_ENDPOINT = 'https://event.100ms.live/v2/client/report';\nexport const CLIENT_ANAYLTICS_QA_ENDPOINT = 'https://event-nonprod.100ms.live/v2/client/report';\nexport const CLIENT_ANAYLTICS_STORAGE_LIMIT = 100;\n\nexport const HMSEvents = {\n  DEVICE_CHANGE: 'device-change',\n  LOCAL_AUDIO_ENABLED: 'local-audio-enabled',\n  LOCAL_VIDEO_ENABLED: 'local-video-enabled',\n  STATS_UPDATE: 'stats-update', // emitted by HMSWebrtcInternals\n  RTC_STATS_UPDATE: 'rtc-stats-update', // emitted by RTCStatsMonitor\n  TRACK_DEGRADED: 'track-degraded',\n  TRACK_RESTORED: 'track-restored',\n  TRACK_AUDIO_LEVEL_UPDATE: 'track-audio-level-update',\n  LOCAL_AUDIO_SILENCE: 'local-audio-silence',\n  ANALYTICS: 'analytics',\n  AUDIO_PLUGIN_FAILED: 'audio-plugin-failed',\n  POLICY_CHANGE: 'policy-change',\n  LOCAL_ROLE_UPDATE: 'local-role-update',\n  AUDIO_TRACK_UPDATE: 'audio-track-update',\n  AUDIO_TRACK_ADDED: 'audio-track-added',\n  AUDIO_TRACK_REMOVED: 'audio-track-removed',\n  AUTOPLAY_ERROR: 'autoplay-error',\n};\n", "import HMSConnection from '../index';\nimport { ISignal } from '../../signal/ISignal';\nimport { IPublishConnectionObserver } from './IPublishConnectionObserver';\nimport { HMSConnectionRole } from '../model';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport HMSTransport from '../../transport';\nimport { HMSLocalTrack } from '../../media/tracks';\n\nconst TAG = 'HMSPublishConnection';\n\nexport default class HMSPublishConnection extends HMSConnection {\n  private readonly observer: IPublishConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n  private readonly transport: HMSTransport;\n\n  constructor(\n    signal: ISignal,\n    config: RTCConfiguration,\n    observer: IPublishConnectionObserver,\n    transport: HMSTransport,\n  ) {\n    super(HMSConnectionRole.Publish, signal);\n    this.observer = observer;\n    this.transport = transport;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {\n      protocol: 'SCTP',\n    });\n\n    this.nativeConnection.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        signal.trickle(this.role, candidate);\n      }\n    };\n\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n  }\n\n  initAfterJoin() {\n    this.nativeConnection.onnegotiationneeded = async () => {\n      HMSLogger.d(TAG, `onnegotiationneeded`);\n      await this.observer.onRenegotiationNeeded();\n    };\n  }\n\n  trackUpdate(track: HMSLocalTrack) {\n    this.transport.trackUpdate(track);\n  }\n}\n", "import { HMSTrack } from '../tracks/HMSTrack';\n\nexport default class HMSMediaStream {\n  readonly nativeStream: MediaStream;\n  readonly id: string;\n\n  readonly tracks = new Array<HMSTrack>();\n\n  constructor(nativeStream: MediaStream) {\n    this.nativeStream = nativeStream;\n    this.id = nativeStream.id;\n  }\n}\n", "import HMSSubscribeConnection from '../../connection/subscribe';\nimport HMSMediaStream from './HMSMediaStream';\nimport HMSLogger from '../../utils/logger';\nimport { HMSSimulcastLayer } from '../../interfaces';\n\n/** @internal */\nexport default class HMSRemoteStream extends HMSMediaStream {\n  private readonly connection: HMSSubscribeConnection;\n  private audio = true;\n  private video = HMSSimulcastLayer.NONE;\n\n  constructor(nativeStream: MediaStream, connection: HMSSubscribeConnection) {\n    super(nativeStream);\n    this.connection = connection;\n  }\n\n  setAudio(enabled: boolean) {\n    if (this.audio === enabled) {\n      return;\n    }\n\n    this.audio = enabled;\n    this.syncWithApiChannel(false);\n  }\n\n  /**\n   * Sets the video layer after receiving new state from SFU. This is used when server side subscribe\n   * degradation is ON.\n   * @param layer is simulcast layer to be set\n   * @param identifier is stream identifier to be printed in logs\n   */\n  setVideoLayerLocally(layer: HMSSimulcastLayer, identifier: string) {\n    this.video = layer;\n    HMSLogger.d(`[Remote stream] ${identifier} - ${this.id}`, `Setting layer field to - ${layer}`);\n  }\n\n  /**\n   * Sets the video layer and updates the track state to SFU via api datachannel. This is used when client\n   * side subscribe degradation is ON or client unsubscribes the current track.\n   * @param layer is simulcast layer to be set\n   * @param identifier is stream identifier to be printed in logs\n   */\n  setVideoLayer(layer: HMSSimulcastLayer, identifier: string) {\n    this.setVideoLayerLocally(layer, identifier);\n    HMSLogger.d(`[Remote stream] ${identifier} - ${this.id}`, `Switching to ${layer} layer`);\n    this.syncWithApiChannel();\n  }\n\n  getSimulcastLayer() {\n    return this.video;\n  }\n\n  isAudioSubscribed() {\n    return this.audio;\n  }\n\n  /**\n   * send the expected state of the stream to SFU over data channel.\n   * the video field is optional from SFU's perspective but audio should be\n   * passed everytime.\n   * We don't pass in the video field, if only audio needs to subscribed/unsubscribed,\n   * else there is a chance of mismatch between states in case of degradation. If\n   * a degraded track is (audio) muted, a video layer false will be sent which to\n   * SFU will appear as if remove sink was called and the track will never be recovered.\n   * @private\n   */\n  private syncWithApiChannel(sendVideoLayer = true) {\n    const data: SubscriptionMessage = {\n      streamId: this.id,\n      audio: this.audio,\n    };\n    if (sendVideoLayer) {\n      data.video = this.video;\n      data.framerate = this.video;\n    }\n    this.connection.sendOverApiDataChannel(JSON.stringify(data));\n  }\n}\n\ninterface SubscriptionMessage {\n  streamId: string;\n  audio: boolean;\n  framerate?: HMSSimulcastLayer;\n  video?: HMSSimulcastLayer;\n}\n", "import HMSLogger from '../utils/logger';\n\nexport interface DataChannelObserver {\n  onMessage(value: string): void;\n}\n\nexport default class HMSDataChannel {\n  private readonly TAG = 'HMSDataChannel';\n  private readonly nativeChannel: RTCDataChannel;\n  private readonly observer: DataChannelObserver;\n  private readonly metadata: string;\n\n  public get id() {\n    return this.nativeChannel.id;\n  }\n\n  public get label() {\n    return this.nativeChannel.label;\n  }\n\n  public get readyState() {\n    return this.nativeChannel.readyState;\n  }\n\n  constructor(nativeChannel: RTCDataChannel, observer: DataChannelObserver, metadata = '') {\n    this.nativeChannel = nativeChannel;\n    this.observer = observer;\n    this.metadata = metadata;\n\n    nativeChannel.onmessage = e => {\n      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);\n      this.observer.onMessage(e.data);\n    };\n  }\n\n  send(message: string) {\n    HMSLogger.d(this.TAG, `[${this.metadata}] Sending [size=${message.length}] message=${message}`);\n    this.nativeChannel.send(message);\n  }\n\n  close() {\n    this.nativeChannel.close();\n  }\n}\n", "import HMSMediaStream from '../streams/HMSMediaStream';\nimport { HMSTrackType } from './HMSTrackType';\n\nexport type HMSTrackSource = 'regular' | 'screen' | 'plugin' | 'audioplaylist' | 'videoplaylist' | string;\n\nexport abstract class HMSTrack {\n  /**\n   * @internal\n   */\n  readonly stream: HMSMediaStream;\n  source?: HMSTrackSource;\n  peerId?: string;\n\n  /**\n   * @internal to print as a helpful identifier alongside logs\n   */\n  logIdentifier = '';\n\n  /** The native mediastream track, for local, this changes on mute/unmute(for video),\n   * and on device change.\n   * @internal */\n  nativeTrack: MediaStreamTrack;\n\n  /**\n   * Firefox doesn't respect the track id as sent from the backend when calling peerconnection.ontrack callback. This\n   * breaks correlation of future track updates from backend. So we're storing the sdp track id as present in the\n   * original offer along with the track as well and will let this override the native track id for any correlation\n   * purpose.\n   * This applies for remote tracks only.\n   * @internal */\n  private sdpTrackId?: string;\n\n  /**\n   * @internal\n   * The local track id is changed on mute/unmute or when device id changes, this is abstracted as an internal\n   * detail of HMSTrack and the variable is used for this enacapsulation where the first track id is remembered\n   * and treated as the fixed track id for this HMSTrack. This simplifies things for the user of the sdk who\n   * do not have to worry about changing track IDs.\n   * This applies for local tracks only.\n   */\n  private firstTrackId?: string;\n\n  abstract readonly type: HMSTrackType;\n\n  public get enabled(): boolean {\n    return this.nativeTrack.enabled;\n  }\n\n  /**\n   * firstTrackId => encapsulates change in local track ids\n   * sdpTrackId => fixes remote track updates correlation on firefox\n   */\n  public get trackId(): string {\n    return this.firstTrackId || this.sdpTrackId || this.nativeTrack.id;\n  }\n\n  getMediaTrackSettings(): MediaTrackSettings {\n    return this.nativeTrack.getSettings();\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    this.nativeTrack.enabled = value;\n  }\n\n  protected constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: HMSTrackSource) {\n    this.stream = stream;\n    this.nativeTrack = track;\n    this.source = source;\n  }\n\n  /**\n   * @internal\n   */\n  setSdpTrackId(sdpTrackId: string) {\n    this.sdpTrackId = sdpTrackId;\n  }\n\n  /**\n   * @internal\n   */\n  protected setFirstTrackId(trackId: string) {\n    this.firstTrackId = trackId;\n  }\n\n  /**\n   * @internal\n   * take care of -\n   * 1. https://bugs.chromium.org/p/chromium/issues/detail?id=1232649\n   * 2. stopping any tracks\n   * 3. plugins related cleanups and stopping\n   */\n  cleanup() {\n    this.nativeTrack?.stop();\n  }\n}\n", "export enum HMSTrackType {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n}\n", "import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\nimport HMSLogger from '../../utils/logger';\n\nexport class HMSAudioTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.AUDIO;\n  private audioElement: HTMLAudioElement | null = null;\n  private outputDevice?: MediaDeviceInfo;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'audio') {\n      throw new Error(\"Expected 'track' kind = 'audio'\");\n    }\n  }\n\n  getVolume() {\n    return this.audioElement ? this.audioElement.volume * 100 : null;\n  }\n\n  setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    // Don't subscribe to audio when volume is 0\n    this.subscribeToAudio(value === 0 ? false : this.enabled);\n    if (this.audioElement) {\n      this.audioElement.volume = value / 100;\n    }\n  }\n\n  setAudioElement(element: HTMLAudioElement | null) {\n    this.audioElement = element;\n  }\n\n  /**\n   * @internal\n   * @returns {HTMLAudioElement | null}\n   */\n  getAudioElement(): HTMLAudioElement | null {\n    return this.audioElement;\n  }\n\n  getOutputDevice() {\n    return this.outputDevice;\n  }\n\n  cleanup() {\n    super.cleanup();\n    if (this.audioElement) {\n      this.audioElement.srcObject = null;\n      this.audioElement.remove();\n      this.audioElement = null;\n    }\n  }\n\n  async setOutputDevice(device: MediaDeviceInfo) {\n    if (!this.audioElement) {\n      HMSLogger.d('audio-track', 'no audio element to set output');\n      return;\n    }\n    try {\n      // @ts-ignore\n      if (typeof this.audioElement.setSinkId === 'function') {\n        // @ts-ignore\n        await this.audioElement?.setSinkId(device.deviceId);\n        this.outputDevice = device;\n      }\n    } catch (error) {\n      HMSLogger.d('audio-track', error);\n    }\n  }\n\n  /**\n   * removes the track from the audio element of the track\n   * @experimental - Not production ready\n   */\n  removeSink() {\n    // @ts-ignore\n    if (this.audioElement && window.HMS?.AUDIO_SINK) {\n      this.audioElement.srcObject = null;\n      this.subscribeToAudio(false);\n    }\n  }\n\n  /**\n   * add track if not already added\n   * @experimental - Not production ready\n   */\n  addSink() {\n    // @ts-ignore\n    if (!this.nativeTrack || !this.audioElement || !window.HMS?.AUDIO_SINK) {\n      return;\n    }\n    const srcObject = this.audioElement.srcObject;\n    if (srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getAudioTracks()[0]?.id;\n      if (existingTrackID === this.nativeTrack.id) {\n        // it's already attached, no need to attach again\n        return;\n      }\n    }\n    this.audioElement.srcObject = new MediaStream([this.nativeTrack]);\n    this.subscribeToAudio(true);\n  }\n\n  protected subscribeToAudio(value: boolean) {\n    if (this.stream instanceof HMSRemoteStream) {\n      this.stream.setAudio(value);\n    }\n  }\n}\n", "import { HMSAudioTrack } from './HMSAudioTrack';\n\nexport class HMSRemoteAudioTrack extends HMSAudioTrack {\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n    await super.setEnabled(value);\n    this.subscribeToAudio(value);\n  }\n}\n", "import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\n\nexport class HMSVideoTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.VIDEO;\n  private sinkCount = 0;\n\n  /**\n   * sink=video element rendering the video\n   */\n  hasSinks() {\n    return this.sinkCount > 0;\n  }\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'video') {\n      throw new Error(\"Expected 'track' kind = 'video'\");\n    }\n  }\n\n  /**\n   * attaches the track to the passed in video element\n   * @param videoElement\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.nativeTrack);\n  }\n\n  /**\n   * removes the track from the passed in video element\n   * @param videoElement\n   */\n  removeSink(videoElement: HTMLVideoElement) {\n    if (videoElement.srcObject !== null) {\n      videoElement.srcObject = null;\n      if (this.sinkCount > 0) {\n        this.sinkCount--;\n      }\n    }\n  }\n\n  protected addSinkInternal(videoElement: HTMLVideoElement, track: MediaStreamTrack) {\n    const srcObject = videoElement.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === track.id) {\n        // it's already attached, attaching again would just cause flickering\n        return;\n      }\n    }\n    videoElement.srcObject = new MediaStream([track]);\n    this.sinkCount++;\n  }\n}\n", "import { HMSVideoTrack } from './HMSVideoTrack';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\nimport { HMSSimulcastLayer, SimulcastLayerDefinition } from '../../interfaces/simulcast-layers';\nimport HMSLogger from '../../utils/logger';\nimport { MAINTAIN_TRACK_HISTORY } from '../../utils/constants';\n\nexport class HMSRemoteVideoTrack extends HMSVideoTrack {\n  private _degraded = false;\n  private _degradedAt: Date | null = null;\n  private _layerDefinitions: SimulcastLayerDefinition[] = [];\n  private history = new TrackHistory();\n\n  public get degraded() {\n    return this._degraded;\n  }\n\n  public get degradedAt() {\n    return this._degradedAt;\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n\n    await super.setEnabled(value);\n  }\n\n  preferLayer(layer: HMSSimulcastLayer) {\n    if (!this.shouldSendVideoLayer(layer, 'preferLayer')) {\n      return;\n    }\n    (this.stream as HMSRemoteStream).setVideoLayer(layer, this.logIdentifier);\n    this.pushInHistory(`uiPreferLayer-${layer}`);\n  }\n\n  getSimulcastLayer() {\n    return (this.stream as HMSRemoteStream).getSimulcastLayer();\n  }\n\n  addSink(videoElement: HTMLVideoElement) {\n    super.addSink(videoElement);\n    this.updateLayer('addSink');\n    this.pushInHistory('uiSetLayer-high');\n  }\n\n  removeSink(videoElement: HTMLVideoElement) {\n    super.removeSink(videoElement);\n    this.updateLayer('removeSink');\n    this._degraded = false;\n    this.pushInHistory('uiSetLayer-none');\n  }\n\n  /**\n   * Method to get available simulcast definitions for the track\n   * @returns {SimulcastLayerDefinition[]}\n   */\n  getSimulcastDefinitions() {\n    // send a clone to store as it will freeze the object from further updates\n    return [...this._layerDefinitions];\n  }\n\n  /** @internal */\n  setSimulcastDefinitons(definitions: SimulcastLayerDefinition[]) {\n    this._layerDefinitions = definitions;\n  }\n\n  /** @internal\n   * SFU will change track's layer(degrade or restore) and tell the sdk to update\n   * it locally.\n   * */\n  setLayerFromServer(layer: HMSSimulcastLayer, isDegraded: boolean) {\n    this._degraded = isDegraded;\n    this._degradedAt = isDegraded ? new Date() : this._degradedAt;\n    // No need to send preferLayer update, as server has done it already\n    (this.stream as HMSRemoteStream).setVideoLayerLocally(layer, this.logIdentifier);\n    this.pushInHistory(`sfuLayerUpdate-${layer}`);\n  }\n\n  /** @internal\n   * If degradation is being managed by sdk, sdk will let the track know of status\n   * post which it'll set it as well and send prefer layer message to SFU.\n   * */\n  setDegradedFromSdk(value: boolean) {\n    this._degraded = value;\n    this._degradedAt = value ? new Date() : this._degradedAt;\n    this.updateLayer('sdkDegradation');\n    this.pushInHistory(value ? 'sdkDegraded-none' : 'sdkRecovered-high');\n  }\n\n  private updateLayer(source: string) {\n    const newLayer = this.degraded || !this.hasSinks() ? HMSSimulcastLayer.NONE : HMSSimulcastLayer.HIGH;\n    if (!this.shouldSendVideoLayer(newLayer, source)) {\n      return;\n    }\n    (this.stream as HMSRemoteStream).setVideoLayer(newLayer, this.logIdentifier);\n  }\n\n  private pushInHistory(action: string) {\n    if (MAINTAIN_TRACK_HISTORY) {\n      this.history.push({ name: action, layer: this.getSimulcastLayer(), degraded: this.degraded });\n    }\n  }\n\n  /**\n   * given the new layer, figure out if the update should be sent to server or not.\n   * It won't be sent if the track is already on the targetLayer. If the track is\n   * degraded though and the target layer is none, update will be sent.\n   * If there are tracks degraded on a page and user paginates away to other page,\n   * it's necessary to send the layer none message to SFU so it knows that the app\n   * is no longer interested in the track and doesn't recover degraded tracks on non\n   * visible pages.\n   *\n   * TODO: if track is degraded, send the update if target layer is lower than current layer\n   * @private\n   */\n  private shouldSendVideoLayer(targetLayer: HMSSimulcastLayer, source: string) {\n    const currLayer = this.getSimulcastLayer();\n    if (this.degraded && targetLayer === HMSSimulcastLayer.NONE) {\n      return true;\n    }\n    if (currLayer === targetLayer) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier}`,\n        `Not sending update, already on layer ${targetLayer}, source=${source}`,\n      );\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * to store history of everything that happened to a remote track which decides\n * it's current layer and degraded status.\n */\nclass TrackHistory {\n  history: Record<string, any>[] = [];\n\n  push(action: Record<string, any>) {\n    action.time = new Date().toISOString().split('T')[1];\n    this.history.push(action);\n  }\n}\n", "import HMSConnection from '../index';\nimport { ISignal } from '../../signal/ISignal';\nimport ISubscribeConnectionObserver from './ISubscribeConnectionObserver';\nimport { HMSConnectionRole } from '../model';\nimport HMSRemoteStream from '../../media/streams/HMSRemoteStream';\nimport HMSDataChannel from '../HMSDataChannel';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport { HMSRemoteAudioTrack } from '../../media/tracks/HMSRemoteAudioTrack';\nimport { HMSRemoteVideoTrack } from '../../media/tracks/HMSRemoteVideoTrack';\nimport HMSLogger from '../../utils/logger';\nimport { getSdpTrackIdForMid } from '../../utils/session-description';\n\nexport default class HMSSubscribeConnection extends HMSConnection {\n  private readonly TAG = '[HMSSubscribeConnection]';\n  private readonly remoteStreams = new Map<string, HMSRemoteStream>();\n\n  private readonly observer: ISubscribeConnectionObserver;\n\n  readonly nativeConnection: RTCPeerConnection;\n\n  private pendingMessageQueue: string[] = [];\n\n  private apiChannel?: HMSDataChannel;\n\n  private initNativeConnectionCallbacks() {\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n\n    this.nativeConnection.ondatachannel = e => {\n      if (e.channel.label !== API_DATA_CHANNEL) {\n        // TODO: this.observer.onDataChannel(e.channel);\n        return;\n      }\n\n      this.apiChannel = new HMSDataChannel(\n        e.channel,\n        {\n          onMessage: (value: string) => {\n            this.observer.onApiChannelMessage(value);\n          },\n        },\n        `role=${this.role}`,\n      );\n\n      e.channel.onopen = this.handlePendingApiMessages;\n    };\n\n    this.nativeConnection.onicecandidate = e => {\n      if (e.candidate !== null) {\n        this.signal.trickle(this.role, e.candidate);\n      }\n    };\n\n    this.nativeConnection.ontrack = e => {\n      const stream = e.streams[0];\n      const streamId = stream.id;\n      if (!this.remoteStreams.has(streamId)) {\n        const remote = new HMSRemoteStream(stream, this);\n        this.remoteStreams.set(streamId, remote);\n\n        stream.onremovetrack = e => {\n          /*\n           * this match has to be with nativetrack.id instead of track.trackId as the latter refers to sdp track id for\n           * ease of correlating update messages coming from the backend. The two track ids are usually the same, but\n           * can be different for some browsers. checkout sdptrackid field in HMSTrack for more details.\n           */\n          const toRemoveTrackIdx = remote.tracks.findIndex(track => track.nativeTrack.id === e.track.id);\n          if (toRemoveTrackIdx >= 0) {\n            const toRemoveTrack = remote.tracks[toRemoveTrackIdx];\n            this.observer.onTrackRemove(toRemoveTrack);\n            remote.tracks.splice(toRemoveTrackIdx, 1);\n\n            // If the length becomes 0 we assume that stream is removed entirely\n            if (remote.tracks.length === 0) {\n              this.remoteStreams.delete(streamId);\n            }\n          }\n        };\n      }\n\n      const remote = this.remoteStreams.get(streamId)!;\n      const TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;\n      const track = new TrackCls(remote, e.track);\n      const trackId = getSdpTrackIdForMid(this.remoteDescription, e.transceiver?.mid);\n      trackId && track.setSdpTrackId(trackId);\n      remote.tracks.push(track);\n      this.observer.onTrackAdd(track);\n    };\n  }\n\n  constructor(signal: ISignal, config: RTCConfiguration, observer: ISubscribeConnectionObserver) {\n    super(HMSConnectionRole.Subscribe, signal);\n    this.observer = observer;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.initNativeConnectionCallbacks();\n  }\n\n  sendOverApiDataChannel(message: string) {\n    if (this.apiChannel && this.apiChannel.readyState === 'open') {\n      this.apiChannel.send(message);\n    } else {\n      HMSLogger.w(this.TAG, `API Data channel not ${this.apiChannel ? 'open' : 'present'}, queueing`, message);\n      this.pendingMessageQueue.push(message);\n    }\n  }\n\n  async close() {\n    await super.close();\n    this.apiChannel?.close();\n  }\n\n  private handlePendingApiMessages = () => {\n    if (this.pendingMessageQueue.length > 0) {\n      HMSLogger.d(this.TAG, 'Found pending message queue, sending messages');\n      this.pendingMessageQueue.forEach(msg => this.sendOverApiDataChannel(msg));\n      this.pendingMessageQueue.length = 0;\n    }\n  };\n}\n", "import { InitConfig } from './models';\nimport HMSLogger from '../../utils/logger';\nimport { userAgent } from '../../utils/support';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\n\nconst TAG = 'InitService';\n\nexport default class InitService {\n  private static handleError(response: Response, body: { code: number; message: string }) {\n    switch (response.status) {\n      case 404:\n        throw ErrorFactory.InitAPIErrors.EndpointUnreachable(HMSAction.INIT, body.message || response.statusText);\n      case 200:\n        break;\n      default:\n        throw ErrorFactory.InitAPIErrors.ServerErrors(\n          body.code || response.status,\n          HMSAction.INIT,\n          body.message || response?.statusText,\n        );\n    }\n  }\n\n  static async fetchInitConfig(\n    token: string,\n    peerId: string,\n    initEndpoint = 'https://prod-init.100ms.live',\n    region = '',\n  ): Promise<InitConfig> {\n    HMSLogger.d(TAG, `fetchInitConfig: initEndpoint=${initEndpoint} token=${token} peerId=${peerId} region=${region} `);\n    const url = getUrl(initEndpoint, peerId, region);\n    try {\n      const response = await fetch(url, {\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n      const config = await response.json();\n      this.handleError(response, config);\n      HMSLogger.d(TAG, `config is ${JSON.stringify(config, null, 2)}`);\n      return transformInitConfig(config);\n    } catch (err) {\n      const error = err as Error;\n      if (['Failed to fetch', 'NetworkError'].some(message => error.message.includes(message))) {\n        throw ErrorFactory.InitAPIErrors.EndpointUnreachable(HMSAction.INIT, error.message);\n      }\n      throw error;\n    }\n  }\n}\n\nexport function getUrl(endpoint: string, peerId: string, region?: string) {\n  try {\n    const url = new URL('/init', endpoint);\n\n    if (region && region.trim().length > 0) {\n      url.searchParams.set('region', region.trim());\n    }\n    url.searchParams.set('peer_id', peerId);\n    url.searchParams.set('user_agent', userAgent);\n    return url.toString();\n  } catch (err) {\n    const error = err as Error;\n    HMSLogger.e(TAG, error.name, error.message);\n    throw error;\n  }\n}\n\nexport function transformInitConfig(config: any): InitConfig {\n  return {\n    ...config,\n    rtcConfiguration: { ...config.rtcConfiguration, iceServers: config.rtcConfiguration?.ice_servers },\n  };\n}\n", "import { v4 as uuid } from 'uuid';\nimport { ISignal } from '../ISignal';\nimport { ISignalEventsObserver } from '../ISignalEventsObserver';\nimport {\n  Track,\n  AcceptRoleChangeParams,\n  RequestForRoleChangeParams,\n  TrackUpdateRequestParams,\n  RemovePeerRequest,\n  MultiTrackUpdateRequestParams,\n  StartRTMPOrRecordingRequestParams,\n  UpdatePeerRequestParams,\n  HLSRequestParams,\n  BroadcastResponse,\n  HLSTimedMetadataParams,\n} from '../interfaces';\nimport { HMSConnectionRole, HMSTrickle } from '../../connection/model';\nimport { convertSignalMethodtoErrorAction, HMSSignalMethod, JsonRpcRequest, JsonRpcResponse } from './models';\nimport { PromiseCallbacks } from '../../utils/promise';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport AnalyticsEvent from '../../analytics/AnalyticsEvent';\nimport {\n  DEFAULT_SIGNAL_PING_TIMEOUT,\n  DEFAULT_SIGNAL_PING_INTERVAL,\n  PONG_RESPONSE_TIMES_SIZE,\n} from '../../utils/constants';\nimport Message from '../../sdk/models/HMSMessage';\nimport { HMSException } from '../../error/HMSException';\nimport { Queue } from '../../utils/queue';\nimport { isPageHidden } from '../../utils/support';\nimport { sleep } from '../../utils/timer-utils';\n\nexport default class JsonRpcSignal implements ISignal {\n  readonly TAG = '[ SIGNAL ]: ';\n  readonly observer: ISignalEventsObserver;\n  readonly pongResponseTimes = new Queue<number>(PONG_RESPONSE_TIMES_SIZE);\n\n  /**\n   * Sometimes before [join] is completed, there could be a lot of trickles\n   * Sending [HMSTrickle]` before [join] web socket message leads to\n   * error: [500] no rtc transport exists for this Peer\n   *\n   * We keep a list of pending trickles and send them immediately after [join]\n   * is done.\n   */\n  private isJoinCompleted = false;\n  private pendingTrickle: Array<HMSTrickle> = [];\n\n  private socket: WebSocket | null = null;\n\n  private callbacks = new Map<string, PromiseCallbacks<string>>();\n\n  private _isConnected = false;\n  private id = 0;\n\n  public get isConnected(): boolean {\n    return this._isConnected;\n  }\n\n  public setIsConnected(newValue: boolean, reason = '') {\n    HMSLogger.d(this.TAG, `isConnected set id: ${this.id}, oldValue: ${this._isConnected}, newValue: ${newValue} }`);\n    if (this._isConnected === newValue) {\n      return;\n    }\n\n    if (this._isConnected && !newValue) {\n      // went offline\n      this._isConnected = newValue;\n      this.observer.onOffline(reason);\n    } else if (!this._isConnected && newValue) {\n      // went online\n      this._isConnected = newValue;\n      this.observer.onOnline();\n    }\n  }\n\n  constructor(observer: ISignalEventsObserver) {\n    this.observer = observer;\n    window.addEventListener('offline', () => {\n      HMSLogger.d(this.TAG, 'Window network offline');\n      this.setIsConnected(false, 'Window network offline');\n    });\n\n    window.addEventListener('online', () => {\n      HMSLogger.d(this.TAG, 'Window network online');\n      this.observer.onNetworkOnline();\n    });\n\n    this.onCloseHandler = this.onCloseHandler.bind(this);\n    this.onMessageHandler = this.onMessageHandler.bind(this);\n  }\n\n  getPongResponseTimes() {\n    return this.pongResponseTimes.toList();\n  }\n\n  private async internalCall<T>(method: string, params: any): Promise<T> {\n    const id = uuid();\n    const message = { method, params, id, jsonrpc: '2.0' } as JsonRpcRequest;\n\n    this.socket?.send(JSON.stringify(message));\n\n    try {\n      const response = await new Promise<any>((resolve, reject) => {\n        this.callbacks.set(id, { resolve, reject });\n      });\n\n      return response;\n    } catch (ex) {\n      const error = ex as HMSException;\n      throw ErrorFactory.WebsocketMethodErrors.ServerErrors(\n        Number((error as HMSException).code),\n        convertSignalMethodtoErrorAction(method as HMSSignalMethod),\n        (error as HMSException).message,\n      );\n    }\n  }\n\n  private notify(method: string, params: any) {\n    const message = { method, params };\n\n    this.socket?.send(JSON.stringify(message));\n  }\n\n  open(uri: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // cleanup\n      if (this.socket) {\n        this.socket.removeEventListener('close', this.onCloseHandler);\n        this.socket.removeEventListener('message', this.onMessageHandler);\n      }\n\n      this.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test\n\n      const errorListener = (error: Event) => {\n        /**\n         * there was an error received from websocket leading to disconnection, this can happen either if server\n         * disconnects the websocket for some reason, there is a network disconnect or a firewall/antivirus on user's\n         * device is breaking the websocket connecting(which can happen even after a successful connect).\n         */\n        HMSLogger.e(this.TAG, 'Error from websocket', error);\n        reject(\n          ErrorFactory.WebSocketConnectionErrors.FailedToConnect(\n            HMSAction.JOIN,\n            `Error opening websocket connection - ${error}`,\n          ),\n        );\n      };\n      this.socket.addEventListener('error', errorListener);\n\n      const openHandler = () => {\n        resolve();\n        this.setIsConnected(true);\n        this.id++;\n        this.socket?.removeEventListener('open', openHandler);\n        this.socket?.removeEventListener('error', errorListener);\n        this.pingPongLoop(this.id);\n      };\n\n      this.socket.addEventListener('open', openHandler);\n      this.socket.addEventListener('close', this.onCloseHandler);\n      this.socket.addEventListener('message', this.onMessageHandler);\n    });\n  }\n\n  async close(): Promise<void> {\n    // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1\n    if (this.socket) {\n      this.socket.close(1000, 'Normal Close');\n      this.setIsConnected(false, 'code: 1000, normal websocket close');\n      this.socket.removeEventListener('close', this.onCloseHandler);\n      this.socket.removeEventListener('message', this.onMessageHandler);\n    } else {\n      this.setIsConnected(false, 'websocket not connected yet');\n    }\n  }\n\n  async join(\n    name: string,\n    data: string,\n    disableVidAutoSub: boolean,\n    serverSubDegrade: boolean,\n    offer?: RTCSessionDescriptionInit,\n  ): Promise<RTCSessionDescriptionInit> {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.JOIN,\n        'Failed to send join over WS connection',\n      );\n    }\n    const params = { name, disableVidAutoSub, data, offer, server_sub_degrade: serverSubDegrade };\n    const response: RTCSessionDescriptionInit = await this.internalCall(HMSSignalMethod.JOIN, params);\n\n    this.isJoinCompleted = true;\n    this.pendingTrickle.forEach(({ target, candidate }) => this.trickle(target, candidate));\n    this.pendingTrickle.length = 0;\n\n    HMSLogger.d(this.TAG, `join: response=${JSON.stringify(response, null, 1)}`);\n    return response;\n  }\n\n  trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit) {\n    if (this.isJoinCompleted) {\n      this.notify(HMSSignalMethod.TRICKLE, { target, candidate });\n    } else {\n      this.pendingTrickle.push({ target, candidate });\n    }\n  }\n\n  async offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit> {\n    const response = await this.call(HMSSignalMethod.OFFER, {\n      desc,\n      tracks: Object.fromEntries(tracks),\n    });\n    return response as RTCSessionDescriptionInit;\n  }\n\n  answer(desc: RTCSessionDescriptionInit) {\n    this.notify(HMSSignalMethod.ANSWER, { desc });\n  }\n\n  trackUpdate(tracks: Map<string, Track>) {\n    this.notify(HMSSignalMethod.TRACK_UPDATE, { version: '1.0', tracks: Object.fromEntries(tracks) });\n  }\n\n  async broadcast(message: Message) {\n    return await this.call<BroadcastResponse>(HMSSignalMethod.BROADCAST, {\n      version: '1.0',\n      ...message.toSignalParams(),\n    });\n  }\n\n  leave() {\n    this.notify(HMSSignalMethod.LEAVE, { version: '1.0' });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.call(HMSSignalMethod.END_ROOM, { lock, reason });\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.isConnected) {\n      throw Error(`${this.TAG} not connected. Could not send event ${event}`);\n    }\n    this.notify(HMSSignalMethod.ANALYTICS, event.toSignalParams());\n  }\n\n  ping(timeout: number): Promise<number> {\n    const pingTime = Date.now();\n    const timer: Promise<number> = new Promise(resolve => {\n      setTimeout(() => {\n        resolve(Date.now() - pingTime);\n      }, timeout + 1);\n    });\n    const pongTimeDiff = this.internalCall(HMSSignalMethod.PING, { timestamp: pingTime })\n      .then(() => Date.now() - pingTime)\n      .catch(() => Date.now() - pingTime);\n\n    return Promise.race([timer, pongTimeDiff]);\n  }\n\n  async requestRoleChange(params: RequestForRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);\n  }\n\n  async acceptRoleChangeRequest(params: AcceptRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE, params);\n  }\n\n  async requestTrackStateChange(params: TrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.TRACK_UPDATE_REQUEST, params);\n  }\n\n  async requestMultiTrackStateChange(params: MultiTrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.CHANGE_TRACK_MUTE_STATE_REQUEST, params);\n  }\n\n  async removePeer(params: RemovePeerRequest) {\n    await this.call(HMSSignalMethod.PEER_LEAVE_REQUEST, params);\n  }\n\n  async startRTMPOrRecording(params: StartRTMPOrRecordingRequestParams) {\n    await this.call(HMSSignalMethod.START_RTMP_OR_RECORDING_REQUEST, { version: '1.0', ...params });\n  }\n\n  async stopRTMPAndRecording() {\n    await this.call(HMSSignalMethod.STOP_RTMP_AND_RECORDING_REQUEST, { version: '1.0' });\n  }\n\n  async startHLSStreaming(params: HLSRequestParams): Promise<void> {\n    await this.call(HMSSignalMethod.START_HLS_STREAMING, { version: '1.0', ...params });\n  }\n\n  async stopHLSStreaming(params?: HLSRequestParams): Promise<void> {\n    await this.call(HMSSignalMethod.STOP_HLS_STREAMING, { version: '1.0', ...params });\n  }\n\n  async sendHLSTimedMetadata(params?: HLSTimedMetadataParams): Promise<void> {\n    await this.call(HMSSignalMethod.HLS_TIMED_METADATA, { version: '1.0', ...params });\n  }\n\n  async updatePeer(params: UpdatePeerRequestParams) {\n    await this.call(HMSSignalMethod.UPDATE_PEER_METADATA, { version: '1.0', ...params });\n  }\n\n  private onCloseHandler(event: CloseEvent) {\n    HMSLogger.d(`Websocket closed code=${event.code}`);\n    this.setIsConnected(false, `code: ${event.code}${event.code !== 1000 ? ', unexpected websocket close' : ''}`);\n    // https://stackoverflow.com/questions/18803971/websocket-onerror-how-to-read-error-description\n\n    // @DISCUSS: onOffline would have thrown error already.\n    // if (event.code !== 1000) {\n    //   HMSLogger.e(`Websocket closed code=${event.code}, reason=${event.reason}`);\n    //   // 1000 code indicated `Normal Closure` [https://tools.ietf.org/html/rfc6455#section-7.4.1]\n    //   const error = ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n    //     HMSAction.INIT,\n    //     `${event.reason} [${event.code}]`,\n    //   );\n    //   this.observer.onFailure(error);\n    // }\n  }\n\n  private onMessageHandler(event: MessageEvent) {\n    const text: string = event.data;\n    const response = JSON.parse(text);\n\n    if (response.id) {\n      this.handleResponseWithId(response);\n    } else if (response.method) {\n      this.handleResponseWithMethod(response);\n    } else {\n      throw Error(`WebSocket message has no 'method' or 'id' field, message=${response}`);\n    }\n  }\n\n  private handleResponseWithId(response: any) {\n    /** This is a response to [call] */\n    const typedResponse = response as JsonRpcResponse;\n    const id: string = typedResponse.id;\n    if (this.callbacks.has(id)) {\n      const cb = this.callbacks.get(id)!;\n      this.callbacks.delete(id);\n      if (typedResponse.result) {\n        cb.resolve(typedResponse.result);\n      } else {\n        cb.reject(typedResponse.error);\n      }\n    } else {\n      this.observer.onNotification(typedResponse);\n    }\n  }\n\n  private handleResponseWithMethod(response: any) {\n    switch (response.method) {\n      case HMSSignalMethod.OFFER:\n        this.observer.onOffer(response.params);\n        break;\n      case HMSSignalMethod.TRICKLE:\n        this.observer.onTrickle(response.params);\n        break;\n      case HMSSignalMethod.SERVER_ERROR:\n        this.observer.onServerError(\n          ErrorFactory.WebsocketMethodErrors.ServerErrors(\n            Number(response.params.code),\n            HMSAction.NONE,\n            response.params.message,\n          ),\n        );\n        break;\n      case HMSSignalMethod.SERVER_WARNING:\n        HMSLogger.w(this.TAG, response.params);\n        break;\n      default:\n        this.observer.onNotification(response);\n        break;\n    }\n  }\n\n  private async pingPongLoop(id: number) {\n    const pingTimeout = window.HMS?.PING_TIMEOUT || DEFAULT_SIGNAL_PING_TIMEOUT;\n    if (this.isConnected) {\n      const pongTimeDiff = await this.ping(pingTimeout);\n      this.pongResponseTimes.enqueue(pongTimeDiff);\n      if (pongTimeDiff > pingTimeout) {\n        HMSLogger.d(this.TAG, `Pong timeout ${id}, pageHidden=${isPageHidden()}`);\n        if (this.id === id) {\n          this.setIsConnected(false, 'ping pong failure');\n        }\n      } else {\n        setTimeout(() => this.pingPongLoop(id), window.HMS?.PING_INTERVAL || DEFAULT_SIGNAL_PING_INTERVAL);\n      }\n    }\n  }\n\n  private async call<T>(method: HMSSignalMethod, params: Record<string, any>): Promise<T> {\n    const MAX_RETRIES = 3;\n    let error: HMSException = ErrorFactory.WebsocketMethodErrors.ServerErrors(500, method, `Default ${method} error`);\n\n    for (let i = 0; i < MAX_RETRIES; i++) {\n      try {\n        HMSLogger.d(this.TAG, `Try number ${i + 1} sending ${method}`, params);\n        return await this.internalCall(method, params);\n      } catch (err) {\n        error = err as HMSException;\n        HMSLogger.e(this.TAG, `Failed sending ${method}`, { method, try: i + 1, params, error });\n        const shouldRetry = parseInt(`${error.code / 100}`) === 5 || error.code === 429;\n        if (!shouldRetry) {\n          break;\n        }\n\n        const delay = (2 + Math.random() * 2) * 1000;\n        await sleep(delay);\n      }\n    }\n    HMSLogger.e(`Sending ${method} over WS failed after ${MAX_RETRIES} retries`, { method, params, error });\n    throw error;\n  }\n}\n", "import { HMSAction } from '../../error/ErrorFactory';\n\nexport interface JsonRpcRequest {\n  id: string;\n  method: string;\n  params: Map<string, any>;\n}\n\nexport interface JsonRpcResponse {\n  id: string;\n  result: any;\n  error: {\n    code: number;\n    message: string;\n  };\n}\n\nexport enum HMSSignalMethod {\n  JOIN = 'join',\n  OFFER = 'offer',\n  ANSWER = 'answer',\n  TRICKLE = 'trickle',\n  TRACK_UPDATE = 'track-update',\n  BROADCAST = 'broadcast',\n  ANALYTICS = 'analytics',\n  SERVER_ERROR = 'on-error',\n  SERVER_WARNING = 'on-warning',\n  SDK_NOTIFICATION = 'sdk-notification',\n  LEAVE = 'leave',\n  END_ROOM = 'end-room',\n  PING = 'ping',\n  ROLE_CHANGE_REQUEST = 'role-change-request',\n  ROLE_CHANGE = 'role-change',\n  TRACK_UPDATE_REQUEST = 'track-update-request',\n  PEER_LEAVE_REQUEST = 'peer-leave-request',\n  CHANGE_TRACK_MUTE_STATE_REQUEST = 'change-track-mute-state-request',\n  START_RTMP_OR_RECORDING_REQUEST = 'rtmp-start',\n  STOP_RTMP_AND_RECORDING_REQUEST = 'rtmp-stop',\n  UPDATE_PEER_METADATA = 'peer-update',\n  START_HLS_STREAMING = 'hls-start',\n  STOP_HLS_STREAMING = 'hls-stop',\n  HLS_TIMED_METADATA = 'hls-timed-metadata',\n}\n\nexport function convertSignalMethodtoErrorAction(method: HMSSignalMethod): HMSAction {\n  switch (method) {\n    case HMSSignalMethod.JOIN:\n      return HMSAction.JOIN;\n    case HMSSignalMethod.OFFER:\n      return HMSAction.PUBLISH;\n    case HMSSignalMethod.ANSWER:\n      return HMSAction.SUBSCRIBE;\n    case HMSSignalMethod.TRACK_UPDATE:\n      return HMSAction.TRACK;\n    default:\n      return HMSAction.NONE;\n  }\n}\n", "export interface IQueue<T> {\n  size(): number;\n  enqueue(item: T): void;\n  dequeue(): T | undefined;\n}\n\nexport class Queue<T> implements IQueue<T> {\n  protected storage: T[] = [];\n\n  constructor(private capacity: number = Infinity) {}\n\n  size() {\n    return this.storage.length;\n  }\n\n  toList() {\n    return this.storage.slice(0);\n  }\n\n  enqueue(item: T) {\n    if (this.size() === this.capacity) {\n      this.dequeue();\n    }\n    this.storage.push(item);\n  }\n\n  dequeue() {\n    return this.storage.shift();\n  }\n\n  aggregate<R>(aggregationFn: (values: T[]) => R): R {\n    return aggregationFn(this.storage);\n  }\n}\n", "/**\n * Delay for a @see ms amount of time\n * @param ms -- time in milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  if (ms < 0) {\n    throw Error('`ms` should be a positive integer');\n  }\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Debounce Fn - Function to limit the number of executions of the passed in\n * function in a given time duration\n * @param fn Function to be called\n * @param delay time by which the function execution has to be delayed\n * @returns {void}\n */\nexport function debounce(fn: () => void, delay = 300) {\n  let timer: any | undefined;\n  return function (...args: []) {\n    clearTimeout(timer);\n    timer = undefined;\n    //@ts-ignore\n    //eslint-disable-next-line\n    const context = this;\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, delay);\n  };\n}\n", "import { HMSAudioTrackSettings as IHMSAudioTrackSettings, HMSAudioCodec } from '../../interfaces';\nimport { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\n\nexport class HMSAudioTrackSettingsBuilder {\n  private _volume = 1.0;\n  private _codec?: HMSAudioCodec = HMSAudioCodec.OPUS;\n  private _maxBitrate?: number = 32;\n  private _deviceId = 'default';\n  private _advanced: Array<MediaTrackConstraintSet> = [\n    // @ts-ignore\n    { googEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { googExperimentalEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { autoGainControl: { exact: true } },\n    // @ts-ignore\n    { noiseSuppression: { exact: true } },\n    // @ts-ignore\n    { googHighpassFilter: { exact: true } },\n    // @ts-ignore\n    { googAudioMirroring: { exact: true } },\n  ];\n\n  volume(volume: number) {\n    if (!(0.0 <= volume && volume <= 1.0)) {\n      throw Error('volume can only be in range [0.0, 1.0]');\n    }\n    this._volume = volume;\n    return this;\n  }\n\n  codec(codec?: HMSAudioCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxBitrate(maxBitrate?: number) {\n    if (maxBitrate && maxBitrate <= 0) {\n      throw Error('maxBitrate should be >= 1');\n    }\n    this._maxBitrate = maxBitrate;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);\n  }\n}\n\nexport class HMSAudioTrackSettings implements IHMSAudioTrackSettings, IAnalyticsPropertiesProvider {\n  readonly volume?: number;\n  readonly codec?: HMSAudioCodec;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced?: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    volume?: number,\n    codec?: HMSAudioCodec,\n    maxBitrate?: number,\n    deviceId?: string,\n    advanced?: Array<MediaTrackConstraintSet>,\n  ) {\n    this.volume = volume;\n    this.codec = codec;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      deviceId: this.deviceId,\n      advanced: this.advanced,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      audio_bitrate: this.maxBitrate,\n      audio_codec: this.codec,\n    };\n  }\n}\n", "import { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { HMSVideoTrackSettings as IHMSVideoTrackSettings, HMSVideoCodec } from '../../interfaces';\n\nexport class HMSVideoTrackSettingsBuilder {\n  private _width?: number = 320;\n  private _height?: number = 180;\n  private _codec?: HMSVideoCodec = HMSVideoCodec.VP8;\n  private _maxFramerate?: number = 30;\n  private _maxBitrate?: number = 150;\n  private _deviceId?: string;\n  private _advanced: Array<MediaTrackConstraintSet> = [];\n\n  setWidth(width?: number) {\n    this._width = width;\n    return this;\n  }\n\n  setHeight(height?: number) {\n    this._height = height;\n    return this;\n  }\n\n  codec(codec?: HMSVideoCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxFramerate(maxFramerate?: number) {\n    if (maxFramerate && maxFramerate <= 0) {\n      throw Error('maxFramerate should be >= 1');\n    }\n    this._maxFramerate = maxFramerate;\n    return this;\n  }\n\n  /**\n   * @param useDefault Ignored if maxBitrate is valid.\n   * If true and maxBitrate is undefined - sets a default value.\n   * If false and maxBitrate is undefined - sets undefined.\n   */\n  maxBitrate(maxBitrate?: number, useDefault = true) {\n    if (typeof maxBitrate === 'number' && maxBitrate <= 0) {\n      throw Error('maxBitrate should be >= 1');\n    }\n    this._maxBitrate = maxBitrate;\n    if (!this._maxBitrate && useDefault) {\n      this._maxBitrate = 150_000;\n    }\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSVideoTrackSettings(\n      this._width,\n      this._height,\n      this._codec,\n      this._maxFramerate,\n      this._deviceId,\n      this._advanced,\n      this._maxBitrate,\n    );\n  }\n}\n\nexport class HMSVideoTrackSettings implements IHMSVideoTrackSettings, IAnalyticsPropertiesProvider {\n  readonly width?: number;\n  readonly height?: number;\n  readonly codec?: HMSVideoCodec;\n  readonly maxFramerate?: number;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced?: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    width?: number,\n    height?: number,\n    codec?: HMSVideoCodec,\n    maxFramerate?: number,\n    deviceId?: string | undefined,\n    advanced?: Array<MediaTrackConstraintSet>,\n    maxBitrate?: number,\n  ) {\n    this.width = width;\n    this.height = height;\n    this.codec = codec;\n    this.maxFramerate = maxFramerate;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.maxFramerate,\n      deviceId: this.deviceId,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      width: this.width,\n      height: this.height,\n      video_bitrate: this.maxBitrate,\n      framerate: this.maxFramerate,\n      video_codec: this.codec,\n    };\n  }\n}\n", "import { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from './HMSVideoTrackSettings';\nimport { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from './HMSAudioTrackSettings';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\n\nexport class HMSTrackSettingsBuilder {\n  private _video: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _audio: HMSAudioTrackSettings | null = new HMSAudioTrackSettingsBuilder().build();\n  private _screen: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _simulcast = false;\n\n  video(video: HMSVideoTrackSettings | null) {\n    this._video = video;\n    return this;\n  }\n\n  audio(audio: HMSAudioTrackSettings | null) {\n    this._audio = audio;\n    return this;\n  }\n\n  screen(screen: HMSVideoTrackSettings | null) {\n    this._screen = screen;\n    return this;\n  }\n\n  simulcast(enabled: boolean) {\n    this._simulcast = enabled;\n    return this;\n  }\n\n  build() {\n    if (this._audio === null && this._video === null) {\n      throw ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK);\n    }\n\n    if (this._video === null && this._simulcast) {\n      throw ErrorFactory.TracksErrors.InvalidVideoSettings(\n        HMSAction.TRACK,\n        'Cannot enable simulcast when no video settings are provided',\n      );\n    }\n\n    return new HMSTrackSettings(this._video, this._audio, this._simulcast, this._screen || undefined);\n  }\n}\n\nexport class HMSTrackSettings implements IAnalyticsPropertiesProvider {\n  readonly video: HMSVideoTrackSettings | null;\n  readonly audio: HMSAudioTrackSettings | null | undefined;\n  readonly screen: HMSVideoTrackSettings | null;\n  readonly simulcast: boolean;\n\n  constructor(\n    video: HMSVideoTrackSettings | null,\n    audio: HMSAudioTrackSettings | null | undefined,\n    simulcast: boolean,\n    screen: HMSVideoTrackSettings | null = null,\n  ) {\n    this.video = video;\n    this.audio = audio;\n    this.simulcast = simulcast;\n    this.screen = screen;\n  }\n\n  toAnalyticsProperties() {\n    let properties = {\n      audio_enabled: this.audio !== null,\n      video_enabled: this.video !== null,\n    };\n\n    if (this.audio) {\n      properties = { ...this.audio.toAnalyticsProperties(), ...properties };\n    }\n\n    if (this.video) {\n      properties = { ...this.video.toAnalyticsProperties(), ...properties };\n    }\n\n    return properties;\n  }\n}\n", "/**\n * Method names for incoming RPC messages from BIZ Signal through Websocket.\n * Used to call the corresponding handler/manager in NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport enum HMSNotificationMethod {\n  ROOM_STATE = 'room-state',\n  PEER_JOIN = 'on-peer-join',\n  PEER_LEAVE = 'on-peer-leave',\n  PEER_LIST = 'peer-list',\n  TRACK_METADATA_ADD = 'on-track-add',\n  TRACK_UPDATE = 'on-track-update',\n  CHANGE_TRACK_MUTE_STATE_UPDATE = 'on-change-track-mute-state-request',\n  ACTIVE_SPEAKERS = 'active-speakers',\n  CONNECTION_QUALITY = 'on-connection-quality-update',\n  SFU_STATS = 'sfu-stats',\n  ON_SFU_TRACK_LAYER_UPDATE = 'on-track-layer-update',\n  BROADCAST = 'on-broadcast',\n  ROLE_CHANGE = 'on-role-change',\n  POLICY_CHANGE = 'on-policy-change',\n  ROLE_CHANGE_REQUEST = 'on-role-change-request',\n  TRACK_UPDATE_REQUEST = 'on-track-update-request',\n  PEER_UPDATE = 'on-peer-update',\n  PEER_LEAVE_REQUEST = 'on-peer-leave-request',\n  UNSUPPORTED = 'unsupported',\n  RTMP_START = 'on-rtmp-start',\n  RTMP_STOP = 'on-rtmp-stop',\n  RECORDING_START = 'on-record-start',\n  RECORDING_STOP = 'on-record-stop',\n  HLS_START = 'on-hls-start',\n  HLS_STOP = 'on-hls-stop',\n}\n", "import { HMSAudioListener, HMSPeerUpdate, HMSSpeaker, HMSUpdateListener } from '../../interfaces';\nimport { HMSAudioTrack } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport { SpeakerList } from '../HMSNotifications';\n\nexport class ActiveSpeakerManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener, public audioListener?: HMSAudioListener) {}\n\n  handleActiveSpeakers(speakerList: SpeakerList) {\n    const speakers = speakerList['speaker-list'];\n    const hmsSpeakers: HMSSpeaker[] = speakers.map(speaker => ({\n      audioLevel: speaker.level,\n      peer: this.store.getPeerById(speaker.peer_id)!,\n      track: this.store.getTrackById(speaker.track_id) as HMSAudioTrack,\n    }));\n\n    this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    this.store.updateSpeakers(hmsSpeakers);\n    const dominantSpeaker = speakers[0];\n\n    if (dominantSpeaker) {\n      const dominantSpeakerPeer = this.store.getPeerById(dominantSpeaker.peer_id);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer!);\n    } else {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);\n    }\n  }\n}\n", "import { HMSRole } from '../../interfaces';\nimport { HMSMessage } from '../../interfaces/message';\nimport { ISignalParamsProvider } from '../../signal/ISignalSendParamsProvider';\nimport { SendMessage } from '../../notification-manager';\nimport { HMSPeer } from './peer';\n\nexport default class Message implements HMSMessage, ISignalParamsProvider<SendMessage> {\n  sender?: HMSPeer;\n  recipientPeer?: HMSPeer;\n  recipientRoles?: HMSRole[];\n  message: any;\n  time: Date;\n  type: string;\n\n  constructor({ sender, message, type = 'chat', recipientPeer, recipientRoles, time }: HMSMessage) {\n    this.sender = sender;\n    this.message = message;\n    this.type = type;\n    this.recipientPeer = recipientPeer;\n    this.recipientRoles = recipientRoles;\n    this.time = time;\n  }\n\n  toSignalParams() {\n    const roles = this.recipientRoles?.map(role => role.name);\n    const peer = this.recipientPeer?.peerId;\n    const sendParams: SendMessage = {\n      info: {\n        message: this.message,\n        type: this.type,\n      },\n    };\n    if (roles?.length) {\n      sendParams.roles = roles;\n    }\n    if (peer) {\n      sendParams.peer_id = peer;\n    }\n    return sendParams;\n  }\n}\n", "import { HMSPeer as IHMSPeer } from '../../../interfaces/peer';\nimport { HMSRole } from '../../../interfaces/role';\nimport { HMSAudioTrack, HMSTrack, HMSVideoTrack } from '../../../media/tracks';\n\nexport type HMSPeerInit = {\n  peerId: string;\n  name: string;\n  isLocal: boolean;\n  customerUserId?: string;\n  metadata?: string;\n  role?: HMSRole;\n  joinedAt?: Date;\n  fromRoomState?: boolean;\n};\n\nexport class HMSPeer implements IHMSPeer {\n  readonly peerId: string;\n  readonly isLocal: boolean;\n  name: string;\n  customerUserId?: string = '';\n  metadata?: string = '';\n  audioTrack?: HMSAudioTrack;\n  videoTrack?: HMSVideoTrack;\n  auxiliaryTracks: HMSTrack[] = [];\n  role?: HMSRole;\n  joinedAt?: Date;\n\n  constructor({ peerId, name, isLocal, customerUserId, metadata, role, joinedAt }: HMSPeerInit) {\n    this.name = name;\n    this.peerId = peerId;\n    this.isLocal = isLocal;\n    this.customerUserId = customerUserId;\n    this.metadata = metadata;\n    this.joinedAt = joinedAt;\n\n    if (role) {\n      this.role = role;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  updateRole(newRole: HMSRole) {\n    this.role = newRole;\n  }\n  /**\n   * @internal\n   */\n  updateName(newName: string) {\n    this.name = newName;\n  }\n  /**\n   * @internal\n   */\n  updateMetadata(data: string) {\n    this.metadata = data;\n  }\n}\n", "import { v4 as uuidv4 } from 'uuid';\n\nexport default class HMSIdFactory {\n  static makePeerId = () => uuidv4();\n}\n", "import { HMSLocalPeer as IHMSLocalPeer } from '../../../interfaces/peer';\nimport { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../../../media/tracks';\nimport HMSIdFactory from '../../../utils/id-factory';\n\ntype HMSLocalPeerInit = Omit<HMSPeerInit, 'isLocal' | 'peerId'>;\n\nexport class HMSLocalPeer extends HMSPeer implements IHMSLocalPeer {\n  isLocal = true;\n  declare audioTrack?: HMSLocalAudioTrack;\n  declare videoTrack?: HMSLocalVideoTrack;\n  auxiliaryTracks: HMSLocalTrack[] = [];\n\n  constructor(peerData: HMSLocalPeerInit) {\n    super({ ...peerData, peerId: HMSIdFactory.makePeerId(), isLocal: true });\n  }\n}\n", "import { HMSRemotePeer as IHMSRemotePeer } from '../../../interfaces/peer';\nimport { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack } from '../../../media/tracks';\n\ntype HMSRemotePeerInit = Omit<HMSPeerInit, 'isLocal'>;\n\nexport class HMSRemotePeer extends HMSPeer implements IHMSRemotePeer {\n  isLocal = false;\n  declare audioTrack?: HMSRemoteAudioTrack;\n  declare videoTrack?: HMSRemoteVideoTrack;\n  auxiliaryTracks: HMSRemoteTrack[] = [];\n  fromRoomState = false;\n\n  constructor(peerData: HMSRemotePeerInit) {\n    super({ ...peerData, isLocal: false });\n    this.fromRoomState = !!peerData.fromRoomState;\n  }\n}\n", "import { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { HMSUpdateListener } from '../../interfaces';\nimport Message from '../../sdk/models/HMSMessage';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { MessageNotification } from '../HMSNotifications';\n\nexport class BroadcastManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  handleNotification(method: string, notification: any) {\n    if (method !== HMSNotificationMethod.BROADCAST) {\n      return;\n    }\n    this.handleBroadcast(notification);\n  }\n\n  private handleBroadcast(messageNotification: MessageNotification) {\n    const notifPeer = messageNotification.peer;\n    const notifMessage = messageNotification.info;\n    const notifRoles = messageNotification.roles;\n\n    const sender = this.getSender(notifPeer);\n    const recipientPeer = messageNotification.private ? this.store.getLocalPeer() : undefined;\n    const recipientRoles = [];\n\n    if (notifRoles?.length) {\n      const knownRoles = this.store.getKnownRoles();\n      for (const role of notifRoles) {\n        knownRoles[role] && recipientRoles.push(knownRoles[role]);\n      }\n    }\n\n    const hmsMessage = new Message({\n      ...notifMessage,\n      sender,\n      recipientRoles,\n      recipientPeer,\n      time: new Date(messageNotification.timestamp),\n    });\n    HMSLogger.d(this.TAG, `Received Message from sender=${notifPeer?.peer_id}: `, hmsMessage);\n    this.listener?.onMessageReceived(hmsMessage);\n  }\n\n  private getSender(notifPeer?: MessageNotification['peer']) {\n    // If sender peerId is available in store, use that peer.\n    let sender = notifPeer ? this.store.getPeerById(notifPeer.peer_id) : undefined;\n    // If not available in store, use peer data from received broadcast message from Biz\n    // notifPeer can be undefined when message is sent via api\n    if (!sender && notifPeer) {\n      sender = new HMSPeer({\n        peerId: notifPeer.peer_id,\n        name: notifPeer.info.name,\n        isLocal: false,\n        customerUserId: notifPeer.info.user_id,\n        metadata: notifPeer.info.data,\n      });\n    }\n    return sender;\n  }\n}\n", "import { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { HMSUpdateListener } from '../..';\nimport { HMSTrackUpdate } from '../../interfaces';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { PeerListNotification, PeerNotification, PeriodicRoomState } from '../HMSNotifications';\nimport { PeerManager } from './PeerManager';\nimport { TrackManager } from './TrackManager';\n\n/**\n * Handles:\n * - Initial Peer List - get peer and track meta-data for peers who are already in the room when you join\n * - Reconnect Peer List - Handle peer and track changes in the room missed out due to reconnection\n *\n * Cases to handle in reconnect peer list:\n * - Add additional peers as peer join\n * - Remove missing peers as peer leave\n * - For existing peers:\n *    - Add new tracks as track add\n *    - Remove missing tracks as track remove\n *    - Track state change(enabled) as track update\n */\nexport class PeerListManager {\n  constructor(\n    private store: IStore,\n    private peerManager: PeerManager,\n    private trackManager: TrackManager,\n    public listener?: HMSUpdateListener,\n  ) {}\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  handleNotification(method: string, notification: any, isReconnecting: boolean) {\n    if (method === HMSNotificationMethod.PEER_LIST) {\n      const peerList = notification as PeerListNotification;\n      if (isReconnecting) {\n        HMSLogger.d(this.TAG, `RECONNECT_PEER_LIST event`, peerList);\n        this.handleReconnectPeerList(peerList);\n      } else {\n        // TODO: Don't call initial peerlist if atleast 1room state had happen\n        HMSLogger.d(this.TAG, `PEER_LIST event`, peerList);\n        this.handleInitialPeerList(peerList);\n      }\n    } else if (method === HMSNotificationMethod.ROOM_STATE) {\n      const roomState = notification as PeriodicRoomState;\n      this.handlePreviewRoomState(roomState);\n    }\n  }\n\n  private handleInitialPeerList = (peerList: PeerListNotification) => {\n    const peers = Object.values(peerList.peers);\n    this.peerManager.handlePeerList(peers);\n  };\n\n  private handleReconnectPeerList = (peerList: PeerListNotification) => {\n    this.handleRepeatedPeerList(peerList.peers);\n  };\n\n  private handlePreviewRoomState = (roomState: PeriodicRoomState) => {\n    if (!this.store.hasRoleDetailsArrived()) {\n      // we can't process the peers yet we don't know enough about them(role info)\n      return;\n    }\n    const roomPeers = roomState.peers;\n    if (roomPeers === null || roomPeers === undefined) {\n      // in this case, room state doesn't say anything about the peers,\n      // there can be optimisations in place to not send this field when it's unchanged from previously sent value.\n      // If there are no peers either roomState.peers will be empty object\n      // or peer_count will be 0(handled below)\n      if (roomState.peer_count === 0) {\n        this.handleRepeatedPeerList({});\n      }\n      return;\n    }\n    // we don't get tracks inside the peer object in room state, we're adding\n    // an empty value here so rest of the code flow can ignore this change, the below\n    // can be changed when tracks will be sent as a separate object in future\n    Object.keys(roomPeers).forEach(peer => {\n      roomPeers[peer].tracks = {};\n      roomPeers[peer].is_from_room_state = true;\n    });\n    this.handleRepeatedPeerList(roomPeers);\n  };\n\n  private handleRepeatedPeerList = (peersMap: Record<string, PeerNotification>) => {\n    const currentPeerList = this.store.getRemotePeers();\n    const peers = Object.values(peersMap);\n    const peersToRemove = currentPeerList.filter(hmsPeer => !peersMap[hmsPeer.peerId]);\n    HMSLogger.d(this.TAG, { peersToRemove });\n\n    // Send peer-leave updates to all the missing peers\n    peersToRemove.forEach(peer => {\n      const peerNotification: PeerNotification = {\n        peer_id: peer.peerId,\n        role: peer.role?.name || '',\n        info: {\n          name: peer.name,\n          data: peer.metadata || '',\n          user_id: peer.customerUserId || '',\n        },\n        tracks: {},\n      };\n\n      this.peerManager.handlePeerLeave(peerNotification);\n    });\n\n    // Check for any tracks which are added/removed\n    peers.forEach(newPeerNotification => {\n      const oldPeer = this.store.getPeerById(newPeerNotification.peer_id);\n      const newPeerTrackStates = Object.values(newPeerNotification.tracks);\n\n      if (oldPeer) {\n        // Peer already present in room, we take diff between the tracks\n        const tracks = this.store.getPeerTracks(oldPeer.peerId);\n\n        // Remove all the tracks which are not present in the peer.tracks\n        tracks.forEach(track => {\n          if (!newPeerNotification.tracks[track.trackId]) {\n            this.removePeerTrack(oldPeer, track.trackId);\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, oldPeer);\n          }\n        });\n\n        // Add track-metadata for all the new tracks\n        newPeerTrackStates.forEach(trackData => {\n          if (!this.store.getTrackById(trackData.track_id)) {\n            // NOTE: We assume that, once the connection is re-established,\n            //  transport layer will send a native onTrackAdd\n            this.store.setTrackState({\n              peerId: oldPeer.peerId,\n              trackInfo: trackData,\n            });\n          }\n        });\n\n        // Handle RTC track add and track state change.\n        this.trackManager.handleTrackUpdate({\n          peer: { info: newPeerNotification.info, peer_id: newPeerNotification.peer_id },\n          tracks: newPeerNotification.tracks,\n        });\n\n        // Update peer's role locally, new role is received from the reconnect peer-list\n        this.peerManager.handlePeerUpdate(newPeerNotification);\n      } else {\n        // New peer joined while reconnecting\n        this.peerManager.handlePeerJoin(newPeerNotification);\n      }\n    });\n  };\n\n  private removePeerTrack(peer: HMSPeer, trackId: string) {\n    if (peer.audioTrack?.trackId === trackId) {\n      peer.audioTrack = undefined;\n    } else if (peer.videoTrack?.trackId === trackId) {\n      peer.videoTrack = undefined;\n    } else {\n      const trackIndex = peer.auxiliaryTracks.findIndex(track => track.trackId === trackId);\n      trackIndex >= 0 && peer.auxiliaryTracks.splice(trackIndex, 1);\n    }\n  }\n}\n", "export const convertDateNumToDate = (dateNum?: number): Date | undefined => {\n  return dateNum ? new Date(dateNum) : undefined;\n};\n", "import { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { HMSPeer, HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemotePeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { PeerNotification } from '../HMSNotifications';\nimport { TrackManager } from './TrackManager';\nimport { convertDateNumToDate } from '../../utils/date';\n\n/**\n * Handles:\n * - New peer join\n * - Peer Leave\n * - Role update for peer\n *\n * Notes:\n * - Peer join comes with track meta-data,\n * we add it to the store and call TrackManager to process it when RTC Track comes in.\n */\nexport class PeerManager {\n  constructor(private store: IStore, private trackManager: TrackManager, public listener?: HMSUpdateListener) {}\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.PEER_JOIN: {\n        const peer = notification as PeerNotification;\n        this.handlePeerJoin(peer);\n        break;\n      }\n\n      case HMSNotificationMethod.PEER_LEAVE: {\n        const peer = notification as PeerNotification;\n        this.handlePeerLeave(peer);\n        break;\n      }\n      case HMSNotificationMethod.PEER_UPDATE:\n        this.handlePeerUpdate(notification as PeerNotification);\n        break;\n      default:\n        break;\n    }\n  }\n\n  handlePeerList = (peers: PeerNotification[]) => {\n    if (peers.length === 0) {\n      return;\n    }\n    const hmsPeers: HMSRemotePeer[] = [];\n    const newPeers = new Set(peers.map(peer => peer.peer_id));\n    this.store.getRemotePeers().forEach(({ peerId, fromRoomState }) => {\n      /**\n       * Remove only if the peer join happened from preview roomstate update. This will prevent the peer joined\n       * from peer-join event post join from being removed from the store.\n       */\n      if (!newPeers.has(peerId) && fromRoomState) {\n        this.store.removePeer(peerId);\n      }\n    });\n    for (const peer of peers) {\n      hmsPeers.push(this.makePeer(peer));\n    }\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LIST, hmsPeers);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerJoin = (peer: PeerNotification) => {\n    const hmsPeer = this.makePeer(peer);\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_JOINED, hmsPeer);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerLeave = (peer: PeerNotification) => {\n    const hmsPeer = this.store.getPeerById(peer.peer_id);\n    this.store.removePeer(peer.peer_id);\n    HMSLogger.d(this.TAG, `PEER_LEAVE event`, peer, this.store.getPeers());\n\n    if (!hmsPeer) {\n      return;\n    }\n\n    if (hmsPeer.audioTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.audioTrack, hmsPeer);\n    }\n\n    if (hmsPeer.videoTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.videoTrack, hmsPeer);\n    }\n\n    hmsPeer.auxiliaryTracks?.forEach(track => {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n    });\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LEFT, hmsPeer);\n  };\n\n  handlePeerUpdate(notification: PeerNotification) {\n    const peer = this.store.getPeerById(notification.peer_id);\n\n    if (!peer) {\n      return;\n    }\n\n    if (peer.role && peer.role.name !== notification.role) {\n      const newRole = this.store.getPolicyForRole(notification.role);\n      peer.updateRole(newRole);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, peer);\n    }\n    this.handlePeerInfoUpdate({ peer, ...notification.info });\n  }\n\n  handlePeerInfoUpdate({ peer, name, data }: { peer?: HMSPeer; name?: string; data?: string }) {\n    if (!peer) {\n      return;\n    }\n    if (name && peer.name !== name) {\n      peer.updateName(name);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.NAME_UPDATED, peer);\n    }\n    if (data && peer.metadata !== data) {\n      peer.updateMetadata(data);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.METADATA_UPDATED, peer);\n    }\n  }\n\n  private makePeer(peer: PeerNotification) {\n    const hmsPeer = new HMSRemotePeer({\n      peerId: peer.peer_id,\n      name: peer.info.name,\n      customerUserId: peer.info.user_id,\n      metadata: peer.info.data,\n      role: this.store.getPolicyForRole(peer.role),\n      joinedAt: convertDateNumToDate(peer.joined_at),\n      fromRoomState: !!peer.is_from_room_state,\n    });\n\n    this.store.addPeer(hmsPeer);\n    HMSLogger.d(this.TAG, `adding to the peerList`, hmsPeer);\n\n    for (const trackId in peer.tracks) {\n      this.store.setTrackState({\n        peerId: peer.peer_id,\n        trackInfo: peer.tracks[trackId],\n      });\n    }\n    return hmsPeer;\n  }\n}\n", "import { IStore } from '../../sdk/store';\nimport { PolicyParams } from '../HMSNotifications';\nimport { PublishParams } from '../../interfaces';\nimport { EventBus } from '../../events/EventBus';\n\n/**\n * Handles:\n * - Set policy with publishParams, simulcast layers to store\n * - Emit 'local-peer-role-update' to trigger RoleChangeManager to publish/unpublish local tracks\n * - Emit 'policy-change' to finish preview before calling listener.onPreview\n */\nexport class PolicyChangeManager {\n  constructor(private store: IStore, private eventBus: EventBus) {}\n\n  handlePolicyChange(params: PolicyParams) {\n    const localPeer = this.store.getLocalPeer();\n\n    if (localPeer && !localPeer.role) {\n      const newRole = params.known_roles[params.name];\n      localPeer.updateRole(newRole);\n    }\n\n    this.store.setKnownRoles(params.known_roles);\n    this.store.getRoom().templateId = params.template_id;\n    // handle when role is not present in known_roles\n    const publishParams = params.known_roles[params.name]?.publishParams;\n    this.store.setPublishParams(publishParams);\n    this.setSimulcastLayers(publishParams);\n\n    if (localPeer?.role && localPeer.role.name !== params.name) {\n      const newRole = this.store.getPolicyForRole(params.name);\n      const oldRole = localPeer.role;\n      localPeer.updateRole(newRole);\n      this.eventBus.localRoleUpdate.publish({ oldRole, newRole });\n    }\n    this.eventBus.policyChange.publish(params);\n  }\n\n  setSimulcastLayers(publishParams?: PublishParams) {\n    if (publishParams && Object.keys(publishParams).length > 0) {\n      const { videoSimulcastLayers, screenSimulcastLayers } = publishParams;\n      this.store.setVideoSimulcastLayers(videoSimulcastLayers);\n      this.store.setScreenshareSimulcastLayers(screenSimulcastLayers);\n    }\n  }\n}\n", "import { HMSLocalTrack, HMSTrackSource } from '../../media/tracks';\nimport { HMSRemotePeer, HMSRoleChangeRequest, HMSUpdateListener } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\nimport {\n  RoleChangeRequestParams,\n  TrackUpdateRequestNotification,\n  ChangeTrackMuteStateNotification,\n} from '../HMSNotifications';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\n\n/**\n * Handles request from remote peers to change something on the local side. For eg. role change, track mute/unmute.\n */\nexport class RequestManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.ROLE_CHANGE_REQUEST:\n        this.handleRoleChangeRequest(notification as RoleChangeRequestParams);\n        break;\n\n      case HMSNotificationMethod.TRACK_UPDATE_REQUEST:\n        this.handleTrackUpdateRequest(notification as TrackUpdateRequestNotification);\n        break;\n\n      case HMSNotificationMethod.CHANGE_TRACK_MUTE_STATE_UPDATE:\n        this.handleChangeTrackStateRequest(notification as ChangeTrackMuteStateNotification);\n        break;\n      default:\n        return;\n    }\n  }\n\n  private handleRoleChangeRequest(notification: RoleChangeRequestParams) {\n    const request: HMSRoleChangeRequest = {\n      requestedBy: notification.requested_by\n        ? (this.store.getPeerById(notification.requested_by) as HMSRemotePeer)\n        : undefined,\n      role: this.store.getPolicyForRole(notification.role),\n      token: notification.token,\n    };\n\n    this.listener?.onRoleChangeRequest(request);\n  }\n\n  // eslint-disable-next-line complexity\n  private handleTrackUpdateRequest(trackUpdateRequest: TrackUpdateRequestNotification) {\n    const { requested_by, track_id, mute } = trackUpdateRequest;\n    const peer = requested_by ? this.store.getPeerById(requested_by) : undefined;\n    const track = this.store.getLocalPeerTracks().find(track => track.publishedTrackId === track_id);\n\n    if (!track) {\n      return;\n    }\n\n    const sendNotification = () => {\n      this.listener?.onChangeTrackStateRequest({ requestedBy: peer as HMSRemotePeer, track, enabled: !mute });\n    };\n\n    if (mute) {\n      // if track is already in the same state as change state, do nothing\n      if (track.enabled === !mute) {\n        return;\n      }\n      /**\n       * Directly mute track when request arrives\n       */\n      track.setEnabled(!mute).then(sendNotification);\n    } else {\n      /**\n       * Notify UI to unmute for requesting consent\n       */\n      sendNotification();\n    }\n  }\n\n  private handleChangeTrackStateRequest(request: ChangeTrackMuteStateNotification) {\n    const { type, source, value, requested_by } = request;\n    const peer = requested_by ? this.store.getPeerById(requested_by) : undefined;\n\n    // value true means the track has to be muted\n    const enabled = !value;\n    const tracksToBeUpdated = this.getTracksToBeUpdated({ type, source, enabled });\n    //Do nothing if all tracks are already in same state as the request\n    if (tracksToBeUpdated.length === 0) {\n      return;\n    }\n    // if track is to be muted, mute and send the notification, otherwise send notification\n    if (!enabled) {\n      const promises: Promise<void>[] = [];\n\n      for (const track of tracksToBeUpdated) {\n        promises.push(track.setEnabled(false));\n      }\n      Promise.all(promises).then(() => {\n        this.listener?.onChangeMultiTrackStateRequest({\n          requestedBy: peer as HMSRemotePeer,\n          tracks: tracksToBeUpdated,\n          enabled: false,\n        });\n      });\n    } else {\n      this.listener?.onChangeMultiTrackStateRequest({\n        requestedBy: peer as HMSRemotePeer,\n        tracks: tracksToBeUpdated,\n        type,\n        source,\n        enabled: true,\n      });\n    }\n  }\n\n  /**\n   * Filter the local tracks based on type, source and enabled state\n   * @returns {HMSLocalTrack[]}\n   */\n  private getTracksToBeUpdated({\n    type,\n    source,\n    enabled,\n  }: {\n    type?: 'audio' | 'video';\n    source?: HMSTrackSource;\n    enabled: boolean;\n  }) {\n    const localPeerTracks = this.store.getLocalPeerTracks();\n    let tracks: HMSLocalTrack[] = localPeerTracks;\n    if (type) {\n      tracks = tracks.filter(track => track.type === type);\n    }\n    if (source) {\n      tracks = tracks.filter(track => track.source === source);\n    }\n    // filter out tracks which are already in the desired state\n    return tracks.filter(track => track.enabled !== enabled);\n  }\n}\n", "import {\n  HLSNotification,\n  PeerListNotification,\n  PeriodicRoomState,\n  RecordingNotification,\n  RoomState,\n  RTMPNotification,\n} from '../HMSNotifications';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { HMSHLS, HMSHLSRecording, HMSRoomUpdate, HMSUpdateListener } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\nimport { convertDateNumToDate } from '../../utils/date';\nimport { ServerError } from '../../interfaces/internal';\nimport { HMSException } from '../../error/HMSException';\nimport { HMSAction } from '../../error/ErrorFactory';\nimport HMSLogger from '../../utils/logger';\n\nexport class RoomUpdateManager {\n  private TAG = 'RoomUpdateManager';\n\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  // eslint-disable-next-line complexity\n  handleNotification(method: HMSNotificationMethod, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.PEER_LIST:\n        this.onRoomState((notification as PeerListNotification).room);\n        break;\n      case HMSNotificationMethod.RTMP_START:\n        this.onRTMPStart(notification as RTMPNotification);\n        break;\n      case HMSNotificationMethod.RTMP_STOP:\n        this.onRTMPStop(notification as RTMPNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_START:\n        this.onRecordingStart(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_STOP:\n        this.onRecordingStop(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.ROOM_STATE:\n        this.handlePreviewRoomState(notification as PeriodicRoomState);\n        break;\n      default:\n        this.onHLS(method, notification as HLSNotification);\n        break;\n    }\n  }\n\n  private handlePreviewRoomState(notification: PeriodicRoomState) {\n    const { room } = notification;\n    this.onRoomState(room, notification.peer_count);\n  }\n\n  private onRoomState(roomNotification: RoomState, peerCount?: number) {\n    const { recording, streaming, session_id, started_at, name } = roomNotification;\n    const room = this.store.getRoom();\n    room.peerCount = peerCount;\n    room.name = name;\n    room.recording.server.running = !!recording?.sfu.enabled;\n    room.recording.browser.running = !!recording?.browser.enabled;\n    room.rtmp.running = !!streaming?.rtmp?.enabled;\n    room.rtmp.startedAt = convertDateNumToDate(streaming?.rtmp?.started_at);\n    room.recording.server.startedAt = convertDateNumToDate(recording?.sfu.started_at);\n    room.recording.browser.startedAt = convertDateNumToDate(recording?.browser.started_at);\n    room.recording.hls = this.getPeerListHLSRecording(recording);\n    room.hls = this.convertHls(streaming?.hls);\n    room.sessionId = session_id;\n    room.startedAt = convertDateNumToDate(started_at);\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RECORDING_STATE_UPDATED, room);\n  }\n\n  private onRTMPStart(notification: RTMPNotification) {\n    this.setRTMPStatus(!notification.error?.code, notification);\n  }\n\n  private onRTMPStop(notification: RTMPNotification) {\n    this.setRTMPStatus(false, notification);\n  }\n\n  private onRecordingStart(notification: RecordingNotification) {\n    this.setRecordingStatus(!notification.error?.code, notification);\n  }\n\n  private onRecordingStop(notification: RecordingNotification) {\n    this.setRecordingStatus(false, notification);\n  }\n\n  private onHLS(method: string, notification: HLSNotification) {\n    if (![HMSNotificationMethod.HLS_START, HMSNotificationMethod.HLS_STOP].includes(method as HMSNotificationMethod)) {\n      return;\n    }\n    const room = this.store.getRoom();\n    notification.enabled = method === HMSNotificationMethod.HLS_START && !notification.error?.code;\n    room.hls = this.convertHls(notification);\n    room.recording.hls = this.getHLSRecording(notification);\n    this.listener?.onRoomUpdate(HMSRoomUpdate.HLS_STREAMING_STATE_UPDATED, room);\n  }\n\n  private convertHls(hlsNotification?: HLSNotification) {\n    const hls: HMSHLS = {\n      running: !!hlsNotification?.enabled,\n      variants: [],\n      error: this.toSdkError(hlsNotification?.error),\n    };\n    hlsNotification?.variants?.forEach(variant => {\n      hls.variants.push({\n        meetingURL: variant.meeting_url,\n        url: variant.url,\n        metadata: variant.metadata,\n        startedAt: convertDateNumToDate(variant.started_at),\n      });\n    });\n    return hls;\n  }\n\n  private getHLSRecording(hlsNotification?: HLSNotification): HMSHLSRecording {\n    let hlsRecording: HMSHLSRecording = { running: false };\n    if (hlsNotification?.hls_recording) {\n      hlsRecording = {\n        running: !!hlsNotification?.enabled,\n        singleFilePerLayer: !!hlsNotification.hls_recording?.single_file_per_layer,\n        hlsVod: !!hlsNotification.hls_recording?.hls_vod,\n        startedAt: convertDateNumToDate(hlsNotification?.variants?.[0].started_at),\n        error: this.toSdkError(hlsNotification.error),\n      };\n    }\n    return hlsRecording;\n  }\n\n  private getPeerListHLSRecording(recording?: RoomState['recording']): HMSHLSRecording {\n    const hlsNotification = recording?.hls;\n    return {\n      running: !!hlsNotification?.enabled,\n      startedAt: convertDateNumToDate(hlsNotification?.started_at),\n      singleFilePerLayer: !!hlsNotification?.config?.single_file_per_layer,\n      hlsVod: !!hlsNotification?.config?.hls_vod,\n    };\n  }\n\n  private setRecordingStatus(running: boolean, notification: RecordingNotification) {\n    const room = this.store.getRoom();\n    let action: HMSRoomUpdate;\n    if (notification.type === 'sfu') {\n      room.recording.server = {\n        running,\n        startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n        error: this.toSdkError(notification.error),\n      };\n      action = HMSRoomUpdate.SERVER_RECORDING_STATE_UPDATED;\n    } else {\n      room.recording.browser = {\n        running,\n        startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n        error: this.toSdkError(notification.error),\n      };\n      action = HMSRoomUpdate.BROWSER_RECORDING_STATE_UPDATED;\n    }\n    this.listener?.onRoomUpdate(action, room);\n  }\n\n  private setRTMPStatus(running: boolean, notification: RTMPNotification) {\n    const room = this.store.getRoom();\n    room.rtmp = {\n      running,\n      startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n      error: this.toSdkError(notification.error),\n    };\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RTMP_STREAMING_STATE_UPDATED, room);\n  }\n\n  private toSdkError(error?: ServerError): HMSException | undefined {\n    if (!error?.code) {\n      return undefined;\n    }\n    const errMsg = error.message || 'error in streaming/recording';\n    const sdkError = new HMSException(error.code, 'ServerErrors', HMSAction.NONE, errMsg, errMsg);\n    HMSLogger.e(this.TAG, 'error in streaming/recording', sdkError);\n    return sdkError;\n  }\n}\n", "import adapter from 'webrtc-adapter';\nimport { ErrorFactory, HMSAction } from './ErrorFactory';\nimport { HMSException } from './HMSException';\n\nexport enum HMSGetMediaActions {\n  UNKNOWN = 'unknown(video or audio)',\n  AUDIO = 'audio',\n  VIDEO = 'video',\n  AV = 'audio, video',\n  SCREEN = 'screen',\n}\n\nfunction getDefaultError(error: string, deviceInfo: string) {\n  const message = error.toLowerCase();\n  if (message.includes('device not found')) {\n    return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, error);\n  } else if (message.includes('permission denied')) {\n    return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, error);\n  } else {\n    return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, error);\n  }\n}\n\n/**\n * # Edge Cases:\n * - Screenshare error: The problem is when block at OS level, chrome throws NotAllowedError(HMS code - 3001) while firefox throws NotFoundError(HMS code - 3002),\n * we will handle this internally and throw error as User block - 3001 and OS block - 3011 for all browsers.\n * Chrome -\n * User blocked - NotAllowedError - Permission denied\n * System blocked - NotAllowedError - Permission denied by system\n */\n// eslint-disable-next-line complexity\nfunction convertMediaErrorToHMSException(err: Error, deviceInfo = ''): HMSException {\n  /**\n   * Note: Adapter detects all chromium browsers as 'chrome'\n   */\n  const chromeSystemDenied =\n    adapter.browserDetails.browser === 'chrome' &&\n    err.name === 'NotAllowedError' &&\n    err.message.includes('denied by system');\n\n  if (chromeSystemDenied) {\n    return ErrorFactory.TracksErrors.SystemDeniedPermission(HMSAction.TRACK, deviceInfo, err.message);\n  }\n\n  if (adapter.browserDetails.browser === 'firefox' && err.name === 'NotFoundError') {\n    const hmsError = ErrorFactory.TracksErrors.SystemDeniedPermission(HMSAction.TRACK, deviceInfo, err.message);\n    hmsError.description = `Capture device is either blocked at Operating System level or not available - ${deviceInfo}`;\n    return hmsError;\n  }\n\n  switch (err.name) {\n    case 'OverconstrainedError':\n      return ErrorFactory.TracksErrors.OverConstrained(\n        HMSAction.TRACK,\n        deviceInfo,\n        (err as OverconstrainedError).constraint,\n      );\n    case 'NotAllowedError':\n      return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotFoundError':\n      return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotReadableError':\n      return ErrorFactory.TracksErrors.DeviceInUse(HMSAction.TRACK, deviceInfo, err.message);\n    case 'TypeError':\n      return ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK, err.message);\n    default:\n      return getDefaultError(err.message, deviceInfo);\n  }\n}\n\nexport function BuildGetMediaError(err: Error, deviceInfo: string): HMSException {\n  const exception = convertMediaErrorToHMSException(err, deviceInfo);\n  exception.addNativeError(err);\n  return exception;\n}\n", "import { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { HMSAudioTrackSettings, HMSVideoTrackSettings } from '../media/settings';\n\nexport async function getAudioTrack(settings: HMSAudioTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: settings ? settings.toConstraints() : false,\n    });\n    return stream.getAudioTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AUDIO);\n  }\n}\n\nexport async function getVideoTrack(settings: HMSVideoTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: settings ? settings.toConstraints() : false,\n    });\n    return stream.getVideoTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.VIDEO);\n  }\n}\n\n// To differentiate between normal track and empty track.\nexport function isEmptyTrack(track: MediaStreamTrack) {\n  // Firefox gives '' as label for empty track(created from audio context)\n  return 'canvas' in track || track.label === 'MediaStreamAudioDestinationNode' || track.label === '';\n}\n", "import { HMSInternalEvent } from '../events/HMSInternalEvent';\nimport { HMSLocalAudioTrack } from '../media/tracks';\nimport HMSLogger from './logger';\nimport { Queue } from './queue';\nimport { sleep } from './timer-utils';\n\n/** Send update only if audio level is above THRESHOLD */\nconst THRESHOLD = 35;\n\n/** Send update only if audio level is changed by UPDATE_THRESHOLD */\nconst UPDATE_THRESHOLD = 5;\n\nexport interface ITrackAudioLevelUpdate {\n  track: HMSLocalAudioTrack;\n  audioLevel: number;\n}\n\nexport class TrackAudioLevelMonitor {\n  private readonly TAG = '[TrackAudioLevelMonitor]';\n  private audioLevel = 0;\n  private analyserNode?: AnalyserNode;\n  private isMonitored = false;\n  /** Frequency of polling audio level from track */\n  private interval = 100;\n  /** Store past audio levels for this duration */\n  private historyInterval = 700;\n  private history = new Queue<number>(this.historyInterval / this.interval);\n\n  constructor(\n    private track: HMSLocalAudioTrack,\n    private audioLevelEvent: HMSInternalEvent<ITrackAudioLevelUpdate>,\n    private silenceEvent: HMSInternalEvent<{ track: HMSLocalAudioTrack }>,\n  ) {\n    try {\n      const stream = new MediaStream([this.track.nativeTrack]);\n      this.analyserNode = this.createAnalyserNodeForStream(stream);\n    } catch (ex) {\n      HMSLogger.w(this.TAG, 'Unable to initialize AudioContext', ex);\n    }\n  }\n\n  /**\n   * To detect silence we check if the track is unmuted and silent in the current moment\n   * periodically. If the track is found to be silent more than a threshold number of times\n   * we send the event. The threshold number of time is there to reduce the chance of false\n   * positives.\n   */\n  detectSilence = async () => {\n    const tickInterval = 30;\n    const tickThreshold = 10;\n    let silenceCounter = 0;\n\n    while (this.isMonitored) {\n      if (this.track.enabled) {\n        if (this.isSilentThisInstant()) {\n          silenceCounter++;\n          if (silenceCounter > tickThreshold) {\n            this.silenceEvent.publish({ track: this.track });\n            break;\n          }\n        } else {\n          // bail out immediately if sound is found\n          break;\n        }\n      }\n      await sleep(tickInterval);\n    }\n  };\n\n  start() {\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d(this.TAG, 'Starting track Monitor', this.track);\n    this.loop().then(() => HMSLogger.d(this.TAG, 'Stopping track Monitor', this.track));\n  }\n\n  stop() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    this.sendAudioLevel(0);\n    this.isMonitored = false;\n  }\n\n  private async loop() {\n    while (this.isMonitored) {\n      this.sendAudioLevel(this.getMaxAudioLevelOverPeriod());\n      await sleep(this.interval);\n    }\n  }\n\n  private sendAudioLevel(audioLevel = 0) {\n    audioLevel = audioLevel > THRESHOLD ? audioLevel : 0;\n    const isSignificantChange = Math.abs(this.audioLevel - audioLevel) > UPDATE_THRESHOLD;\n    if (isSignificantChange) {\n      this.audioLevel = audioLevel;\n      const audioLevelUpdate: ITrackAudioLevelUpdate = { track: this.track, audioLevel: this.audioLevel };\n      this.audioLevelEvent.publish(audioLevelUpdate);\n    }\n  }\n\n  private getMaxAudioLevelOverPeriod() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n    const newLevel = this.calculateAudioLevel();\n    newLevel !== undefined && this.history.enqueue(newLevel);\n    return this.history.aggregate(values => Math.max(...values));\n  }\n\n  private calculateAudioLevel() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    const data = new Uint8Array(this.analyserNode.fftSize);\n    this.analyserNode.getByteTimeDomainData(data);\n    const lowest = 0.009;\n    let max = lowest;\n    for (const frequency of data) {\n      max = Math.max(max, (frequency - 128) / 128);\n    }\n    const normalized = (Math.log(lowest) - Math.log(max)) / Math.log(lowest);\n    const percent = Math.ceil(Math.min(Math.max(normalized * 100, 0), 100));\n    return percent;\n  }\n\n  private isSilentThisInstant() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    const data = new Uint8Array(this.analyserNode.fftSize);\n    this.analyserNode.getByteTimeDomainData(data);\n\n    // For absolute silence(in case of mic/software failures), all frequencies are 128 or 0.\n    return !data.some(frequency => frequency !== 128 && frequency !== 0);\n  }\n\n  private createAnalyserNodeForStream(stream: MediaStream): AnalyserNode {\n    const audioContext = new AudioContext();\n    const analyser = audioContext.createAnalyser();\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    return analyser;\n  }\n}\n", "/**\n * A plugin implementing this interface can be registered with HMSLocalAudioTrack to transform, process or\n * analyze the local audio track.These can include applications like background noise removal, speech commands, live\n * analysis of audio etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\n\nexport interface HMSAudioPlugin {\n  /**\n   * This function will be called by the SDK for audio track which the plugin needs to process.\n   * The reason audio context is also part of the interface is that it's recommeneded to reuse on audio context\n   * instead of creating new for every use - https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n   */\n  processAudioTrack(ctx: AudioContext, source: AudioNode): Promise<AudioNode>;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS, browser and audio device or not. An error object will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  checkSupport(ctx?: AudioContext): HMSPluginSupportResult;\n\n  /**\n   * @deprecated. Will be deleted in future updates. Use checkSupport instead.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processAudio is called.\n   */\n  init(): Promise<void> | void;\n\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   This sets the Plugin type @see HMSAudioPluginType, processing will happen\n   based on the type of plugin\n   */\n  getPluginType(): HMSAudioPluginType;\n  /*\n   * the plugin can use this function to dispose off its resources. It'll be called when the plugin instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output audio node to give the resulting\n * transformation. While an analyzing plugin will only be passed the input node.\n * For analyse plugins, you can return the source node passed to plugin.processTrack to not modify anything\n */\nexport enum HMSAudioPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n\nexport interface HMSPluginSupportResult {\n  isSupported: boolean;\n  errType?: HMSPluginUnsupportedTypes;\n  errMsg?: string;\n}\n\nexport enum HMSPluginUnsupportedTypes {\n  PLATFORM_NOT_SUPPORTED = 'PLATFORM_NOT_SUPPORTED',\n  DEVICE_NOT_SUPPORTED = 'DEVICE_NOT_SUPPORTED',\n}\n", "import { v4 as uuid } from 'uuid';\nimport { ISignalParamsProvider } from '../signal/ISignalSendParamsProvider';\nimport { domainCategory } from './domain-analytics';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { getAnalyticsDeviceId } from '../utils/support';\n\ninterface AnalyticsEventInit {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII?: boolean;\n  properties?: Record<string, any>;\n  timestamp?: number;\n}\n\ninterface SignalEventParams {\n  name: string;\n  info: any;\n  timestamp: number;\n}\n\nexport default class AnalyticsEvent implements ISignalParamsProvider<SignalEventParams> {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII: boolean;\n  properties: Record<string, any>;\n  metadata: {\n    token?: string;\n    peer: {\n      peer_id?: string;\n      session_id?: string;\n      room_id?: string;\n      role?: string;\n      room_name?: string;\n      joined_at?: number;\n      template_id?: string;\n      session_started_at?: number;\n      user_name?: string;\n      user_data?: string;\n    };\n  } = {\n    peer: {},\n  };\n  timestamp: number;\n  event_id: string;\n  device_id: string;\n\n  constructor({ name, level, properties, includesPII, timestamp }: AnalyticsEventInit) {\n    this.name = name;\n    this.level = level;\n    this.includesPII = includesPII || false;\n    this.properties = properties || {};\n    this.timestamp = timestamp || new Date().getTime(); // Timestamp of generating the event\n    this.event_id = uuid();\n    this.device_id = getAnalyticsDeviceId();\n  }\n\n  toSignalParams() {\n    return {\n      name: this.name,\n      info: { ...this.properties, timestamp: this.timestamp, domain: domainCategory },\n      timestamp: new Date().getTime(), // Timestamp of sending the event\n    };\n  }\n}\n", "export enum DomainCategory {\n  CUSTOM = 'CUSTOM',\n  LOCAL = 'LOCAL',\n  HMS = 'HMS',\n}\n", "import { DomainCategory } from './AnalyticsEventDomains';\nimport { isBrowser } from '../utils/support';\n\nfunction getDomainCategory() {\n  // this function gives us the domain category(sutom, hms , local) of the base url.\n  // below if statement checks if it's running in a browser ; or if we can use 'window' safely\n\n  if (isBrowser && window) {\n    const baseurl = window.location.hostname;\n\n    if (baseurl === 'localhost' || baseurl === '127.0.0.1') {\n      return DomainCategory.LOCAL;\n    }\n\n    if (baseurl.includes('app.100ms.live')) {\n      return DomainCategory.HMS;\n    } else {\n      return DomainCategory.CUSTOM;\n    }\n  }\n\n  return DomainCategory.CUSTOM;\n}\n\nexport const domainCategory = getDomainCategory();\n", "export enum HMSAnalyticsLevel {\n  VERBOSE,\n  INFO,\n  ERROR,\n  OFF,\n}\n\nexport enum AnalyticsEventLevel {\n  VERBOSE,\n  INFO,\n  ERROR,\n  OFF,\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { HMSException } from '../error/HMSException';\n\nexport default class MediaPluginsAnalyticsFactory {\n  static failure(pluginName: string, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginFailure(pluginName: string, sampleRate: number, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, sampleRate: sampleRate, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginStats({\n    pluginName,\n    duration,\n    loadTime,\n    sampleRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    sampleRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      sampleRate: sampleRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static stats({\n    pluginName,\n    duration,\n    loadTime,\n    avgPreProcessingTime,\n    avgProcessingTime,\n    inputFrameRate,\n    pluginFrameRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    avgPreProcessingTime: number;\n    avgProcessingTime: number;\n    inputFrameRate: number;\n    pluginFrameRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      avg_preprocessing_time: avgPreProcessingTime,\n      avg_processing_time: avgProcessingTime,\n      input_frame_rate: inputFrameRate,\n      plugin_frame_rate: pluginFrameRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n}\n", "import MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\n\nconst TAG = 'AudioPluginsAnalytics';\n\nexport class AudioPluginsAnalytics {\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginSampleRate: Record<string, number>;\n\n  constructor(private eventBus: EventBus) {\n    this.initTime = {};\n    this.addedTimestamps = {};\n    this.pluginAdded = {};\n    this.pluginSampleRate = {};\n  }\n\n  added(name: string, sampleRate: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.pluginSampleRate[name] = sampleRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        sampleRate: this.pluginSampleRate[name],\n      };\n      //send stats\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.audioPluginStats(stats));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      this.eventBus.analytics.publish(\n        MediaPluginsAnalyticsFactory.audioPluginFailure(name, this.pluginSampleRate[name], error),\n      );\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.AUDIO_PLUGINS,\n        `failed during initialization of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.pluginAdded[name];\n    delete this.pluginSampleRate[name];\n  }\n}\n", "import { HMSAudioPlugin, HMSPluginUnsupportedTypes } from './HMSAudioPlugin'; //HMSAudioPluginType\nimport { HMSLocalAudioTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { AudioPluginsAnalytics } from './AudioPluginsAnalytics';\nimport { EventBus } from '../../events/EventBus';\n\nconst TAG = 'AudioPluginsManager';\nconst DEFAULT_SAMPLE_RATE = 48000;\n\n//Handling sample rate error in case of firefox\nconst checkBrowserSupport = () => {\n  return navigator.userAgent.indexOf('Firefox') !== -1;\n};\n\n/**\n * This class manages applying different plugins on a local audio track. Plugins which need to modify the audio\n * are called in the order they were added. Plugins which do not need to modify the audio are called\n * with the original input.\n *\n * Concepts -\n * Audio Plugin - A module which can take in input audio, do some processing on it and return an AudioNode\n *\n * For Each Plugin, an AudioNode will be created and the source will be created from local audio track.\n * Each Audio node will be connected in the following order\n * source -> first plugin -> second plugin -> third plugin .. so on\n * @see HMSAudioPlugin\n */\nexport class HMSAudioPluginsManager {\n  private readonly hmsTrack: HMSLocalAudioTrack;\n  // Map maintains the insertion order\n  private readonly pluginsMap: Map<string, HMSAudioPlugin>;\n  private audioContext?: AudioContext;\n\n  private sourceNode?: MediaStreamAudioSourceNode;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private prevAudioNode?: any;\n  private analytics: AudioPluginsAnalytics;\n  // This will replace the native track in peer connection when plugins are enabled\n  private outputTrack?: MediaStreamTrack;\n  private pluginAddInProgress = false;\n\n  constructor(track: HMSLocalAudioTrack, eventBus: EventBus) {\n    this.hmsTrack = track;\n    this.pluginsMap = new Map();\n    this.analytics = new AudioPluginsAnalytics(eventBus);\n    this.createAudioContext();\n  }\n\n  getPlugins(): string[] {\n    return Array.from(this.pluginsMap.keys());\n  }\n\n  async addPlugin(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!name) {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginAddInProgress) {\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.AUDIO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      this.analytics.failure(name, err);\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin);\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  private async addPluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (this.pluginsMap.get(name)) {\n      HMSLogger.w(TAG, `plugin - ${name} already added.`);\n      return;\n    }\n\n    await this.validateAndThrow(name, plugin);\n\n    try {\n      if (this.pluginsMap.size === 0) {\n        await this.initAudioNodes();\n      } else if (this.prevAudioNode) {\n        // Previous node will be connected to destination. Disconnect that\n        this.prevAudioNode.disconnect();\n      }\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      await this.analytics.initWithTime(name, async () => plugin.init());\n      this.pluginsMap.set(name, plugin);\n      await this.processPlugin(plugin);\n      await this.connectToDestination();\n    } catch (err) {\n      HMSLogger.e(TAG, 'failed to add plugin', err);\n      throw err;\n    }\n  }\n\n  validatePlugin(plugin: HMSAudioPlugin) {\n    return plugin.checkSupport(this.audioContext);\n  }\n\n  async validateAndThrow(name: string, plugin: HMSAudioPlugin) {\n    const result = this.validatePlugin(plugin);\n    if (result.isSupported) {\n      HMSLogger.i(TAG, `plugin is supported,- ${plugin.getName()}`);\n    } else {\n      //Needed to re-add in the reprocess case, to send error message in case of failure\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      if (result.errType === HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED) {\n        const err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(\n          HMSAction.AUDIO_PLUGINS,\n          'platform not supported, see docs',\n        );\n        this.analytics.failure(name, err);\n        await this.cleanup();\n        throw err;\n      } else if (result.errType === HMSPluginUnsupportedTypes.DEVICE_NOT_SUPPORTED) {\n        const err = ErrorFactory.MediaPluginErrors.DeviceNotSupported(\n          HMSAction.AUDIO_PLUGINS,\n          'audio device not supported, see docs',\n        );\n        this.analytics.failure(name, err);\n        await this.cleanup();\n        throw err;\n      }\n    }\n  }\n\n  async removePlugin(plugin: HMSAudioPlugin) {\n    await this.removePluginInternal(plugin);\n    if (this.pluginsMap.size === 0) {\n      // remove all previous nodes\n      await this.cleanup();\n      HMSLogger.i(TAG, `No plugins left, stopping plugins loop`);\n      await this.hmsTrack.setProcessedTrack(undefined);\n    } else {\n      // Reprocess the remaining plugins again because there is no way to connect\n      // the source of the removed plugin to destination of removed plugin\n      await this.reprocessPlugins();\n    }\n  }\n\n  async cleanup() {\n    for (const plugin of this.pluginsMap.values()) {\n      await this.removePluginInternal(plugin);\n    }\n    await this.hmsTrack.setProcessedTrack(undefined);\n    //disconnect nodes, stop track\n    this.sourceNode?.disconnect();\n    this.prevAudioNode?.disconnect();\n    this.outputTrack?.stop();\n\n    // reset all variables\n    this.sourceNode = undefined;\n    this.destinationNode = undefined;\n    this.prevAudioNode = undefined;\n    this.outputTrack = undefined;\n  }\n\n  //Keeping it separate since we are initializing context only once\n  async closeContext() {\n    this.audioContext?.close();\n    this.audioContext = undefined;\n  }\n\n  async reprocessPlugins() {\n    if (this.pluginsMap.size === 0 || !this.sourceNode) {\n      return;\n    }\n    const plugins = Array.from(this.pluginsMap.values()); // make a copy of plugins\n    await this.cleanup();\n    await this.initAudioNodes();\n    for (const plugin of plugins) {\n      await this.addPlugin(plugin);\n    }\n  }\n\n  private async initAudioNodes() {\n    if (this.audioContext) {\n      if (!this.sourceNode) {\n        const audioStream = new MediaStream([this.hmsTrack.nativeTrack]);\n        this.sourceNode = this.audioContext.createMediaStreamSource(audioStream);\n      }\n      if (!this.destinationNode) {\n        this.destinationNode = this.audioContext.createMediaStreamDestination();\n        this.outputTrack = this.destinationNode.stream.getAudioTracks()[0];\n        try {\n          await this.hmsTrack.setProcessedTrack(this.outputTrack);\n        } catch (err) {\n          HMSLogger.e(TAG, 'error in setting processed track', err);\n          throw err;\n        }\n      }\n    }\n  }\n\n  private async processPlugin(plugin: HMSAudioPlugin) {\n    try {\n      const currentNode = await plugin.processAudioTrack(\n        this.audioContext!, // it is always present at this point\n        this.prevAudioNode || this.sourceNode,\n      );\n      if (this.prevAudioNode) {\n        // if previous node was present while adding this plugin\n        // it is disconnected from destination, connect the previous node to\n        // to the current node\n        this.prevAudioNode.connect(currentNode);\n      }\n      this.prevAudioNode = currentNode;\n    } catch (err) {\n      const name = plugin.getName();\n      //TODO error happened on processing of plugin notify UI\n      HMSLogger.e(TAG, `error in processing plugin ${name}`, err);\n      //remove plugin from loop and stop analytics for it\n      await this.removePluginInternal(plugin);\n    }\n  }\n\n  private async connectToDestination() {\n    try {\n      if (this.prevAudioNode && this.destinationNode && this.prevAudioNode.context === this.destinationNode.context) {\n        this.prevAudioNode.connect(this.destinationNode);\n      }\n    } catch (err) {\n      HMSLogger.e(TAG, 'error in connecting to destination node', err);\n    }\n  }\n\n  private async removePluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!this.pluginsMap.get(name)) {\n      HMSLogger.w(TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(TAG, `removing plugin ${name}`);\n    this.pluginsMap.delete(name);\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  private createAudioContext() {\n    if (!this.audioContext) {\n      if (checkBrowserSupport()) {\n        /**\n        Not setting default sample rate for firefox since connecting\n        audio nodes from context with different sample rate is not\n        supported in firefox\n */\n        this.audioContext = new AudioContext();\n      } else {\n        this.audioContext = new AudioContext({ sampleRate: DEFAULT_SAMPLE_RATE });\n      }\n    }\n  }\n}\n", "import { DeviceMap } from '../interfaces';\nimport { SelectedDevices } from './DeviceManager';\nimport { LocalStorage } from '../utils/local-storage';\nimport HMSLogger from '../utils/logger';\n\ntype DeviceInfo = { deviceId?: string; groupId?: string };\n/**\n * This class is to manage storing and retrieving selected devices\n * from localstorage\n * @internal\n */\nclass DeviceStorage {\n  private storage = new LocalStorage<SelectedDevices>('hms-device-selection');\n  private remember = false;\n  private devices?: DeviceMap;\n  private TAG = 'HMSDeviceStorage';\n\n  setDevices(devices: DeviceMap) {\n    this.devices = devices;\n  }\n\n  rememberDevices(value: boolean) {\n    this.remember = value;\n  }\n\n  /**\n   * This will update the passed in type value in storage\n   * @param {string} type - One of audioInput | videoInput | audioOutput\n   * @param {DeviceInfo} param\n   * @returns {void}\n   */\n  updateSelection(type: 'audioInput' | 'videoInput' | 'audioOutput', { deviceId, groupId }: DeviceInfo) {\n    if (!this.devices || !this.remember) {\n      return;\n    }\n    const newSelection = this.devices[type].find(device => this.isSame({ deviceId, groupId }, device));\n    if (!newSelection) {\n      HMSLogger.w(this.TAG, `Could not find device with deviceId: ${deviceId}, groupId: ${groupId}`);\n      return;\n    }\n    const selectedDevices = this.storage.get() || {};\n    if (type === 'audioOutput') {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    } else {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    }\n    this.storage.set(selectedDevices);\n  }\n\n  getSelection() {\n    if (!this.remember) {\n      return undefined;\n    }\n    return this.storage.get();\n  }\n\n  cleanup() {\n    this.remember = false;\n    this.devices = undefined;\n  }\n\n  private isSame(current: DeviceInfo, device: DeviceInfo) {\n    // Safari doesn't give groupId from nativeTrack. Check if groupId's match or current groupId is not present\n    return current.deviceId === device.deviceId && (current.groupId === device.groupId || !current.groupId);\n  }\n}\n\nexport const DeviceStorageManager = new DeviceStorage();\n", "import { HMSAudioTrack } from './HMSAudioTrack';\nimport HMSLocalStream from '../streams/HMSLocalStream';\nimport { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from '../settings';\nimport { getAudioTrack, isEmptyTrack } from '../../utils/track';\nimport { TrackAudioLevelMonitor } from '../../utils/track-audio-level-monitor';\nimport HMSLogger from '../../utils/logger';\nimport { HMSAudioPlugin, HMSPluginSupportResult } from '../../plugins';\nimport { HMSAudioPluginsManager } from '../../plugins/audio';\nimport { HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSException } from '../../error/HMSException';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSAudioTrackSettings>, oldSettings: HMSAudioTrackSettings) {\n  return function hasChanged(prop: 'codec' | 'volume' | 'maxBitrate' | 'deviceId' | 'advanced') {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nconst TAG = 'HMSLocalAudioTrack';\n\nexport class HMSLocalAudioTrack extends HMSAudioTrack {\n  settings: HMSAudioTrackSettings;\n  private pluginsManager: HMSAudioPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n\n  audioLevelMonitor?: TrackAudioLevelMonitor;\n\n  /**\n   * see the doc in HMSLocalVideoTrack\n   * @internal\n   */\n  publishedTrackId?: string;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    private eventBus: EventBus,\n    settings: HMSAudioTrackSettings = new HMSAudioTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n\n    this.settings = settings;\n    // Replace the 'default' deviceId with the actual deviceId\n    // This is to maintain consistency with selected devices as in some cases there will be no 'default' device\n    if (settings.deviceId === 'default' && !isEmptyTrack(track)) {\n      this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n    }\n    this.pluginsManager = new HMSAudioPluginsManager(this, eventBus);\n    this.setFirstTrackId(track.id);\n  }\n\n  private async replaceTrackWith(settings: HMSAudioTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    const prevState = this.enabled;\n    const isLevelMonitored = Boolean(this.audioLevelMonitor);\n    /**\n     * Stop has to be called before getting newTrack as it would cause NotReadableError\n     */\n    prevTrack?.stop();\n    const newTrack = await getAudioTrack(settings);\n    newTrack.enabled = prevState;\n\n    const localStream = this.stream as HMSLocalStream;\n    // change nativeTrack so plugin can start its work\n    await localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);\n    await localStream.replaceStreamTrack(prevTrack, newTrack);\n    this.nativeTrack = newTrack;\n    isLevelMonitored && this.initAudioLevelMonitor();\n    try {\n      await this.pluginsManager.reprocessPlugins();\n    } catch (e) {\n      this.eventBus.audioPluginFailed.publish(e as HMSException);\n    }\n  }\n\n  async setEnabled(value: boolean) {\n    if (value === this.enabled) {\n      return;\n    }\n\n    // Replace silent empty track with an actual audio track, if enabled.\n    if (value && isEmptyTrack(this.nativeTrack)) {\n      await this.replaceTrackWith(this.settings);\n    }\n    await super.setEnabled(value);\n    if (value) {\n      this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId });\n    }\n    this.eventBus.localAudioEnabled.publish({ enabled: value, track: this });\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  /**\n   * verify if the track id being passed is of this track for correlating server messages like audio level\n   */\n  isPublishedTrackId(trackId: string) {\n    return this.publishedTrackId === trackId;\n  }\n\n  async setSettings(settings: Partial<IHMSAudioTrackSettings>, internal = false) {\n    const newSettings = this.buildNewSettings(settings);\n\n    await this.handleDeviceChange(newSettings, internal);\n    if (isEmptyTrack(this.nativeTrack)) {\n      // if it is an empty track, cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n    await this.handleSettingsChange(newSettings);\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async addPlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async removePlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  validatePlugin(plugin: HMSAudioPlugin): HMSPluginSupportResult {\n    return this.pluginsManager.validatePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  initAudioLevelMonitor() {\n    if (this.audioLevelMonitor) {\n      this.destroyAudioLevelMonitor();\n    }\n    HMSLogger.d(TAG, 'Monitor Audio Level for', this, this.getMediaTrackSettings().deviceId);\n    this.audioLevelMonitor = new TrackAudioLevelMonitor(\n      this,\n      this.eventBus.trackAudioLevelUpdate,\n      this.eventBus.localAudioSilence,\n    );\n    this.audioLevelMonitor.start();\n    this.audioLevelMonitor.detectSilence();\n  }\n\n  destroyAudioLevelMonitor() {\n    this.audioLevelMonitor?.stop();\n    this.audioLevelMonitor = undefined;\n  }\n\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    await this.pluginsManager.closeContext();\n    this.processedTrack?.stop();\n    this.destroyAudioLevelMonitor();\n  }\n\n  /**\n   * @internal\n   * published track id will be different in case there was some processing done using plugins.\n   */\n  getTrackIDBeingSent() {\n    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;\n  }\n\n  /**\n   * @internal\n   */\n  getTrackBeingSent() {\n    return this.processedTrack || this.nativeTrack;\n  }\n\n  private buildNewSettings(settings: Partial<HMSAudioTrackSettings>) {\n    const { volume, codec, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);\n    return newSettings;\n  }\n\n  private handleSettingsChange = async (settings: HMSAudioTrackSettings) => {\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('maxBitrate') && settings.maxBitrate) {\n      await stream.setMaxBitrate(settings.maxBitrate, this);\n    }\n\n    if (hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(settings.toConstraints());\n    }\n  };\n\n  /**\n   * Replace audio track with new track on device change if enabled\n   * @param settings - AudioSettings Object constructed with new settings\n   * @param internal - whether the change was because of internal sdk call or external client call\n   */\n  private handleDeviceChange = async (settings: HMSAudioTrackSettings, internal = false) => {\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('deviceId')) {\n      await this.replaceTrackWith(settings);\n      if (!internal) {\n        DeviceStorageManager.updateSelection('audioInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n  };\n}\n", "import { HMSPluginSupportResult } from '../audio';\n\n/**\n * A plugin implementing this interface can be registered with HMSLocalVideoTrack to transform, process or\n * analyze the local video track.These can include applications like video filters, virtual background, live\n * analysis of video etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\nexport interface HMSVideoPlugin {\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS and device or not. An error will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  checkSupport(): HMSPluginSupportResult;\n\n  /**\n   * @deprecated. Will be deleted in future updates. Use checkSupport instead.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processVideoFrame is called.\n   */\n  init(): Promise<void>;\n\n  /**\n   * @see HMSVideoPluginType\n   */\n  getPluginType(): HMSVideoPluginType;\n\n  getContextType?(): HMSVideoPluginCanvasContextType;\n\n  /**\n   * This function will be called by the SDK for every video frame which the plugin needs to process.\n   * PluginFrameRate - the rate at which the plugin is expected to process the video frames. This is not necessarily\n   * equal to the capture frame rate. The user can specify this rate, and the sdk might also change it on basis of\n   * device type, or CPU usage.\n   * For an analyzing plugin, the below function will be called at plugin framerate.\n   * For a transforming plugin, the sdk will pass in the input and output at real frame rate with an additional boolean\n   * pass. The expectation is that the plugin should use results of previous runs instead of doing a complex processing\n   * again when pass is set to true. This helps in maintaining the framerate of the video as well as bringing down\n   * CPU usage in case of complex processing.\n   * @param input input canvas containing the input frame\n   * @param output the output canvas which should contain the output frame\n   * @param skipProcessing use results from previous run if true\n   */\n  processVideoFrame(\n    input: HTMLCanvasElement,\n    output?: HTMLCanvasElement,\n    skipProcessing?: boolean,\n  ): Promise<void> | void;\n\n  /**\n   * the plugin can use this function to dispose off its resources. It'll be called when the processor instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output canvas to give the resulting\n * transformation. While an analyzing plugin will only be passed the input canvas.\n */\nexport enum HMSVideoPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n\nexport enum HMSVideoPluginCanvasContextType {\n  '2D' = '2d',\n  WEBGL = 'webgl',\n  'WEBGL2' = 'webgl2',\n}\n", "export class RunningAverage {\n  private total = 0;\n  private count = 0;\n\n  add(item: number) {\n    this.count++;\n    this.total += item;\n  }\n\n  getAvg(): number {\n    return Math.floor(this.total / this.count);\n  }\n\n  reset() {\n    this.total = 0;\n    this.count = 0;\n  }\n}\n", "import { RunningAverage } from '../../utils/math';\nimport MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\n\nconst TAG = 'VideoPluginsAnalytics';\n\nexport class VideoPluginsAnalytics {\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly preProcessingAvgs: RunningAverage;\n  private readonly processingAvgs: Record<string, RunningAverage>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginInputFrameRate: Record<string, number>;\n  private readonly pluginFrameRate: Record<string, number>;\n\n  constructor(private eventBus: EventBus) {\n    this.initTime = {};\n    this.preProcessingAvgs = new RunningAverage();\n    this.addedTimestamps = {};\n    this.processingAvgs = {};\n    this.pluginAdded = {};\n    this.pluginInputFrameRate = {};\n    this.pluginFrameRate = {};\n  }\n\n  added(name: string, inputFrameRate: number, pluginFrameRate?: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.processingAvgs[name] = new RunningAverage();\n    this.pluginInputFrameRate[name] = inputFrameRate;\n    this.pluginFrameRate[name] = pluginFrameRate || inputFrameRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        avgPreProcessingTime: this.preProcessingAvgs.getAvg(), //Do we need this in stat not plugin specific\n        avgProcessingTime: this.processingAvgs[name]?.getAvg(),\n        inputFrameRate: this.pluginInputFrameRate[name],\n        pluginFrameRate: this.pluginFrameRate[name],\n      };\n      //send stats\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.stats(stats));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.failure(name, error));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.VIDEO_PLUGINS,\n        `failed during initialization of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  async preProcessWithTime<T>(preProcessFn: () => Promise<T>) {\n    //TODO: check if it is required to maintain and shall we handle preprocess failures\n    const time = await this.timeInMs(preProcessFn);\n    this.preProcessingAvgs.add(time);\n  }\n\n  async processWithTime<T>(name: string, processFn: () => Promise<T>) {\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(processFn);\n    } catch (e) {\n      //Failed during processing of plugin\n      const err = ErrorFactory.MediaPluginErrors.ProcessingFailed(\n        HMSAction.VIDEO_PLUGINS,\n        `Failed during processing of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.processingAvgs[name]?.add(time);\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.processingAvgs[name];\n    delete this.pluginAdded[name];\n    delete this.pluginInputFrameRate[name];\n    delete this.pluginFrameRate[name];\n  }\n}\n", "/* eslint-disable complexity */\nimport { HMSVideoPlugin, HMSVideoPluginCanvasContextType, HMSVideoPluginType } from './HMSVideoPlugin';\nimport { HMSLocalVideoTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\nimport { sleep } from '../../utils/timer-utils';\nimport { VideoPluginsAnalytics } from './VideoPluginsAnalytics';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSPluginUnsupportedTypes } from '../audio';\n\nconst DEFAULT_FRAME_RATE = 24;\nconst DEFAULT_WIDTH = 320;\nconst DEFAULT_HEIGHT = 240;\nconst TAG = 'VideoPluginsManager';\n\ninterface CanvasElement extends HTMLCanvasElement {\n  captureStream(frameRate?: number): MediaStream;\n}\n\n/**\n * This class manages applying different plugins on a local video track. Plugins which need to modify the video\n * are called in the order they were added. Plugins which do not need to modify the video frames are called\n * with the original input.\n *\n * Concepts -\n * Video Plugin - A module which can take in input video painted on a canvas, do some processing on it and optionally\n * render its output on a passed in output canvas which will be shown in the UI.\n *\n * frameRate - the frame rate of the input video as present in track.getSettings, this is the rate at which new frames\n * are being produced and the rate we need to maintain in output as well.\n *\n * pluginFrameRate - this is the rate at which the plugin is supposed to do its processing. The processing can be an\n * expensive operation and can result in high usage of resources like CPU. This rate would usually be lower than the\n * real frame rate.\n *\n * pluginsLoop - a loop is run at framerate in this class, on each loop if the original track is unmuted all added\n * plugins are called one by one in the order they were called.\n *\n * @see HMSVideoPlugin\n */\nexport class HMSVideoPluginsManager {\n  /**\n   * plugins loop is the loop in which all plugins are applied\n   */\n  private pluginsLoopRunning = false;\n  private pluginsLoopState: 'paused' | 'running' = 'paused';\n  private readonly hmsTrack: HMSLocalVideoTrack;\n  private readonly pluginsMap: Map<string, HMSVideoPlugin>; // plugin names to their instance mapping\n  private inputVideo?: HTMLVideoElement;\n  private inputCanvas?: CanvasElement;\n  private outputCanvas?: CanvasElement;\n  private outputTrack?: MediaStreamTrack;\n  private analytics: VideoPluginsAnalytics;\n  private pluginAddInProgress = false;\n  private pluginNumFramesToSkip: Record<string, number>;\n  private pluginNumFramesSkipped: Record<string, number>;\n  private canvases: Array<CanvasElement>; //array of canvases to store intermediate result\n\n  constructor(track: HMSLocalVideoTrack, eventBus: EventBus) {\n    this.hmsTrack = track;\n    this.pluginsMap = new Map();\n    this.pluginNumFramesToSkip = {};\n    this.pluginNumFramesSkipped = {};\n    this.analytics = new VideoPluginsAnalytics(eventBus);\n    this.canvases = new Array<CanvasElement>();\n  }\n\n  getPlugins(): string[] {\n    return Array.from(this.pluginsMap.keys());\n  }\n\n  /**\n   * @param plugin\n   * @param pluginFrameRate\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    if (this.pluginAddInProgress) {\n      const name = plugin.getName?.();\n      if (!name || name === '') {\n        HMSLogger.w('no name provided by the plugin');\n        return;\n      }\n\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.VIDEO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.failure(name, err);\n\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin, pluginFrameRate);\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  private async addPluginInternal(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    const name = plugin.getName?.();\n    if (!name || name === '') {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginsMap.has(name)) {\n      HMSLogger.w(TAG, `plugin - ${plugin.getName()} already added.`);\n      return;\n    }\n    //TODO: assuming this inputFrameRate from getMediaTrackSettings will not change once set\n    //TODO: even if it changes will not have the info/params to know the change\n    const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n\n    let numFramesToSkip = 0;\n    if (pluginFrameRate && pluginFrameRate > 0) {\n      HMSLogger.i(TAG, `adding plugin ${plugin.getName()} with framerate ${pluginFrameRate}`);\n      if (pluginFrameRate < inputFrameRate) {\n        numFramesToSkip = Math.ceil(inputFrameRate / pluginFrameRate) - 1;\n      }\n      this.analytics.added(name, inputFrameRate, pluginFrameRate);\n    } else {\n      HMSLogger.i(TAG, `adding plugin ${plugin.getName()}`);\n      this.analytics.added(name, inputFrameRate);\n    }\n\n    HMSLogger.i(TAG, 'numFrames to skip processing', numFramesToSkip);\n    this.pluginNumFramesToSkip[name] = numFramesToSkip;\n    this.pluginNumFramesSkipped[name] = numFramesToSkip;\n\n    this.validateAndThrow(name, plugin);\n\n    try {\n      await this.analytics.initWithTime(name, async () => await plugin.init());\n      this.pluginsMap.set(name, plugin);\n      // add new canvases according to new added plugins\n      if (this.pluginsMap.size + 1 > this.canvases.length) {\n        for (let i = this.canvases.length; i <= this.pluginsMap.size; i++) {\n          this.canvases[i] = document.createElement('canvas') as CanvasElement;\n        }\n      }\n      await this.startPluginsLoop(plugin.getContextType?.());\n    } catch (err) {\n      HMSLogger.e(TAG, 'failed to add plugin', err);\n      await this.removePlugin(plugin);\n      throw err;\n    }\n  }\n\n  validatePlugin(plugin: HMSVideoPlugin) {\n    return plugin.checkSupport();\n  }\n\n  validateAndThrow(name: string, plugin: HMSVideoPlugin) {\n    const result = this.validatePlugin(plugin);\n    if (result.isSupported) {\n      HMSLogger.i(TAG, `plugin is supported,- ${plugin.getName()}`);\n    } else {\n      let error;\n      switch (result.errType) {\n        case HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED:\n          error = ErrorFactory.MediaPluginErrors.PlatformNotSupported(\n            HMSAction.VIDEO_PLUGINS,\n            'platform not supported, see docs',\n          );\n          this.analytics.failure(name, error);\n          throw error;\n        case HMSPluginUnsupportedTypes.DEVICE_NOT_SUPPORTED:\n          error = ErrorFactory.MediaPluginErrors.DeviceNotSupported(\n            HMSAction.VIDEO_PLUGINS,\n            'video device not supported, see docs',\n          );\n          this.analytics.failure(name, error);\n          throw error;\n      }\n    }\n  }\n\n  async removePlugin(plugin: HMSVideoPlugin) {\n    const name = plugin.getName();\n    if (!this.pluginsMap.get(name)) {\n      HMSLogger.w(TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(TAG, `removing plugin ${name}`);\n    this.removePluginEntry(name);\n    if (this.pluginsMap.size === 0) {\n      HMSLogger.i(TAG, `No plugins left, stopping plugins loop`);\n      await this.stopPluginsLoop();\n    }\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  removePluginEntry(name: string) {\n    this.pluginsMap.delete(name);\n    if (this.pluginNumFramesToSkip[name]) {\n      delete this.pluginNumFramesToSkip[name];\n    }\n    if (this.pluginNumFramesSkipped[name]) {\n      delete this.pluginNumFramesSkipped[name];\n    }\n  }\n\n  /**\n   * when video is unmuted it takes some time for all the plugins to be re run and an output stream to be\n   * produced. It can await on this function to confirm and tell the new unmuted state.\n   * If this is not awaited on video will freeze with a frame from past run.\n   */\n  async waitForRestart() {\n    if (!this.pluginsLoopRunning || this.pluginsLoopState === 'running') {\n      return;\n    }\n    while (this.pluginsLoopState === 'paused') {\n      await sleep(100);\n    }\n  }\n\n  /**\n   * remove every plugin one by one\n   */\n  async cleanup() {\n    for (const plugin of this.pluginsMap.values()) {\n      await this.removePlugin(plugin);\n    }\n    // memory cleanup\n    this.outputTrack?.stop();\n  }\n\n  private initElementsAndStream(contextType?: HMSVideoPluginCanvasContextType) {\n    if (!this.inputCanvas) {\n      this.inputCanvas = document.createElement('canvas') as CanvasElement;\n    }\n    this.outputCanvas = document.createElement('canvas') as CanvasElement;\n    if (!this.inputVideo) {\n      this.inputVideo = document.createElement('video');\n    }\n    // FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974\n    this.inputCanvas.getContext('2d');\n    this.outputCanvas.getContext(contextType || HMSVideoPluginCanvasContextType['2D']);\n    // capture stream automatically uses the framerate at which the output canvas is changing\n    const outputStream = this.outputCanvas.captureStream();\n    this.outputTrack = outputStream.getVideoTracks()[0];\n  }\n\n  private async startPluginsLoop(contextType?: HMSVideoPluginCanvasContextType) {\n    if (this.pluginsLoopRunning) {\n      return;\n    }\n    this.initElementsAndStream(contextType);\n    this.pluginsLoopRunning = true;\n    try {\n      await this.hmsTrack.setProcessedTrack(this.outputTrack);\n    } catch (err) {\n      this.pluginsLoopRunning = false;\n      HMSLogger.e(TAG, 'error in setting processed track', err);\n      throw err;\n    }\n    // can't await on pluginsLoop as it'll run for a long long time\n    this.pluginsLoop().then(() => {\n      HMSLogger.d(TAG, 'processLoop stopped');\n    });\n  }\n\n  private async stopPluginsLoop() {\n    this.pluginsLoopRunning = false;\n    await this.hmsTrack.setProcessedTrack(undefined);\n    this.resetCanvases();\n    this.outputTrack?.stop();\n    if (this.inputVideo) {\n      this.inputVideo.srcObject = null;\n      this.inputVideo = undefined;\n    }\n  }\n\n  private async pluginsLoop() {\n    while (this.pluginsLoopRunning) {\n      const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n      const sleepTimeMs = Math.floor(1000 / inputFrameRate);\n      if (!this.hmsTrack.enabled || this.hmsTrack.nativeTrack.readyState === 'ended') {\n        if (this.pluginsLoopState === 'running') {\n          // mute just happened, reset canvases to black so even if it is sent to remote, it\n          // is a black screen instead of a stucked frame from previous run\n          this.resetCanvases();\n        }\n        this.pluginsLoopState = 'paused';\n        await sleep(sleepTimeMs);\n        continue;\n      }\n      let processingTime = 0;\n      try {\n        await this.analytics.preProcessWithTime(async () => await this.doPreProcessing());\n        const start = Date.now();\n        await this.processFramesThroughPlugins();\n        processingTime = Math.floor(Date.now() - start);\n        if (processingTime > sleepTimeMs) {\n          processingTime = sleepTimeMs;\n        }\n      } catch (err) {\n        // TODO: handle failures properly, detect which plugin failed, stop it and notify back to the UI\n        HMSLogger.e(TAG, 'error in plugins loop', err);\n      }\n      this.pluginsLoopState = 'running';\n      // take into account processing time to decide time to wait for the next loop\n      await sleep(sleepTimeMs - processingTime);\n    }\n  }\n\n  private async doPreProcessing() {\n    await this.addTrackToVideo(); // ensure current native track is playing in video\n    await this.updateInputCanvas(); // put the latest video frame on input canvas\n  }\n\n  /**\n   * pass the input canvas through all plugins in a loop\n   * @private\n   */\n  private async processFramesThroughPlugins() {\n    this.canvases[0] = this.inputCanvas!;\n    let i = 0;\n    for (const plugin of this.pluginsMap.values()) {\n      const name = plugin.getName();\n      if (!plugin) {\n        continue;\n      }\n      try {\n        const skipProcessing = this.checkIfSkipRequired(name);\n\n        if (plugin.getPluginType() === HMSVideoPluginType.TRANSFORM) {\n          const process = async (input: CanvasElement, output: CanvasElement) => {\n            try {\n              await plugin.processVideoFrame(input, output, skipProcessing);\n            } catch (err) {\n              HMSLogger.e(TAG, `error in processing plugin ${name}`, err);\n            }\n          };\n          if (!skipProcessing) {\n            const currentCanvas = this.canvases[i];\n            const nextCanvas = this.canvases[i + 1];\n            if (i === this.pluginsMap.size - 1) {\n              await this.analytics.processWithTime(name, async () => process(currentCanvas, this.outputCanvas!));\n            } else {\n              await this.analytics.processWithTime(name, async () => process(currentCanvas, nextCanvas));\n            }\n          } else {\n            if (i === this.pluginsMap.size - 1) {\n              await process(this.canvases[i], this.outputCanvas!);\n            } else {\n              await process(this.canvases[i], this.canvases[i + 1]);\n            }\n          }\n        } else if (plugin.getPluginType() === HMSVideoPluginType.ANALYZE && !skipProcessing) {\n          // there is no need to await for this case\n          await this.analytics.processWithTime(name, async () => await plugin.processVideoFrame(this.inputCanvas!));\n        }\n      } catch (err) {\n        //TODO error happened on processing of plugin notify UI\n        HMSLogger.e(TAG, `error in processing plugin ${name}`, err);\n        //remove plugin from loop and stop analytics for it\n        await this.removePlugin(plugin);\n      }\n      i++;\n    }\n  }\n\n  /**\n   * add the current native track to the inputVideoElement if it's not already added.\n   * @private\n   */\n  private async addTrackToVideo() {\n    if (!this.inputVideo) {\n      return;\n    }\n    const srcObject = this.inputVideo.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === this.hmsTrack.nativeTrack.id) {\n        // it's already attached\n        return;\n      }\n    }\n    this.inputVideo.pause();\n    this.inputVideo.srcObject = new MediaStream([this.hmsTrack.nativeTrack]);\n    this.inputVideo.muted = true;\n    this.inputVideo.playsInline = true;\n    if (this.inputVideo) {\n      this.inputVideo.oncanplaythrough = () => {\n        this.inputVideo?.play();\n      };\n    }\n  }\n\n  /**\n   * get the new video frame from input video element and put it on canvas\n   * @private\n   */\n  private async updateInputCanvas() {\n    if (!this.inputCanvas || !this.inputVideo) {\n      return;\n    }\n    const { width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT } = this.hmsTrack.getMediaTrackSettings();\n    // TODO: should we reduce height/width to optimize?\n    if (this.inputCanvas.height !== height) {\n      this.inputCanvas.height = height;\n    }\n    if (this.inputCanvas.width !== width) {\n      this.inputCanvas.width = width;\n    }\n    const ctx = this.inputCanvas.getContext('2d');\n    ctx!.drawImage(this.inputVideo, 0, 0, width, height);\n  }\n\n  private resetCanvases() {\n    if (!this.outputCanvas || !this.inputCanvas) {\n      return;\n    }\n    const inputCtx = this.inputCanvas.getContext('2d');\n    if (inputCtx) {\n      inputCtx.fillStyle = `rgb(0, 0, 0)`;\n      inputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    }\n    this.canvases = [];\n  }\n\n  /**\n    N = ceil(inputFrameRate/pluginFrameRate) - 1\n    N = this.pluginNumFramesToSkip[name] = frames to skip for every processed frame\n    all the frames we are skipping are using the previous frame output\n   **/\n  private checkIfSkipRequired(name: string) {\n    let skip = false;\n\n    if (this.pluginNumFramesSkipped[name] < this.pluginNumFramesToSkip[name]) {\n      this.pluginNumFramesSkipped[name]++;\n      skip = true;\n    } else {\n      skip = false;\n      this.pluginNumFramesSkipped[name] = 0;\n    }\n\n    return skip;\n  }\n}\n", "import HMSMediaStream from './HMSMediaStream';\nimport { HMSLocalTrack, HMSLocalVideoTrack } from '../tracks';\nimport HMSPublishConnection from '../../connection/publish';\nimport HMSLogger from '../../utils/logger';\nimport { SimulcastLayer } from '../../interfaces';\nimport { isNode } from '../../utils/support';\n\nconst TAG = 'HMSLocalStream';\n\nexport default class HMSLocalStream extends HMSMediaStream {\n  /** Connection set when publish is called for the first track */\n  private connection: HMSPublishConnection | null = null;\n\n  setConnection(connection: HMSPublishConnection) {\n    this.connection = connection;\n  }\n\n  addTransceiver(track: HMSLocalTrack, simulcastLayers: SimulcastLayer[]) {\n    const trackEncodings: RTCRtpEncodingParameters[] = [];\n    if (track instanceof HMSLocalVideoTrack) {\n      if (simulcastLayers.length > 0) {\n        HMSLogger.v(TAG, 'Simulcast enabled with layers', simulcastLayers);\n        trackEncodings.push(...simulcastLayers);\n      } else {\n        const encodings: RTCRtpEncodingParameters = { active: this.nativeStream.active };\n        if (track.settings.maxBitrate && !isNode) {\n          encodings.maxBitrate = track.settings.maxBitrate;\n        }\n        trackEncodings.push(encodings);\n      }\n    }\n\n    const transceiver = this.connection!.addTransceiver(track.getTrackBeingSent(), {\n      streams: [this.nativeStream],\n      direction: 'sendonly',\n      sendEncodings: trackEncodings,\n    });\n    this.setPreferredCodec(transceiver, track.nativeTrack.kind);\n    return transceiver;\n  }\n\n  async setMaxBitrate(maxBitrate: number, track: HMSLocalTrack): Promise<void> {\n    await this.connection?.setMaxBitrate(maxBitrate, track);\n  }\n\n  // @ts-ignore\n  setPreferredCodec(_transceiver: RTCRtpTransceiver, _kind: string) {\n    // TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?\n  }\n\n  /**\n   * On mute and unmute of video tracks as well as for changing cameras, we replace the track using replaceTrack api\n   * so as to avoid a renegotiation with the backend and reflect changes faster.\n   * @param track - the current track\n   * @param withTrack - the track to replace it with\n   */\n  async replaceTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    await this.replaceSenderTrack(track, withTrack);\n    track.stop(); // If the track is already stopped, this does not throw any error. \uD83D\uDE09\n    this.replaceStreamTrack(track, withTrack);\n  }\n\n  replaceStreamTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    this.nativeStream.addTrack(withTrack);\n    this.nativeStream.removeTrack(track);\n  }\n\n  /**\n   * In case of video plugins we need to replace the track sent to remote without stopping the original one. As\n   * if the original is stopped, plugin would stop getting input frames to process. So only the track in the\n   * sender needs to be replaced.\n   */\n  async replaceSenderTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    const sender = this.connection?.getSenders().find(sender => sender.track && sender.track!.id === track.id);\n\n    if (sender === undefined) {\n      HMSLogger.w(TAG, `No sender found for trackId=${track.id}`);\n      return;\n    }\n    await sender.replaceTrack(withTrack);\n  }\n\n  removeSender(track: HMSLocalTrack) {\n    let removedSenderCount = 0;\n    this.connection!.getSenders().forEach(sender => {\n      if (sender.track?.id === track.trackId || sender.track?.id === track.getTrackIDBeingSent()) {\n        this.connection!.removeTrack(sender);\n        removedSenderCount += 1;\n\n        // Remove the local reference as well\n        const toRemoveLocalTrackIdx = this.tracks.indexOf(track);\n        if (toRemoveLocalTrackIdx !== -1) {\n          this.tracks.splice(toRemoveLocalTrackIdx, 1);\n        } else {\n          HMSLogger.e(TAG, `Cannot find ${track.trackId} in locally stored tracks`);\n        }\n      }\n    });\n    if (removedSenderCount !== 1) {\n      HMSLogger.e(TAG, `Removed ${removedSenderCount} sender's, expected to remove 1`);\n    }\n  }\n\n  trackUpdate(track: HMSLocalTrack) {\n    this.connection?.trackUpdate(track);\n  }\n}\n", "import { HMSException } from '../error/HMSException';\nimport { HMSTrackSettings } from '../media/settings/HMSTrackSettings';\nimport { SelectedDevices } from '../device-manager';\nimport { DeviceMap } from '../interfaces';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { IAnalyticsPropertiesProvider } from './IAnalyticsPropertiesProvider';\nimport { HMSRemoteVideoTrack } from '../media/tracks';\nimport { AdditionalAnalyticsProperties } from './AdditionalAnalyticsProperties';\n\nexport default class AnalyticsEventFactory {\n  private static KEY_REQUESTED_AT = 'requested_at';\n  private static KEY_RESPONDED_AT = 'responded_at';\n\n  static connect(\n    error?: Error,\n    additionalProperties?: AdditionalAnalyticsProperties,\n    requestedAt: Date = new Date(),\n    respondedAt: Date = new Date(),\n    endpoint?: string,\n  ) {\n    const name = this.eventNameFor('connect', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError(\n      {\n        ...additionalProperties,\n        [this.KEY_REQUESTED_AT]: requestedAt?.getTime(),\n        [this.KEY_RESPONDED_AT]: respondedAt?.getTime(),\n        endpoint,\n      },\n      error,\n    );\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static disconnect(error?: Error, additionalProperties?: AdditionalAnalyticsProperties) {\n    const name = 'disconnected';\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(additionalProperties, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static preview({\n    error,\n    ...props\n  }: {\n    error?: Error;\n    time?: number;\n    init_response_time?: number;\n    ws_connect_time?: number;\n    on_policy_change_time?: number;\n    local_tracks_time?: number;\n  }) {\n    const name = this.eventNameFor('preview', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(props, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static join({\n    error,\n    ...props\n  }: {\n    error?: Error;\n    is_preview_called?: boolean;\n    start?: Date;\n    end?: Date;\n    time?: number;\n    init_response_time?: number;\n    ws_connect_time?: number;\n    on_policy_change_time?: number;\n    local_tracks_time?: number;\n    retries_join?: number;\n  }) {\n    const name = this.eventNameFor('join', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError({ ...props, is_preview_called: !!props.is_preview_called }, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static publish({ devices, settings, error }: { devices?: DeviceMap; settings?: HMSTrackSettings; error?: Error }) {\n    const name = this.eventNameFor('publish', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(\n      {\n        devices,\n        audio: settings?.audio,\n        video: settings?.video,\n      },\n      error,\n    );\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static subscribeFail(error: Error) {\n    const name = this.eventNameFor('subscribe', false);\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = this.getErrorProperties(error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static leave() {\n    return new AnalyticsEvent({ name: 'leave', level: AnalyticsEventLevel.INFO });\n  }\n\n  static autoplayError() {\n    return new AnalyticsEvent({ name: 'autoplayError', level: AnalyticsEventLevel.ERROR });\n  }\n\n  static deviceChange({\n    selection,\n    type,\n    devices,\n    error,\n  }: {\n    selection: Partial<SelectedDevices>;\n    type?: 'change' | 'list';\n    devices: DeviceMap;\n    error?: Error;\n  }) {\n    const name = this.eventNameFor(error ? 'publish' : `device.${type}`, error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError({ selection, devices }, error);\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static performance(stats: IAnalyticsPropertiesProvider) {\n    const name = 'perf.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static rtcStats(stats: IAnalyticsPropertiesProvider) {\n    const name = 'rtc.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  /**\n   * TODO: remove once everything is switched to server side degradation, this\n   * event can be handled on server side as well.\n   */\n  static degradationStats(track: HMSRemoteVideoTrack, isDegraded: boolean) {\n    const name = 'video.degradation.stats';\n    const level = AnalyticsEventLevel.INFO;\n    let properties: any = {\n      degradedAt: track.degradedAt,\n      trackId: track.trackId,\n    };\n\n    if (!isDegraded && track.degradedAt instanceof Date) {\n      // not degraded => restored\n      const restoredAt = new Date();\n      const duration = restoredAt.valueOf() - track.degradedAt.valueOf();\n      properties = { ...properties, duration, restoredAt };\n    }\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioDetectionFail(error: Error, device?: MediaDeviceInfo): AnalyticsEvent {\n    const properties = this.getPropertiesWithError({ device }, error);\n    const level = AnalyticsEventLevel.ERROR;\n    const name = 'audiopresence.failed';\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static previewNetworkQuality(properties: { downLink?: string; score?: number; error?: string }) {\n    return new AnalyticsEvent({\n      name: 'perf.networkquality.preview',\n      level: properties.error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO,\n      properties,\n    });\n  }\n\n  static HLSError(error: Error, start = true) {\n    return new AnalyticsEvent({\n      name: `hls.${start ? 'start' : 'stop'}.failed`,\n      level: AnalyticsEventLevel.ERROR,\n      properties: this.getPropertiesWithError(error),\n    });\n  }\n\n  static RTMPError(error: Error, start = true) {\n    return new AnalyticsEvent({\n      name: `rtmp.${start ? 'start' : 'stop'}.failed`,\n      level: AnalyticsEventLevel.ERROR,\n      properties: this.getPropertiesWithError(error),\n    });\n  }\n\n  private static eventNameFor(name: string, ok: boolean) {\n    const suffix = ok ? 'success' : 'failed';\n    return `${name}.${suffix}`;\n  }\n\n  private static getPropertiesWithError(initialProperties: any, error?: Error) {\n    const errorProperties = this.getErrorProperties(error);\n    initialProperties = { ...errorProperties, ...initialProperties };\n    return initialProperties;\n  }\n\n  private static getErrorProperties(error?: Error): Record<string, any> {\n    if (error) {\n      return error instanceof HMSException\n        ? error.toAnalyticsProperties()\n        : {\n            error_name: error.name,\n            error_message: error.message,\n            error_description: error.cause,\n          };\n    } else {\n      return {};\n    }\n  }\n}\n", "import { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport HMSLogger from './logger';\n\nexport async function getLocalStream(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AV);\n  }\n}\n\nexport async function getLocalScreen(constraints: MediaStreamConstraints['video']): Promise<MediaStream> {\n  try {\n    // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: constraints, audio: false });\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n  }\n}\n\ninterface MediaDeviceGroups {\n  audioinput: MediaDeviceInfo[];\n  audiooutput: MediaDeviceInfo[];\n  videoinput: MediaDeviceInfo[];\n}\n\nexport async function getLocalDevices(): Promise<MediaDeviceGroups> {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const deviceGroups: MediaDeviceGroups = {\n      audioinput: [],\n      audiooutput: [],\n      videoinput: [],\n    };\n    devices.forEach(device => deviceGroups[device.kind].push(device));\n    return deviceGroups;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AV);\n  }\n}\n\nexport interface HMSAudioContext {\n  audioContext: AudioContext | null;\n  getAudioContext: () => AudioContext;\n  resumeContext: () => void;\n}\n\nexport const HMSAudioContextHandler: HMSAudioContext = {\n  audioContext: null,\n  getAudioContext() {\n    if (!this.audioContext) {\n      this.audioContext = new AudioContext();\n    }\n    return this.audioContext;\n  },\n  resumeContext() {\n    this.getAudioContext()\n      .resume()\n      .catch(error => {\n        HMSLogger.e('AudioContext', error);\n      });\n  },\n};\n", "import HMSLogger from '../utils/logger';\n\nexport type TimedEventName = 'init' | 'websocket-open' | 'on-policy-change' | 'local-tracks' | 'preview' | 'join';\n\nexport enum TimedEvent {\n  INIT = 'init_response_time',\n  WEBSOCKET_CONNECT = 'ws_connect_time',\n  ON_POLICY_CHANGE = 'on_policy_change_time',\n  LOCAL_TRACKS = 'local_tracks_time',\n  JOIN = 'join_time',\n  PREVIEW = 'preview_time',\n}\n\nexport class AnalyticsTimer {\n  private eventPerformanceMeasures: Partial<Record<TimedEvent, PerformanceMeasure>> = {};\n\n  start(eventName: TimedEvent) {\n    performance.mark(eventName);\n  }\n\n  end(eventName: TimedEvent) {\n    try {\n      this.eventPerformanceMeasures[eventName] = performance.measure(eventName, eventName);\n      HMSLogger.d('[HMSPerformanceTiming]', eventName, this.eventPerformanceMeasures[eventName]?.duration);\n    } catch (error) {\n      HMSLogger.w('[AnalyticsTimer]', `Error in measuring performance for event ${eventName}`, { error });\n    }\n  }\n\n  getTimeTaken(eventName: TimedEvent) {\n    return this.eventPerformanceMeasures[eventName]?.duration;\n  }\n\n  getTimes(...eventNames: TimedEvent[]) {\n    return eventNames.reduce(\n      (timeObject, eventName) => ({ ...timeObject, [eventName]: this.getTimeTaken(eventName) }),\n      {},\n    );\n  }\n\n  cleanUp() {\n    this.eventPerformanceMeasures = {};\n  }\n}\n", "import { HMSAudioCodec, HMSVideoCodec } from '../interfaces';\nimport {\n  HMSAudioTrackSettings,\n  HMSAudioTrackSettingsBuilder,\n  HMSTrackSettings,\n  HMSTrackSettingsBuilder,\n  HMSVideoTrackSettings,\n  HMSVideoTrackSettingsBuilder,\n} from '../media/settings';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack, HMSTrackType } from '../media/tracks';\nimport { IStore } from './store';\nimport { IFetchAVTrackOptions } from '../transport/ITransport';\nimport HMSLogger from '../utils/logger';\nimport { HMSException } from '../error/HMSException';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { DeviceManager } from '../device-manager';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { EventBus } from '../events/EventBus';\nimport { HMSAudioContextHandler } from '../utils/media';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\n\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nlet blankCanvas: any;\n\nexport class LocalTrackManager {\n  readonly TAG: string = '[LocalTrackManager]';\n\n  constructor(\n    private store: IStore,\n    private observer: ITransportObserver,\n    private deviceManager: DeviceManager,\n    private eventBus: EventBus,\n    private analyticsTimer: AnalyticsTimer,\n  ) {}\n\n  // eslint-disable-next-line complexity\n  async getTracksToPublish(initialSettings: InitialSettings): Promise<HMSLocalTrack[]> {\n    const trackSettings = this.getTrackSettings(initialSettings);\n    if (!trackSettings) {\n      return [];\n    }\n    const canPublishAudio = !!trackSettings.audio;\n    const canPublishVideo = !!trackSettings.video;\n    let tracksToPublish: Array<HMSLocalTrack> = [];\n    const { videoTrack, audioTrack } = await this.updateCurrentLocalTrackSettings(trackSettings);\n    const localStream = (videoTrack?.stream || audioTrack?.stream) as HMSLocalStream | undefined;\n    // The track gets added to the store only after it is published.\n    const isVideoTrackPublished = Boolean(videoTrack && this.store.getTrackById(videoTrack.trackId));\n    const isAudioTrackPublished = Boolean(audioTrack && this.store.getTrackById(audioTrack.trackId));\n\n    if (isVideoTrackPublished && isAudioTrackPublished) {\n      // there is nothing to publish\n      return [];\n    }\n\n    const fetchTrackOptions: IFetchAVTrackOptions = {\n      audio: canPublishAudio && !audioTrack && (initialSettings.isAudioMuted ? 'empty' : true),\n      video: canPublishVideo && !videoTrack && (initialSettings.isVideoMuted ? 'empty' : true),\n    };\n\n    this.analyticsTimer.start(TimedEvent.LOCAL_TRACKS);\n    try {\n      HMSLogger.d(this.TAG, 'Init Local Tracks', { fetchTrackOptions });\n      tracksToPublish = await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n    } catch (error) {\n      tracksToPublish = await this.retryGetLocalTracks(\n        error as HMSException,\n        trackSettings,\n        fetchTrackOptions,\n        localStream,\n      );\n    }\n    this.analyticsTimer.end(TimedEvent.LOCAL_TRACKS);\n\n    /**\n     * concat local tracks only if both are true which means it is either join or switched from a role\n     * with no tracks earlier.\n     * the reason we need this is for preview API to work, in case of preview we want to publish the same\n     * tracks which were shown and are already part of the local peer instead of creating new ones.\n     * */\n    // if (publishConfig.publishAudio && publishConfig.publishVideo) {\n    //   return tracks.concat(localTracks);\n    // }\n    if (videoTrack && canPublishVideo && !isVideoTrackPublished) {\n      tracksToPublish.push(videoTrack);\n    }\n    if (audioTrack && canPublishAudio && !isAudioTrackPublished) {\n      tracksToPublish.push(audioTrack);\n    }\n    return tracksToPublish;\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  async getLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: true, video: true },\n    settings: HMSTrackSettings,\n    localStream?: HMSLocalStream,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      const nativeTracks = await this.getNativeLocalTracks(fetchTrackOptions, settings);\n      return this.createHMSLocalTracks(nativeTracks, settings, localStream);\n    } catch (error) {\n      // TOOD: On OverConstrained error, retry with dropping all constraints.\n      // Just retry getusermedia again - it sometimes work when AbortError or NotFoundError is thrown on a few devices\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.publish({\n          devices: this.deviceManager.getDevices(),\n          error: error as Error,\n          settings,\n        }),\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  private async getNativeLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: false, video: false },\n    settings: HMSTrackSettings,\n  ) {\n    const trackSettings = new HMSTrackSettings(\n      fetchTrackOptions.video === true ? settings.video : null,\n      fetchTrackOptions.audio === true ? settings.audio : null,\n      settings.simulcast,\n    );\n    const nativeTracks: MediaStreamTrack[] = [];\n\n    if (trackSettings.audio || trackSettings.video) {\n      nativeTracks.push(...(await this.getAVTracks(trackSettings)));\n    }\n    nativeTracks.push(...this.getEmptyTracks(fetchTrackOptions));\n    return nativeTracks;\n  }\n\n  async getLocalScreen(videosettings: HMSVideoTrackSettings, audioSettings?: HMSAudioTrackSettings) {\n    const constraints = {\n      video: videosettings.toConstraints(),\n    } as MediaStreamConstraints;\n    if (audioSettings) {\n      const audioConstraints: MediaTrackConstraints = audioSettings.toConstraints();\n      // remove advanced constraints as it not supported for screenshare audio\n      delete audioConstraints.advanced;\n      constraints.audio = {\n        ...audioConstraints,\n        autoGainControl: false,\n        noiseSuppression: false,\n        // @ts-ignore\n        googAutoGainControl: false,\n        echoCancellation: false,\n      };\n    }\n    let stream;\n    try {\n      // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n      stream = (await navigator.mediaDevices.getDisplayMedia(constraints)) as MediaStream;\n    } catch (err) {\n      throw BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    const local = new HMSLocalStream(stream);\n    const nativeVideoTrack = stream.getVideoTracks()[0];\n    const videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'screen', this.eventBus, videosettings);\n    tracks.push(videoTrack);\n    const nativeAudioTrack = stream.getAudioTracks()[0];\n    if (nativeAudioTrack) {\n      const audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'screen', this.eventBus, audioSettings);\n      tracks.push(audioTrack);\n    }\n\n    HMSLogger.v(this.TAG, 'getLocalScreen', tracks);\n    return tracks;\n  }\n\n  async requestPermissions() {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true,\n      });\n      // Stop stream\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      HMSLogger.e(this.TAG, error);\n    }\n  }\n\n  static getEmptyVideoTrack(prevTrack?: MediaStreamTrack): MediaStreamTrack {\n    const width = prevTrack?.getSettings()?.width || 320;\n    const height = prevTrack?.getSettings()?.height || 240;\n    const frameRate = 10; // fps TODO: experiment, see if this can be reduced\n    if (!blankCanvas) {\n      blankCanvas = Object.assign(document.createElement('canvas'), { width, height });\n      blankCanvas.getContext('2d')?.fillRect(0, 0, width, height);\n    }\n    const stream = blankCanvas.captureStream(frameRate);\n    const emptyTrack = stream.getVideoTracks()[0];\n    const intervalID = setInterval(() => {\n      if (emptyTrack.readyState === 'ended') {\n        clearInterval(intervalID);\n        return;\n      }\n      const ctx = blankCanvas.getContext('2d');\n      if (ctx) {\n        const pixel = ctx.getImageData(0, 0, 1, 1).data;\n        const red = pixel[0] === 0 ? 1 : 0; // toggle red in pixel\n        ctx.fillStyle = `rgb(${red}, 0, 0)`;\n        ctx.fillRect(0, 0, 1, 1);\n      }\n    }, 1000 / frameRate);\n    emptyTrack.onended = () => {\n      clearInterval(intervalID);\n    };\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  static getEmptyAudioTrack(): MediaStreamTrack {\n    const ctx = HMSAudioContextHandler.getAudioContext();\n    const oscillator = ctx.createOscillator();\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(dst);\n    oscillator.start();\n    const emptyTrack = dst.stream.getAudioTracks()[0];\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  private async getAVTracks(settings: HMSTrackSettings): Promise<Array<MediaStreamTrack>> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: settings.audio ? settings.audio.toConstraints() : false,\n        video: settings.video ? settings.video.toConstraints() : false,\n      });\n\n      return stream.getVideoTracks().concat(stream.getAudioTracks());\n    } catch (error) {\n      await this.deviceManager.init();\n      const videoError = !!(!this.deviceManager.hasWebcamPermission && settings.video);\n      const audioError = !!(!this.deviceManager.hasMicrophonePermission && settings.audio);\n      /**\n       * TODO: Only permission error throws correct device info in error(audio or video or both),\n       * Right now for other errors such as overconstrained error we are unable to get whether audio/video failure.\n       * Fix this by checking the native error message.\n       */\n      const errorType = this.getErrorType(videoError, audioError);\n      throw BuildGetMediaError(error as Error, errorType);\n    }\n  }\n\n  private getTrackSettings(initialSettings: InitialSettings): HMSTrackSettings | null {\n    const audioSettings = this.getAudioSettings(initialSettings);\n    const videoSettings = this.getVideoSettings(initialSettings);\n    if (!audioSettings && !videoSettings) {\n      return null;\n    }\n    const screenSettings = this.getScreenSettings();\n    return new HMSTrackSettingsBuilder().video(videoSettings).audio(audioSettings).screen(screenSettings).build();\n  }\n\n  // eslint-disable-next-line complexity\n  private async retryGetLocalTracks(\n    error: HMSException,\n    trackSettings: HMSTrackSettings,\n    fetchTrackOptions: IFetchAVTrackOptions,\n    localStream?: HMSLocalStream,\n  ): Promise<Array<HMSLocalTrack>> {\n    if (error instanceof HMSException && error.action === HMSAction.TRACK) {\n      this.observer.onFailure(error);\n\n      const overConstrainedFailure = error.code === ErrorCodes.TracksErrors.OVER_CONSTRAINED;\n      const audioFailure = error.message.includes('audio');\n      const videoFailure = error.message.includes('video');\n      if (overConstrainedFailure) {\n        // TODO: Use this once TODO@L#250 is completed\n        // const newTrackSettings = new HMSTrackSettingsBuilder()\n        //   .video(videoFailure ? new HMSVideoTrackSettings() : trackSettings.video)\n        //   .audio(audioFailure ? new HMSAudioTrackSettings() : trackSettings.audio)\n        //   .build();\n        const newTrackSettings = new HMSTrackSettingsBuilder()\n          .video(new HMSVideoTrackSettings())\n          .audio(new HMSAudioTrackSettings())\n          .build();\n\n        HMSLogger.w(this.TAG, 'Fetch AV Tracks failed with overconstrained error', { fetchTrackOptions }, { error });\n\n        try {\n          // Try get local tracks with no constraints\n          return await this.getLocalTracks(fetchTrackOptions, newTrackSettings, localStream);\n        } catch (error) {\n          /**\n           * This error shouldn't be overconstrained error(as we've dropped all constraints).\n           * If it's an overconstrained error, change error code to avoid recursive loop\n           * Try get local tracks for empty tracks\n           */\n          const nativeError: Error | undefined = error instanceof HMSException ? error.nativeError : (error as Error);\n          let ex = error;\n          if (nativeError?.name === 'OverconstrainedError') {\n            const newError = ErrorFactory.TracksErrors.GenericTrack(\n              HMSAction.TRACK,\n              'Overconstrained error after dropping all constraints',\n            );\n            newError.addNativeError(nativeError);\n            ex = newError;\n          }\n\n          return await this.retryGetLocalTracks(ex as HMSException, trackSettings, fetchTrackOptions, localStream);\n        }\n      }\n\n      fetchTrackOptions.audio = audioFailure ? 'empty' : fetchTrackOptions.audio;\n      fetchTrackOptions.video = videoFailure ? 'empty' : fetchTrackOptions.video;\n      HMSLogger.w(this.TAG, 'Fetch AV Tracks failed', { fetchTrackOptions }, error);\n      try {\n        return await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n      } catch (error) {\n        HMSLogger.w(this.TAG, 'Fetch empty tacks failed', error);\n        fetchTrackOptions.audio = fetchTrackOptions.audio && 'empty';\n        fetchTrackOptions.video = fetchTrackOptions.video && 'empty';\n        this.observer.onFailure(error as HMSException);\n        return await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n      }\n    } else {\n      HMSLogger.w(this.TAG, 'Fetch AV Tracks failed - unknown exception', error);\n      this.observer.onFailure(error);\n      return [];\n    }\n  }\n\n  private getErrorType(videoError: boolean, audioError: boolean): HMSGetMediaActions {\n    if (videoError && audioError) {\n      return HMSGetMediaActions.AV;\n    }\n    if (videoError) {\n      return HMSGetMediaActions.VIDEO;\n    }\n    if (audioError) {\n      return HMSGetMediaActions.AUDIO;\n    }\n    return HMSGetMediaActions.UNKNOWN;\n  }\n\n  private getEmptyTracks(fetchTrackOptions: IFetchAVTrackOptions) {\n    const nativeTracks: MediaStreamTrack[] = [];\n    if (fetchTrackOptions.audio === 'empty') {\n      nativeTracks.push(LocalTrackManager.getEmptyAudioTrack());\n    }\n\n    if (fetchTrackOptions.video === 'empty') {\n      nativeTracks.push(LocalTrackManager.getEmptyVideoTrack());\n    }\n    return nativeTracks;\n  }\n\n  private async updateCurrentLocalTrackSettings(trackSettings: HMSTrackSettings | null) {\n    const localTracks = this.store.getLocalPeerTracks();\n    const videoTrack = localTracks.find(t => t.type === HMSTrackType.VIDEO && t.source === 'regular') as\n      | HMSLocalVideoTrack\n      | undefined;\n    const audioTrack = localTracks.find(t => t.type === HMSTrackType.AUDIO && t.source === 'regular') as\n      | HMSLocalAudioTrack\n      | undefined;\n    const screenTrack = localTracks.find(t => t.type === HMSTrackType.VIDEO && t.source === 'screen') as\n      | HMSLocalVideoTrack\n      | undefined;\n\n    if (trackSettings?.video) {\n      await videoTrack?.setSettings(trackSettings.video);\n    }\n\n    if (trackSettings?.audio) {\n      await audioTrack?.setSettings(trackSettings.audio);\n    }\n\n    if (trackSettings?.screen) {\n      await screenTrack?.setSettings(trackSettings.screen);\n    }\n\n    return { videoTrack, audioTrack };\n  }\n\n  private getAudioSettings(initialSettings: InitialSettings) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('audio')) {\n      return null;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const audioTrack = localPeer?.audioTrack;\n    // Get device from the tracks already added in preview\n    const audioDeviceId = audioTrack?.settings.deviceId || initialSettings.audioInputDeviceId;\n\n    return new HMSAudioTrackSettingsBuilder()\n      .codec(publishParams.audio.codec as HMSAudioCodec)\n      .maxBitrate(publishParams.audio.bitRate)\n      .deviceId(audioDeviceId || defaultSettings.audioInputDeviceId)\n      .build();\n  }\n\n  private getVideoSettings(initialSettings: InitialSettings) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('video')) {\n      return null;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const videoTrack = localPeer?.videoTrack;\n    // Get device from the tracks already added in preview\n    const videoDeviceId = videoTrack?.settings.deviceId || initialSettings.videoDeviceId;\n    const video = publishParams.video;\n    const { width = video.width, height = video.height } = this.store.getSimulcastDimensions('regular') || {};\n    return new HMSVideoTrackSettingsBuilder()\n      .codec(video.codec as HMSVideoCodec)\n      .maxBitrate(video.bitRate)\n      .maxFramerate(video.frameRate)\n      .setWidth(width) // take simulcast width if available\n      .setHeight(height) // take simulcast width if available\n      .deviceId(videoDeviceId || defaultSettings.videoDeviceId)\n      .build();\n  }\n\n  private getScreenSettings() {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('screen')) {\n      return null;\n    }\n    const screen = publishParams.screen;\n    const { width = screen.width, height = screen.height } = this.store.getSimulcastDimensions('screen') || {};\n    return (\n      new HMSVideoTrackSettingsBuilder()\n        // Don't cap maxBitrate for screenshare.\n        // If publish params doesn't have bitRate value - don't set maxBitrate.\n        .maxBitrate(screen.bitRate, false)\n        .codec(screen.codec as HMSVideoCodec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(width)\n        .setHeight(height)\n        .build()\n    );\n  }\n\n  private createHMSLocalTracks(\n    nativeTracks: MediaStreamTrack[],\n    settings: HMSTrackSettings,\n    localStream?: HMSLocalStream,\n  ) {\n    const nativeVideoTrack = nativeTracks.find(track => track.kind === 'video');\n    const nativeAudioTrack = nativeTracks.find(track => track.kind === 'audio');\n    if (localStream) {\n      nativeTracks.forEach(track => localStream?.nativeStream.addTrack(track));\n    } else {\n      localStream = new HMSLocalStream(new MediaStream(nativeTracks));\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    if (nativeAudioTrack && settings?.audio) {\n      const audioTrack = new HMSLocalAudioTrack(\n        localStream,\n        nativeAudioTrack,\n        'regular',\n        this.eventBus,\n        settings.audio,\n      );\n      tracks.push(audioTrack);\n    }\n\n    if (nativeVideoTrack && settings?.video) {\n      const videoTrack = new HMSLocalVideoTrack(\n        localStream,\n        nativeVideoTrack,\n        'regular',\n        this.eventBus,\n        settings.video,\n      );\n      tracks.push(videoTrack);\n    }\n    return tracks;\n  }\n}\n", "import { HMSVideoTrack } from './HMSVideoTrack';\nimport HMSLocalStream from '../streams/HMSLocalStream';\nimport { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from '../settings';\nimport { getVideoTrack } from '../../utils/track';\nimport { HMSPluginSupportResult, HMSVideoPlugin } from '../../plugins';\nimport { HMSVideoPluginsManager } from '../../plugins/video';\nimport { HMSVideoTrackSettings as IHMSVideoTrackSettings } from '../../interfaces';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { EventBus } from '../../events/EventBus';\nimport { LocalTrackManager } from '../../sdk/LocalTrackManager';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSVideoTrackSettings>, oldSettings: HMSVideoTrackSettings) {\n  return function hasChanged(\n    prop: 'codec' | 'width' | 'height' | 'maxFramerate' | 'maxBitrate' | 'deviceId' | 'advanced',\n  ) {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport class HMSLocalVideoTrack extends HMSVideoTrack {\n  settings: HMSVideoTrackSettings;\n  private pluginsManager: HMSVideoPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n\n  /**\n   * @internal\n   * This is required for handling remote mute/unmute as the published track will not necessarily be same as\n   * the first track id or current native track's id.\n   * It won't be same as first track id if the native track was changed after preview started but before join happened,\n   * with device change, or mute/unmute.\n   * It won't be same as native track id, as the native track can change post join(and publish), when the nativetrack\n   * changes, replacetrack is used which doesn't involve republishing which means from server's point of view, the track id\n   * is same as what was initially published.\n   * This will only be available if the track was actually published and won't be set for preview tracks.\n   */\n  publishedTrackId?: string;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    private eventBus: EventBus,\n    settings: HMSVideoTrackSettings = new HMSVideoTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n    this.settings = settings;\n    // Replace the 'default' deviceId with the actual deviceId\n    // This is to maintain consistency with selected devices as in some cases there will be no 'default' device\n    if (settings.deviceId === 'default' && track.enabled) {\n      this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n    }\n    this.pluginsManager = new HMSVideoPluginsManager(this, eventBus);\n    this.setFirstTrackId(this.trackId);\n  }\n\n  /**\n   * use this function to set the enabled state of a track. If true the track will be unmuted and muted otherwise.\n   * @param value\n   */\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n    if (this.source === 'regular') {\n      let track: MediaStreamTrack;\n      if (value) {\n        track = await this.replaceTrackWith(this.settings);\n      } else {\n        track = await this.replaceTrackWithBlank();\n      }\n      await this.replaceSender(track, value);\n      this.nativeTrack = track;\n      if (value) {\n        await this.pluginsManager.waitForRestart();\n        this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n      }\n    }\n    await super.setEnabled(value);\n    this.eventBus.localVideoEnabled.publish({ enabled: value, track: this });\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  /**\n   * verify if the track id being passed is of this track for correlating server messages like degradation\n   */\n  isPublishedTrackId(trackId: string) {\n    return this.publishedTrackId === trackId;\n  }\n\n  /**\n   * @see HMSVideoTrack#addSink()\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.processedTrack || this.nativeTrack);\n  }\n\n  /**\n   * This function can be used to set media track settings. Frequent options -\n   * deviceID: can be used to change to different input source\n   * width, height - can be used to change capture dimensions\n   * maxFramerate - can be used to control the capture framerate\n   * @param settings\n   */\n  async setSettings(settings: Partial<IHMSVideoTrackSettings>, internal = false) {\n    const newSettings = this.buildNewSettings(settings);\n    await this.handleDeviceChange(newSettings, internal);\n    if (!this.enabled) {\n      // if track is muted, we just cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n    await this.handleSettingsChange(newSettings);\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin, pluginFrameRate);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async removePlugin(plugin: HMSVideoPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  validatePlugin(plugin: HMSVideoPlugin): HMSPluginSupportResult {\n    return this.pluginsManager.validatePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    this.processedTrack?.stop();\n  }\n\n  /**\n   * once the plugin manager has done its processing it can set or remove processed track via this method\n   * note that replacing sender track only makes sense if the native track is enabled. if it's disabled there is\n   * no point in replacing it. We'll update the processed track variable though so next time unmute happens\n   * it's set properly.\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // required replacement will happen when video is unmuted\n    if (!this.nativeTrack.enabled) {\n      this.processedTrack = processedTrack;\n      return;\n    }\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  /**\n   * @internal\n   * sent track id will be different in case there was some processing done using plugins.\n   * replace track is used to, start sending data from a new track without un publishing the prior one. There\n   * are thus two track ids - the one which was initially published and should be unpublished when required.\n   * The one whose data is currently being sent, which will be used when removing from connection senders.\n   */\n  getTrackIDBeingSent() {\n    return this.getTrackBeingSent().id;\n  }\n\n  getTrackBeingSent() {\n    return this.enabled ? this.processedTrack || this.nativeTrack : this.nativeTrack;\n  }\n\n  /**\n   * called when the video is unmuted\n   * @private\n   */\n  private async replaceTrackWith(settings: HMSVideoTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    prevTrack?.stop();\n    const newTrack = await getVideoTrack(settings);\n    // Replace deviceId with actual deviceId when it is default\n    if (this.settings.deviceId === 'default') {\n      this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId });\n    }\n    return newTrack;\n  }\n\n  /**\n   * called when the video is muted. A blank track is used to replace the original track. This is in order to\n   * turn off the camera light and keep the bytes flowing to avoid av sync, timestamp issues.\n   * @private\n   */\n  private async replaceTrackWithBlank() {\n    const prevTrack = this.nativeTrack;\n    prevTrack?.stop();\n    return LocalTrackManager.getEmptyVideoTrack(prevTrack);\n  }\n\n  private async replaceSender(newTrack: MediaStreamTrack, enabled: boolean) {\n    const localStream = this.stream as HMSLocalStream;\n    if (enabled) {\n      await localStream.replaceSenderTrack(this.nativeTrack, this.processedTrack || newTrack);\n    } else {\n      await localStream.replaceSenderTrack(this.processedTrack || this.nativeTrack, newTrack);\n    }\n    await localStream.replaceStreamTrack(this.nativeTrack, newTrack);\n  }\n\n  private buildNewSettings = (settings: Partial<HMSVideoTrackSettings>) => {\n    const { width, height, codec, maxFramerate, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSVideoTrackSettings(width, height, codec, maxFramerate, deviceId, advanced, maxBitrate);\n    return newSettings;\n  };\n\n  private handleSettingsChange = async (settings: HMSVideoTrackSettings) => {\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('maxBitrate') && settings.maxBitrate) {\n      await stream.setMaxBitrate(settings.maxBitrate, this);\n    }\n\n    if (hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(settings.toConstraints());\n    }\n  };\n\n  /**\n   * Replace video track with new track on device change\n   * @param settings - VideoSettings Object constructed with new settings\n   * @param internal - whether the change was because of internal sdk call or external client call\n   */\n  private handleDeviceChange = async (settings: HMSVideoTrackSettings, internal = false) => {\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId') && this.source === 'regular') {\n      if (this.enabled) {\n        const track = await this.replaceTrackWith(settings);\n        await this.replaceSender(track, this.enabled);\n        this.nativeTrack = track;\n      }\n      if (!internal) {\n        DeviceStorageManager.updateSelection('videoInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n  };\n}\n", "import { EventBus } from '../../events/EventBus';\nimport { HMSPeer, HMSSimulcastLayer, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack, HMSTrackType } from '../../media/tracks';\nimport { HMSRemotePeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { OnTrackLayerUpdateNotification, TrackState, TrackStateNotification } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Incoming track meta-data from BIZ(signal) to match a track to a peer.\n * - Incoming MediaStreamTracks(wrapped in HMSTracks) from RTCMediaChannel.\n * - Mute/unmute track meta-data updates from BIZ.\n *\n * Since track meta-data and RTC tracks come in asynchronously,\n * we store the track meta-data(TrackState) in SDK Store and tracks temporarily here in tracksToProcess.\n *\n * Once we have both TrackState and track,\n * we add it to peer, send listener.onTrackUpdate and remove it from tracksToProcess.\n *\n * Gotchas:\n * - TRACK_UPDATE comes before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n */\nexport class TrackManager {\n  private tracksToProcess: Map<string, HMSRemoteTrack> = new Map();\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  constructor(private store: IStore, private eventBus: EventBus, public listener?: HMSUpdateListener) {}\n\n  isTrackDegraded(prevLayer: HMSSimulcastLayer, newLayer: HMSSimulcastLayer): boolean {\n    const toInt = (layer: HMSSimulcastLayer): number => {\n      switch (layer) {\n        case HMSSimulcastLayer.HIGH:\n          return 3;\n        case HMSSimulcastLayer.MEDIUM:\n          return 2;\n        case HMSSimulcastLayer.LOW:\n          return 1;\n        case HMSSimulcastLayer.NONE:\n          return 0;\n      }\n    };\n\n    return toInt(newLayer) < toInt(prevLayer);\n  }\n\n  handleTrackMetadataAdd(params: TrackStateNotification) {\n    HMSLogger.d(this.TAG, `TRACK_METADATA_ADD`, params);\n\n    for (const trackId in params.tracks) {\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: params.tracks[trackId],\n      });\n    }\n\n    this.processPendingTracks();\n  }\n\n  /**\n   * Sets the tracks to peer and returns the peer\n   */\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKADD`, track, track.nativeTrack);\n    this.store.addTrack(track);\n    this.tracksToProcess.set(track.trackId, track);\n    this.processPendingTracks();\n  };\n\n  /**\n   * Sets the track of corresponding peer to null and returns the peer\n   */\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKREMOVE`, track, track.nativeTrack);\n    const trackStateEntry = this.store.getTrackState(track.trackId);\n\n    if (!trackStateEntry) {\n      return;\n    }\n\n    // emit this event here as peer will already be removed(if left the room) by the time this event is received\n    track.type === HMSTrackType.AUDIO && this.eventBus.audioTrackRemoved.publish(track as HMSRemoteAudioTrack);\n    const hmsPeer = this.store.getPeerById(trackStateEntry.peerId);\n    if (!hmsPeer) {\n      return;\n    }\n    this.removePeerTracks(hmsPeer, track);\n    this.store.removeTrack(track.trackId);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n  };\n\n  handleTrackLayerUpdate = (params: OnTrackLayerUpdateNotification) => {\n    for (const trackId in params.tracks) {\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n      if (!track) {\n        continue;\n      }\n\n      const peer = this.store.getPeerByTrackId(trackId)!;\n      if (!peer) {\n        continue;\n      }\n\n      if (track instanceof HMSRemoteVideoTrack) {\n        const isDegraded = this.isTrackDegraded(trackEntry.expected_layer, trackEntry.current_layer);\n        track.setLayerFromServer(trackEntry.current_layer, isDegraded);\n        if (isDegraded) {\n          this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_DEGRADED, track, peer);\n        } else {\n          this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_RESTORED, track, peer);\n        }\n      }\n    }\n  };\n\n  handleTrackUpdate = (params: TrackStateNotification) => {\n    const hmsPeer = this.store.getPeerById(params.peer.peer_id);\n    if (!hmsPeer) {\n      return;\n    }\n\n    for (const trackId in params.tracks) {\n      const currentTrackStateInfo = Object.assign({}, this.store.getTrackState(trackId)?.trackInfo);\n\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: { ...currentTrackStateInfo, ...trackEntry },\n      });\n\n      // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n      if (!track || this.tracksToProcess.has(trackId)) {\n        this.processPendingTracks();\n      } else {\n        track.setEnabled(!trackEntry.mute);\n        const eventType = this.processTrackUpdate(track as HMSRemoteTrack, currentTrackStateInfo, trackEntry);\n        if (eventType) {\n          this.listener?.onTrackUpdate(eventType, track, hmsPeer);\n        }\n      }\n    }\n  };\n\n  processPendingTracks() {\n    const tracksCopy = new Map(this.tracksToProcess);\n\n    tracksCopy.forEach(track => {\n      const state = this.store.getTrackState(track.trackId);\n      if (!state) {\n        return;\n      }\n\n      const hmsPeer = this.store.getPeerById(state.peerId);\n      if (!hmsPeer) {\n        return;\n      }\n\n      track.source = state.trackInfo.source;\n      track.peerId = hmsPeer.peerId;\n      // set log identifier to initial name of the peer\n      track.logIdentifier = hmsPeer.name;\n      track.setEnabled(!state.trackInfo.mute);\n      this.addAudioTrack(hmsPeer, track);\n      this.addVideoTrack(hmsPeer, track);\n      /**\n       * Don't call onTrackUpdate for audio elements immediately because the operations(eg: setVolume) performed\n       * on onTrackUpdate can be overriden in AudioSinkManager when audio element is created\n       **/\n      track.type === HMSTrackType.AUDIO\n        ? this.eventBus.audioTrackAdded.publish({ track: track as HMSRemoteAudioTrack, peer: hmsPeer as HMSRemotePeer })\n        : this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);\n      this.tracksToProcess.delete(track.trackId);\n    });\n  }\n\n  private removePeerTracks(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    const auxiliaryTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);\n    if (auxiliaryTrackIndex > -1) {\n      hmsPeer.auxiliaryTracks.splice(auxiliaryTrackIndex, 1);\n    } else {\n      if (track.type === HMSTrackType.AUDIO && hmsPeer.audioTrack?.trackId === track.trackId) {\n        hmsPeer.audioTrack = undefined;\n      } else if (track.type === HMSTrackType.VIDEO && hmsPeer.videoTrack?.trackId === track.trackId) {\n        hmsPeer.videoTrack = undefined;\n      }\n    }\n  }\n\n  private addAudioTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.type !== HMSTrackType.AUDIO) {\n      return;\n    }\n    if (!hmsPeer.audioTrack && track.source === 'regular') {\n      hmsPeer.audioTrack = track as HMSRemoteAudioTrack;\n    } else {\n      hmsPeer.auxiliaryTracks.push(track);\n    }\n  }\n\n  private addVideoTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.type !== HMSTrackType.VIDEO) {\n      return;\n    }\n    const remoteTrack = track as HMSRemoteVideoTrack;\n    const simulcastDefinitions = this.store.getSimulcastDefinitionsForPeer(hmsPeer, remoteTrack.source!);\n    remoteTrack.setSimulcastDefinitons(simulcastDefinitions);\n    if (!hmsPeer.videoTrack && track.source === 'regular') {\n      hmsPeer.videoTrack = remoteTrack;\n    } else {\n      hmsPeer.auxiliaryTracks.push(remoteTrack);\n    }\n  }\n\n  private processTrackUpdate(track: HMSRemoteTrack, currentTrackState: TrackState, trackState: TrackState) {\n    let eventType;\n    track.setEnabled(!trackState.mute);\n    if (currentTrackState.mute !== trackState.mute) {\n      eventType = trackState.mute ? HMSTrackUpdate.TRACK_MUTED : HMSTrackUpdate.TRACK_UNMUTED;\n      track.type === HMSTrackType.AUDIO &&\n        this.eventBus.audioTrackUpdate.publish({ track: track as HMSRemoteAudioTrack, enabled: !trackState.mute });\n    } else if (currentTrackState.description !== trackState.description) {\n      eventType = HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED;\n    }\n    return eventType;\n  }\n}\n", "import { HMSConnectionQuality, HMSConnectionQualityListener } from '../../interfaces';\nimport { ConnectionQualityList } from '../HMSNotifications';\n\nexport class ConnectionQualityManager {\n  constructor(public listener?: HMSConnectionQualityListener) {}\n\n  handleQualityUpdate(qualityList: ConnectionQualityList) {\n    const peers = qualityList.peers;\n    const hmsPeers: HMSConnectionQuality[] = peers.map(peer => {\n      return {\n        peerID: peer.peer_id,\n        downlinkQuality: peer.downlink_score,\n      };\n    });\n    this.listener?.onConnectionQualityUpdate(hmsPeers);\n  }\n}\n", "import { HMSAudioListener, HMSConnectionQualityListener, HMSUpdateListener } from '../interfaces';\nimport { HMSRemoteTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { HMSNotificationMethod } from './HMSNotificationMethod';\nimport {\n  ConnectionQualityList,\n  OnTrackLayerUpdateNotification,\n  PolicyParams,\n  SpeakerList,\n  TrackStateNotification,\n} from './HMSNotifications';\nimport { ActiveSpeakerManager } from './managers/ActiveSpeakerManager';\nimport { BroadcastManager } from './managers/BroadcastManager';\nimport { PeerListManager } from './managers/PeerListManager';\nimport { PeerManager } from './managers/PeerManager';\nimport { PolicyChangeManager } from './managers/PolicyChangeManager';\nimport { RequestManager } from './managers/RequestManager';\nimport { RoomUpdateManager } from './managers/RoomUpdateManager';\nimport { TrackManager } from './managers/TrackManager';\nimport { ConnectionQualityManager } from './managers/ConnectionQualityManager';\nimport { EventBus } from '../events/EventBus';\n\nexport class NotificationManager {\n  private TAG = '[HMSNotificationManager]';\n  private trackManager: TrackManager;\n  private peerManager: PeerManager;\n  private peerListManager: PeerListManager;\n  private activeSpeakerManager: ActiveSpeakerManager;\n  private connectionQualityManager: ConnectionQualityManager;\n  private broadcastManager: BroadcastManager;\n  private policyChangeManager: PolicyChangeManager;\n  private requestManager: RequestManager;\n  private roomUpdateManager: RoomUpdateManager;\n  /**\n   * room state can be sent before join in preview stage as well but that is outdated, based on\n   * eventual consistency and doesn't have all data. If we get at least one consistent room update\n   * from that point onwards we can rely on live server updates and ignore periodic room state messages\n   */\n  private hasConsistentRoomStateArrived = false;\n\n  constructor(\n    private store: IStore,\n    eventBus: EventBus,\n    private listener?: HMSUpdateListener,\n    private audioListener?: HMSAudioListener,\n    private connectionQualityListener?: HMSConnectionQualityListener,\n  ) {\n    this.trackManager = new TrackManager(this.store, eventBus, this.listener);\n    this.peerManager = new PeerManager(this.store, this.trackManager, this.listener);\n    this.peerListManager = new PeerListManager(this.store, this.peerManager, this.trackManager, this.listener);\n    this.broadcastManager = new BroadcastManager(this.store, this.listener);\n    this.policyChangeManager = new PolicyChangeManager(this.store, eventBus);\n    this.requestManager = new RequestManager(this.store, this.listener);\n    this.activeSpeakerManager = new ActiveSpeakerManager(this.store, this.listener, this.audioListener);\n    this.connectionQualityManager = new ConnectionQualityManager(this.connectionQualityListener);\n    this.roomUpdateManager = new RoomUpdateManager(this.store, this.listener);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n    this.trackManager.listener = listener;\n    this.peerManager.listener = listener;\n    this.peerListManager.listener = listener;\n    this.broadcastManager.listener = listener;\n    this.requestManager.listener = listener;\n    this.activeSpeakerManager.listener = listener;\n    this.roomUpdateManager.listener = listener;\n  }\n\n  setAudioListener(audioListener?: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.activeSpeakerManager.audioListener = audioListener;\n  }\n\n  setConnectionQualityListener(qualityListener?: HMSConnectionQualityListener) {\n    this.connectionQualityListener = qualityListener;\n    this.connectionQualityManager.listener = qualityListener;\n  }\n\n  handleNotification(message: { method: string; params: any }, isReconnecting = false) {\n    const method = message.method as HMSNotificationMethod;\n    const notification = message.params;\n\n    if (\n      ![\n        HMSNotificationMethod.ACTIVE_SPEAKERS,\n        HMSNotificationMethod.SFU_STATS,\n        HMSNotificationMethod.CONNECTION_QUALITY,\n      ].includes(method)\n    ) {\n      HMSLogger.d(this.TAG, `Received notification - ${method}`, { notification });\n    }\n    if (method === HMSNotificationMethod.SFU_STATS) {\n      if (window.HMS?.ON_SFU_STATS && typeof window.HMS?.ON_SFU_STATS === 'function') {\n        window.HMS.ON_SFU_STATS(message.params);\n      }\n    }\n\n    if (this.ignoreNotification(method)) {\n      return;\n    }\n\n    this.roomUpdateManager.handleNotification(method, notification);\n    this.peerManager.handleNotification(method, notification);\n    this.requestManager.handleNotification(method, notification);\n    this.peerListManager.handleNotification(method, notification, isReconnecting);\n    this.broadcastManager.handleNotification(method, notification);\n    this.handleIsolatedMethods(method, notification);\n  }\n\n  // eslint-disable-next-line complexity\n  handleIsolatedMethods(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.TRACK_METADATA_ADD: {\n        this.trackManager.handleTrackMetadataAdd(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_UPDATE: {\n        this.trackManager.handleTrackUpdate(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ON_SFU_TRACK_LAYER_UPDATE: {\n        this.trackManager.handleTrackLayerUpdate(notification as OnTrackLayerUpdateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ACTIVE_SPEAKERS:\n        this.activeSpeakerManager.handleActiveSpeakers(notification as SpeakerList);\n        break;\n\n      case HMSNotificationMethod.CONNECTION_QUALITY:\n        this.connectionQualityManager.handleQualityUpdate(notification as ConnectionQualityList);\n        break;\n\n      case HMSNotificationMethod.POLICY_CHANGE:\n        this.policyChangeManager.handlePolicyChange(notification as PolicyParams);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  ignoreNotification = (method: string): boolean => {\n    if (method === HMSNotificationMethod.PEER_LIST) {\n      this.hasConsistentRoomStateArrived = true;\n    } else if (method === HMSNotificationMethod.ROOM_STATE) {\n      // ignore periodic inconsistent room state if consistent one has arrived at least once\n      return this.hasConsistentRoomStateArrived;\n    }\n    return false;\n  };\n\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackAdd(track);\n  };\n\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackRemove(track);\n  };\n\n  updateLocalPeer = ({ name, metadata }: { name?: string; metadata?: string }) => {\n    const peer = this.store.getLocalPeer();\n    this.peerManager.handlePeerInfoUpdate({ peer, name, data: metadata });\n  };\n}\n", "import { HMSTrack, HMSTrackSource } from '../media/tracks/HMSTrack';\nimport { HMSRole } from '../interfaces/role';\nimport { Track } from '../signal/interfaces';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { HMSSimulcastLayer } from '../interfaces';\n\n/**\n * Interfaces for message received from BIZ Signal through Websocket.\n * These messages are handled by NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport interface ServerError {\n  code: number;\n  message?: string;\n}\n\nexport interface TrackStateNotification {\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  peer: PeerNotificationInfo;\n}\n\nexport interface OnTrackLayerUpdateNotification {\n  tracks: {\n    [track_id: string]: {\n      current_layer: HMSSimulcastLayer;\n      expected_layer: HMSSimulcastLayer;\n      track_id: string;\n    };\n  };\n}\n\nexport interface PeerNotificationInfo {\n  peer_id: string;\n  info: Info;\n}\n\nexport interface Info {\n  name: string;\n  data: string;\n  user_id: string;\n}\n\nexport interface PolicyParams {\n  name: string;\n  known_roles: {\n    [role: string]: HMSRole;\n  };\n  template_id: string;\n}\n\n/**\n * This is in a format biz sends/received the track metadata\n */\nexport class TrackState implements Track {\n  mute: boolean;\n  type: 'audio' | 'video';\n  source: HMSTrackSource;\n  description: string;\n  track_id: string;\n  stream_id: string;\n\n  constructor(track: HMSLocalTrack | Track) {\n    this.type = track.type;\n    this.source = track.source || 'regular';\n    this.description = '';\n    if (track instanceof HMSTrack) {\n      this.mute = !track.enabled;\n      this.track_id = track.publishedTrackId!;\n      this.stream_id = track.stream.id;\n    } else {\n      this.mute = track.mute;\n      this.track_id = track.track_id;\n      this.stream_id = track.stream_id;\n    }\n  }\n}\n\nexport interface PeerNotification {\n  peer_id: string;\n  info: Info;\n  role: string;\n  joined_at?: number;\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  is_from_room_state?: boolean;\n}\n\nexport interface RoomState {\n  name: string;\n  session_id?: string;\n  started_at?: number;\n  recording?: {\n    sfu: {\n      started_at?: number;\n      enabled: boolean;\n    };\n    browser: {\n      started_at?: number;\n      enabled: boolean;\n    };\n    hls: {\n      started_at?: number;\n      enabled: boolean;\n      config?: {\n        hls_vod: boolean;\n        single_file_per_layer: boolean;\n      };\n    };\n  };\n  streaming?: {\n    enabled: boolean;\n    rtmp: { enabled: boolean; started_at?: number };\n    hls: HLSNotification;\n  };\n}\n\nexport interface PeerListNotification {\n  peers: {\n    [peer_id: string]: PeerNotification;\n  };\n  room: RoomState;\n}\n\nexport interface PeriodicRoomState {\n  peer_count: number;\n  room: RoomState;\n  peers?: {\n    [peer_id: string]: PeerNotification;\n  };\n}\n\ninterface Speaker {\n  peer_id: string;\n  track_id: string;\n  level: number;\n}\n\nexport interface SpeakerList {\n  'speaker-list': Speaker[];\n}\n\ninterface ConnectionQuality {\n  peer_id: string;\n  downlink_score: number;\n}\n\nexport interface ConnectionQualityList {\n  peers: ConnectionQuality[];\n}\n\n/**\n * Represents the role change request received from the server\n */\nexport interface RoleChangeRequestParams {\n  requested_by?: string;\n  role: string;\n  token: string;\n}\n\nexport interface TrackUpdateRequestNotification {\n  requested_by?: string;\n  track_id: string;\n  stream_id: string;\n  mute: boolean;\n}\n\nexport interface ChangeTrackMuteStateNotification {\n  requested_by?: string;\n  roles?: string[];\n  type?: 'audio' | 'video';\n  source?: HMSTrackSource;\n  value: boolean;\n}\n\nexport interface PeerLeaveRequestNotification {\n  requested_by?: string;\n  reason: string;\n  room_end: boolean;\n}\n\nexport interface MessageNotification {\n  peer?: {\n    peer_id: string;\n    info: {\n      name: string;\n      data: any;\n      user_id: string;\n    };\n  };\n  roles?: string[];\n  private: boolean;\n  timestamp: number;\n  info: MessageNotificationInfo;\n}\n\nexport interface SendMessage {\n  info: MessageNotificationInfo;\n  roles?: string[];\n  peer_id?: string;\n}\n\nexport interface MessageNotificationInfo {\n  message: any;\n  type: string;\n}\n\nexport interface RecordingNotification {\n  type: 'sfu' | 'Browser';\n  started_at?: number;\n  peer?: PeerNotificationInfo;\n  error?: ServerError;\n}\n\nexport interface RTMPNotification {\n  peer?: PeerNotificationInfo;\n  started_at?: number;\n  error?: ServerError;\n}\n\nexport interface HLSNotification {\n  enabled: boolean;\n  variants?: Array<HLSVariantInfo>;\n  error?: ServerError;\n  hls_recording?: {\n    hls_vod: boolean;\n    single_file_per_layer: boolean;\n  };\n}\n\nexport interface HLSVariantInfo {\n  url: string;\n  meeting_url?: string;\n  metadata?: string;\n  started_at?: number;\n}\n", "export enum TransportState {\n  Disconnected = 'Disconnected',\n  Connecting = 'Connecting',\n  Joined = 'Joined',\n  Preview = 'Preview',\n  Failed = 'Failed',\n  Reconnecting = 'Reconnecting',\n  Leaving = 'Leaving',\n}\n", "export class JoinParameters {\n  constructor(\n    public authToken: string,\n    public peerId: string,\n    public peerName: string = '',\n    public data: string = '',\n    public endpoint: string = 'https://prod-init.100ms.live/init',\n    public autoSubscribeVideo: boolean = false,\n  ) {}\n}\n", "/**\n * Thresholds for the network quality scores in kbps.\n * ex: { 1: { low: 300, high: 400 }}\n */\nexport type ScoreMap = Record<\n  number,\n  {\n    low: number;\n    high?: number;\n  }\n>;\n\n/**\n * Informantion necessary to test network quality. it provides a url to be\n * downloaded and timeout for the url download. And also the scores to be\n * assigned based on the downloaded data and time.\n */\nexport interface NetworkHealth {\n  url: string;\n  timeout: number;\n  scoreMap: ScoreMap;\n}\nexport interface InitConfig {\n  readonly endpoint: string;\n  readonly log_level: string;\n  readonly policy: string;\n  readonly rtcConfiguration: RTCConfiguration;\n  readonly pingTimeout?: number;\n  readonly config: {\n    readonly enabledFlags?: Array<`${InitFlags}`>;\n    readonly networkHealth: NetworkHealth;\n  };\n}\n\nexport enum InitFlags {\n  FLAG_SERVER_SUB_DEGRADATION = 'subscribeDegradation',\n  FLAG_SERVER_SIMULCAST = 'simulcast',\n  FLAG_NON_WEBRTC_DISABLE_OFFER = 'nonWebRTCDisableOffer',\n}\n", "export enum TransportFailureCategory {\n  ConnectFailed,\n  SignalDisconnect,\n  JoinWSMessageFailed,\n  PublishIceConnectionFailed,\n  SubscribeIceConnectionFailed,\n}\n\nexport const Dependencies = {\n  [TransportFailureCategory.ConnectFailed]: [],\n  [TransportFailureCategory.SignalDisconnect]: [],\n  [TransportFailureCategory.JoinWSMessageFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.PublishIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.SubscribeIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n};\n", "export interface PromiseCallbacks<T> {\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport class PromiseWithCallbacks<T> {\n  promise: Promise<T>;\n  resolve!: (value: T) => void;\n  reject!: (reason?: any) => void;\n\n  constructor(cb: (resolve: (value: T) => void, reject: (reason?: any) => void) => any) {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      cb(resolve, reject);\n    });\n  }\n}\n", "import { HMSException } from '../error/HMSException';\nimport { MAX_TRANSPORT_RETRIES, MAX_TRANSPORT_RETRY_DELAY } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { PromiseWithCallbacks } from '../utils/promise';\nimport { TransportFailureCategory as TFC, Dependencies as TFCDependencies } from './models/TransportFailureCategory';\nimport { TransportState } from './models/TransportState';\n\n/**\n * Task which is executed by [RetryScheduler.schedule] until max retry count\n * is reached.\n *\n * Any exception raised while executing the task assumes that task is failed.\n * Failed tasks are retried if max retry count is not reached.\n *\n * @returns True if the task if successful, otherwise False\n *\n *\n */\ntype RetryTask = () => Promise<boolean>;\n\nconst TAG = '[RetryScheduler]';\n\ninterface ScheduleTaskParams {\n  category: TFC;\n  error: HMSException;\n  task: RetryTask;\n  originalState: TransportState;\n  maxFailedRetries?: number;\n  changeState?: boolean;\n}\n\nexport class RetryScheduler {\n  private inProgress = new Map<TFC, PromiseWithCallbacks<number>>();\n  private retryTaskIds: number[] = [];\n\n  constructor(\n    private onStateChange: (state: TransportState, error?: HMSException) => Promise<void>,\n    private sendEvent: (error: HMSException, category: TFC) => void,\n  ) {}\n\n  async schedule({\n    category,\n    error,\n    task,\n    originalState,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    changeState = true,\n  }: ScheduleTaskParams) {\n    await this.scheduleTask({ category, error, changeState, task, originalState, maxFailedRetries });\n  }\n\n  reset() {\n    this.retryTaskIds.forEach(future => clearTimeout(future));\n    this.retryTaskIds = [];\n    this.inProgress.clear();\n  }\n\n  // eslint-disable-next-line complexity\n  private async scheduleTask({\n    category,\n    error,\n    changeState,\n    task,\n    originalState,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    failedRetryCount = 0,\n  }: ScheduleTaskParams & { failedRetryCount?: number }): Promise<void> {\n    HMSLogger.d(TAG, 'schedule: ', { category: TFC[category], error });\n\n    // First schedule call\n    if (failedRetryCount === 0) {\n      const inProgressTask = this.inProgress.get(category);\n      if (inProgressTask) {\n        HMSLogger.d(TAG, `schedule: Already a task for ${TFC[category]} scheduled, waiting for its completion`);\n        await inProgressTask.promise;\n        return;\n      }\n\n      const taskPromise = new PromiseWithCallbacks<number>((_, __) => {});\n      this.inProgress.set(category, taskPromise);\n\n      this.sendEvent(error, category);\n    }\n\n    let hasFailedDependency = false;\n    const dependencies = TFCDependencies[category];\n\n    for (const dependencyIndexString in dependencies) {\n      const dependency = dependencies[parseInt(dependencyIndexString)];\n      try {\n        const dependencyTask = this.inProgress.get(dependency);\n        if (dependencyTask) {\n          HMSLogger.d(\n            TAG,\n            `schedule: Suspending retry task of ${TFC[category]}, waiting for ${TFC[dependency]} to recover`,\n          );\n          await dependencyTask.promise;\n          HMSLogger.d(\n            TAG,\n            `schedule: Resuming retry task ${TFC[category]} as it's dependency ${TFC[dependency]} is recovered`,\n          );\n        }\n      } catch (ex) {\n        HMSLogger.d(\n          TAG,\n          `schedule: Stopping retry task of ${TFC[category]} as it's dependency ${TFC[dependency]} failed to recover`,\n        );\n        hasFailedDependency = true;\n        break;\n      }\n    }\n\n    if (failedRetryCount >= maxFailedRetries || hasFailedDependency) {\n      error.description += `. [${TFC[category]}] Could not recover after ${failedRetryCount} tries`;\n\n      if (hasFailedDependency) {\n        error.description += ` Could not recover all of it's required dependencies - [${(dependencies as Array<TFC>)\n          .map(dep => TFC[dep])\n          .toString()}]`;\n      }\n      error.isTerminal = true;\n\n      // @NOTE: Don't reject to throw error for dependencies, use onStateChange\n      // const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      // taskPromise?.reject(error);\n      this.sendEvent(error, category);\n\n      this.reset();\n\n      if (changeState) {\n        this.onStateChange(TransportState.Failed, error);\n      } else {\n        throw error;\n      }\n\n      return;\n    }\n\n    if (changeState) {\n      this.onStateChange(TransportState.Reconnecting, error);\n    }\n\n    const delay = this.getDelayForRetryCount(category, failedRetryCount);\n\n    HMSLogger.i(\n      TAG,\n      `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Scheduling retry task in ${delay}ms`,\n    );\n\n    let taskSucceeded: boolean;\n    try {\n      taskSucceeded = await this.setTimeoutPromise(task, delay);\n    } catch (ex) {\n      taskSucceeded = false;\n      HMSLogger.w(\n        TAG,\n        `[${TFC[category]}] Un-caught exception ${(ex as HMSException).name} in retry-task, initiating retry`,\n        ex,\n      );\n    }\n\n    if (taskSucceeded) {\n      const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      taskPromise?.resolve(failedRetryCount);\n\n      if (changeState && this.inProgress.size === 0) {\n        this.onStateChange(originalState);\n      }\n      HMSLogger.i(TAG, `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Recovered \u267B\uFE0F`);\n    } else {\n      await this.scheduleTask({\n        category,\n        error,\n        changeState,\n        task,\n        originalState,\n        maxFailedRetries,\n        failedRetryCount: failedRetryCount + 1,\n      });\n    }\n  }\n\n  private getBaseDelayForTask(category: TFC, n: number) {\n    if (category === TFC.JoinWSMessageFailed) {\n      // linear backoff(2 + jitter for every retry)\n      return 2;\n    }\n    // exponential backoff\n    return Math.pow(2, n);\n  }\n\n  private getDelayForRetryCount(category: TFC, n: number) {\n    const delay = this.getBaseDelayForTask(category, n);\n    const jitter = category === TFC.JoinWSMessageFailed ? Math.random() * 2 : Math.random();\n    return Math.round(Math.min(delay + jitter, MAX_TRANSPORT_RETRY_DELAY) * 1000);\n  }\n\n  private async setTimeoutPromise<T>(task: () => Promise<T>, delay: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = window.setTimeout(async () => {\n        try {\n          const value: T = await task();\n          value && this.retryTaskIds.splice(this.retryTaskIds.indexOf(timeoutId), 1);\n          resolve(value);\n        } catch (error) {\n          reject(error);\n        }\n      }, delay);\n\n      this.retryTaskIds.push(timeoutId);\n    });\n  }\n}\n", "import { HMSRoom, HMSSpeaker, HMSRole, PublishParams, HMSConfig } from '../../interfaces';\nimport {\n  HMSTrack,\n  HMSAudioTrack,\n  HMSVideoTrack,\n  HMSTrackSource,\n  HMSRemoteVideoTrack,\n  HMSLocalTrack,\n} from '../../media/tracks';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from '../models/peer';\nimport {\n  SimulcastLayer,\n  SimulcastDimensions,\n  SimulcastLayers,\n  SimulcastLayerDefinition,\n} from '../../interfaces/simulcast-layers';\nimport { SubscribeDegradationParams } from '../../interfaces/subscribe-degradation-params';\nimport { Comparator } from './Comparator';\nimport { TrackState } from '../../notification-manager';\nimport { IErrorListener } from '../../interfaces/error-listener';\n\nexport type KnownRoles = { [role: string]: HMSRole };\nexport interface TrackStateEntry {\n  peerId: string;\n  trackInfo: TrackState;\n}\n\nexport enum ENV {\n  PROD = 'prod',\n  QA = 'qa',\n  DEV = 'dev',\n}\n\nexport interface IStore {\n  getConfig(): HMSConfig | undefined;\n  getEnv(): ENV;\n  getPublishParams(): PublishParams | undefined;\n\n  getComparator(): Comparator;\n\n  getRoom(): HMSRoom;\n  getPolicyForRole(role: string): HMSRole;\n  getKnownRoles(): KnownRoles;\n  getSimulcastLayers(source: HMSTrackSource): SimulcastLayer[];\n  getSimulcastDimensions(source: HMSTrackSource): SimulcastDimensions | undefined;\n  getSubscribeDegradationParams(): SubscribeDegradationParams | undefined;\n  getSimulcastDefinitionsForPeer(peer: HMSPeer, source: HMSTrackSource): SimulcastLayerDefinition[];\n\n  getLocalPeer(): HMSLocalPeer | undefined;\n  getRemotePeers(): HMSRemotePeer[];\n  getPeers(): HMSPeer[];\n\n  getTracksMap(): Record<string, HMSTrack>;\n  getTracks(): HMSTrack[];\n  getVideoTracks(): HMSVideoTrack[];\n  getAudioTracks(): HMSAudioTrack[];\n  getRemoteVideoTracks(): HMSRemoteVideoTrack[];\n\n  getPeerById(peerId: string): HMSPeer | undefined;\n  getTrackById(trackId: string): HMSTrack | undefined;\n  getPeerByTrackId(trackId: string): HMSPeer | undefined;\n  getPeerTracks(peerId: string): HMSTrack[];\n  getLocalPeerTracks(): HMSLocalTrack[];\n\n  getSpeakers(): HMSSpeaker[];\n  getSpeakerPeers(): HMSPeer[];\n\n  setRoom(room: HMSRoom): void;\n  setKnownRoles(knownRoles: KnownRoles): void;\n  setVideoSimulcastLayers(layers: SimulcastLayers): void;\n  setScreenshareSimulcastLayers(layers: SimulcastLayers): void;\n  setConfig(config: HMSConfig): void;\n  setPublishParams(params: PublishParams): void;\n  setErrorListener(listener: IErrorListener): void;\n\n  addPeer(peer: HMSPeer): void;\n  addTrack(track: HMSTrack): void;\n\n  getTrackState(trackId: string): TrackStateEntry;\n  setTrackState(trackState: TrackStateEntry): void;\n\n  removePeer(peerId: string): void;\n  removeTrack(trackId: string): void;\n\n  updateSpeakers(speakers: HMSSpeaker[]): void;\n  updateAudioOutputVolume(volume: number): void;\n  updateAudioOutputDevice(device: MediaDeviceInfo): void;\n\n  hasRoleDetailsArrived(): boolean;\n\n  cleanUp(): void;\n}\n", "import { ENV } from '../sdk/store/IStore';\nimport {\n  CLIENT_ANAYLTICS_PROD_ENDPOINT,\n  CLIENT_ANAYLTICS_QA_ENDPOINT,\n  CLIENT_ANAYLTICS_STORAGE_LIMIT,\n} from '../utils/constants';\nimport { LocalStorage } from '../utils/local-storage';\nimport HMSLogger from '../utils/logger';\nimport { userAgent } from '../utils/support';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\n\ninterface ClientEventBody {\n  event: string;\n  event_id: string;\n  peer: {\n    peer_id?: string;\n    role?: string;\n    joined_at?: number;\n    left_at?: number;\n    room_id?: string;\n    room_name?: string;\n    session_started_at?: number;\n    user_data?: string;\n    user_name?: string;\n    template_id?: string;\n    session_id?: string;\n  };\n  timestamp: number;\n  payload: Record<string, any>;\n  agent: string;\n  device_id: string;\n}\n\nclass ClientAnalyticsTransport implements IAnalyticsTransportProvider {\n  TAG = '[HTTPAnalyticsTransport]';\n  private failedEvents = new LocalStorage<AnalyticsEvent[]>('client-events');\n  isConnected = true;\n  private env: null | ENV = null;\n\n  setEnv(env: ENV) {\n    this.env = env;\n    this.flushFailedEvents();\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.env) {\n      this.addEventToStorage(event);\n      return;\n    }\n    const requestBody: ClientEventBody = {\n      event: event.name,\n      payload: event.properties,\n      event_id: String(event.timestamp),\n      peer: event.metadata.peer,\n      timestamp: event.timestamp,\n      agent: userAgent,\n      device_id: event.device_id,\n    };\n    const url = this.env === ENV.PROD ? CLIENT_ANAYLTICS_PROD_ENDPOINT : CLIENT_ANAYLTICS_QA_ENDPOINT;\n    fetch(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${event.metadata.token}` },\n      body: JSON.stringify(requestBody),\n    })\n      .then(response => {\n        // Ignore invalid token or expired token messages\n        if (response.status === 401) {\n          this.removeFromStorage(event);\n          return;\n        }\n        if (response.status !== 200) {\n          throw Error(response.statusText);\n        }\n        this.removeFromStorage(event);\n      })\n      .catch(error => {\n        HMSLogger.v(this.TAG, 'Failed to send event', error, event);\n        this.addEventToStorage(event);\n      });\n  }\n  flushFailedEvents() {\n    const events = this.failedEvents.get();\n    events?.forEach(event => this.sendEvent(event));\n  }\n\n  private addEventToStorage(event: AnalyticsEvent): void {\n    const existingEvents = this.failedEvents.get() || [];\n    if (!existingEvents.find(existingEvent => existingEvent.timestamp === event.timestamp)) {\n      if (existingEvents.length === CLIENT_ANAYLTICS_STORAGE_LIMIT) {\n        existingEvents.shift();\n      }\n      existingEvents.push(event);\n      this.failedEvents.set(existingEvents);\n    }\n  }\n\n  private removeFromStorage(event: AnalyticsEvent): void {\n    const events = this.failedEvents.get() || [];\n    const index = events.findIndex(storageEvent => storageEvent.timestamp === event.timestamp);\n    if (index > -1) {\n      events.splice(index, 1);\n      this.failedEvents.set(events);\n    }\n  }\n}\n\nexport const HTTPAnalyticsTransport = new ClientAnalyticsTransport();\n", "import HMSLogger from '../utils/logger';\nimport { Queue } from '../utils/queue';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { HTTPAnalyticsTransport } from './HTTPAnalyticsTransport';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\n\nexport abstract class AnalyticsTransport {\n  abstract transportProvider: IAnalyticsTransportProvider;\n  abstract failedEvents: Queue<AnalyticsEvent>;\n  private TAG = 'AnalyticsTransport';\n\n  sendEvent(event: AnalyticsEvent) {\n    try {\n      this.sendSingleEvent(event);\n      this.flushFailedEvents();\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'sendEvent failed', error);\n    }\n  }\n\n  flushFailedEvents(currentPeerId?: string) {\n    try {\n      HMSLogger.d(this.TAG, 'Flushing failed events', this.failedEvents);\n      while (this.failedEvents.size() > 0) {\n        const event = this.failedEvents.dequeue();\n        if (event) {\n          const isEventFromCurrentPeer = event.metadata?.peer.peer_id === currentPeerId;\n          if (isEventFromCurrentPeer || !event.metadata.peer.peer_id) {\n            this.sendSingleEvent(event);\n          } else {\n            HTTPAnalyticsTransport.sendEvent(event);\n          }\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'flushFailedEvents failed', error);\n    }\n  }\n\n  private sendSingleEvent(event: AnalyticsEvent) {\n    try {\n      this.transportProvider.sendEvent(event);\n      HMSLogger.d(this.TAG, 'Sent event', event.name, event);\n    } catch (error) {\n      HMSLogger.w(this.TAG, `${this.transportProvider.TAG}.sendEvent failed, adding to local storage events`, {\n        event,\n        error,\n      });\n      this.failedEvents.enqueue(event);\n      throw error;\n    }\n  }\n}\n", "import { ANALYTICS_BUFFER_SIZE } from '../../utils/constants';\nimport { LocalStorage } from '../../utils/local-storage';\nimport { Queue } from '../../utils/queue';\nimport AnalyticsEvent from '../AnalyticsEvent';\n\nexport class LocalStorageEvents extends Queue<AnalyticsEvent> {\n  private localStorage = new LocalStorage<AnalyticsEvent[]>('hms-analytics');\n\n  constructor() {\n    super(ANALYTICS_BUFFER_SIZE);\n    // @TODO: Currently we don't send failed events of old sessions. So reset localstorage for every session.\n    // Once support for failed events from old sessions is added, remove clear and init queue from localstorage.\n    this.localStorage.clear();\n    this.initLocalStorageQueue();\n  }\n\n  enqueue(event: AnalyticsEvent) {\n    super.enqueue(event);\n    this.localStorage.set(this.storage);\n  }\n\n  dequeue() {\n    const removedEvent = super.dequeue();\n    this.localStorage.set(this.storage);\n    return removedEvent;\n  }\n\n  private initLocalStorageQueue() {\n    this.localStorage.get()?.forEach(event => {\n      const eventInstance = new AnalyticsEvent(event);\n      super.enqueue(eventInstance);\n    });\n  }\n}\n", "import { ISignal } from '../../signal/ISignal';\nimport { AnalyticsTransport } from '../AnalyticsTransport';\nimport { LocalStorageEvents } from './LocalStoageEvents';\n\nexport class SignalAnalyticsTransport extends AnalyticsTransport {\n  failedEvents = new LocalStorageEvents();\n\n  constructor(public transportProvider: ISignal) {\n    super();\n  }\n}\n", "import { IStore } from '../sdk/store/IStore';\nimport { HMSRemoteVideoTrack } from '../media/tracks';\nimport HMSLogger from '../utils/logger';\nimport { EventBus } from '../events/EventBus';\n\n/** @see docs/Subscribe-Degradation.md */\nexport class TrackDegradationController {\n  private readonly TAG = '[TrackDegradationController]';\n  private readonly PACKETS_LOST_THRESHOLD: number;\n  private readonly MIN_DEGRADE_GRACE_PERIOD: number;\n  private readonly MIN_RECOVER_GRACE_PERIOD: number;\n  private readonly MAX_RECOVER_GRACE_PERIOD = 120;\n\n  private recoveringTrack?: HMSRemoteVideoTrack;\n  private degradeGracePeriod: number;\n  private recoverGracePeriod: number;\n  private recoverAttemptCount = 0;\n  private packetsLost = 0;\n\n  private get isAttemptingRecover() {\n    return Boolean(this.recoveringTrack);\n  }\n\n  constructor(private readonly store: IStore, private readonly eventBus: EventBus) {\n    const storeParams = this.store.getSubscribeDegradationParams()!;\n    this.PACKETS_LOST_THRESHOLD = storeParams.packetLossThreshold;\n    this.MIN_DEGRADE_GRACE_PERIOD = storeParams.degradeGracePeriodSeconds;\n    this.MIN_RECOVER_GRACE_PERIOD = storeParams.recoverGracePeriodSeconds;\n\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;\n  }\n\n  handleRtcStatsChange(packetsLost: number) {\n    /**\n     * packetLost is a running counter\n     * Degrade if packetsLost increase is greater than threshold\n     */\n    const shouldDegrade = packetsLost > this.packetsLost + this.PACKETS_LOST_THRESHOLD;\n    this.packetsLost = packetsLost;\n    shouldDegrade ? this.degrade() : this.recover();\n  }\n\n  degrade() {\n    if (this.degradeGracePeriod > 0) {\n      this.degradeGracePeriod--;\n      return;\n    }\n\n    if (this.isAttemptingRecover) {\n      return this.cancelRecovery();\n    }\n\n    HMSLogger.d(this.TAG, 'Packet loss increased, Degrading', { packetsLost: this.packetsLost });\n\n    this.degradeActiveTracksByHalf();\n\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;\n  }\n\n  recover() {\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    if (this.recoverGracePeriod > 0) {\n      this.recoverGracePeriod--;\n      return;\n    }\n\n    this.recoveringTrack = this.getActiveTracks(true).find(track => track.degraded);\n    if (!this.recoveringTrack) {\n      return;\n    }\n\n    HMSLogger.d(this.TAG, 'Packet lost stable, recovering track', this.recoveringTrack);\n    this.recoveringTrack.setDegradedFromSdk(false);\n    this.eventBus.trackRestored.publish(this.recoveringTrack);\n    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;\n  }\n\n  cleanUp() {\n    this.eventBus.trackDegraded.removeAllListeners();\n    this.eventBus.trackRestored.removeAllListeners();\n  }\n\n  private degradeActiveTracksByHalf() {\n    const activeTracks = this.getActiveTracks(false);\n    if (!activeTracks.length) {\n      return;\n    }\n    HMSLogger.d(this.TAG, { activeTracks: [...activeTracks] });\n\n    let halfCount = Math.ceil(activeTracks.length / 2);\n    while (halfCount--) {\n      const track = activeTracks.pop();\n      track!.setDegradedFromSdk(true);\n      this.eventBus.trackDegraded.publish(track!);\n    }\n  }\n\n  private getActiveTracks(includeDegraded: boolean) {\n    return this.store\n      .getRemoteVideoTracks()\n      .filter(track => track.hasSinks() && (!track.degraded || includeDegraded))\n      .sort((trackA, trackB) => {\n        const comparators = this.store.getComparator().getTrackComparators();\n        /**\n         * Sort in descending order of importance.\n         * Importance: Screenshare > Role Priority > Speaker > TrackId\n         */\n        return (\n          -1 *\n          (comparators.screenShare(trackA, trackB) ||\n            comparators.rolePriority(trackA, trackB) ||\n            comparators.peerAudioLevel(trackA, trackB) ||\n            this.store.getComparator().stringComparator(trackA.trackId, trackB.trackId))\n        );\n      })\n      .slice(0); // Shallow copy - clone array, keep track references\n  }\n\n  private cancelRecovery() {\n    if (this.recoveringTrack) {\n      this.recoveringTrack.setDegradedFromSdk(true);\n      this.eventBus.trackDegraded.publish(this.recoveringTrack);\n    }\n    this.recoveringTrack = undefined;\n    this.recoverAttemptCount++;\n    this.recoverGracePeriod = this.getDelayForRecoverCount(this.recoverAttemptCount);\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    HMSLogger.d(this.TAG, 'Recover Attempt Failed', {\n      count: this.recoverAttemptCount,\n      delay: this.recoverGracePeriod,\n    });\n  }\n\n  private getDelayForRecoverCount(count: number) {\n    const delay = this.MIN_RECOVER_GRACE_PERIOD + this.MIN_RECOVER_GRACE_PERIOD * count;\n    return Math.min(delay, this.MAX_RECOVER_GRACE_PERIOD);\n  }\n}\n", "import { HMSTrack, HMSLocalTrack } from '../media/tracks';\nimport {\n  HMSPeerStats,\n  HMSTrackStats,\n  PeerConnectionType,\n  RTCRemoteInboundRtpStreamStats,\n} from '../interfaces/webrtc-stats';\nimport { isPresent } from '../utils/validations';\nimport { HMSWebrtcStats } from './HMSWebrtcStats';\nimport HMSLogger from '../utils/logger';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\n\nconst getTrackAndConnectionType = (track: HMSTrack) => {\n  const outbound = track.stream instanceof HMSLocalStream;\n  const peerConnectionType: PeerConnectionType = outbound ? 'publish' : 'subscribe';\n  const nativeTrack: MediaStreamTrack = outbound ? (track as HMSLocalTrack).getTrackBeingSent() : track.nativeTrack;\n  return { peerConnectionType, nativeTrack };\n};\n\nexport const getTrackStats = async (\n  getStats: HMSWebrtcStats['getStats'],\n  track: HMSTrack,\n  peerName?: string,\n  prevTrackStats?: HMSTrackStats,\n): Promise<HMSTrackStats | undefined> => {\n  const { peerConnectionType, nativeTrack } = getTrackAndConnectionType(track);\n  let trackReport: RTCStatsReport | undefined;\n  try {\n    trackReport = await getStats[peerConnectionType]?.(nativeTrack);\n  } catch (err) {\n    HMSLogger.w('[HMSWebrtcStats]', 'Error in getting track stats', track, nativeTrack, err);\n  }\n  const trackStats = getRelevantStatsFromTrackReport(trackReport);\n\n  const bitrate = computeBitrate(\n    (peerConnectionType === 'publish' ? 'bytesSent' : 'bytesReceived') as any,\n    trackStats,\n    prevTrackStats,\n  );\n\n  const packetsLostRate = computeStatRate('packetsLost', trackStats, prevTrackStats);\n\n  if (trackStats?.remote) {\n    Object.assign(trackStats.remote, {\n      packetsLostRate: computeStatRate('packetsLost', trackStats.remote, prevTrackStats?.remote),\n    });\n  }\n\n  return (\n    trackStats &&\n    Object.assign(trackStats, {\n      bitrate,\n      packetsLostRate,\n      peerId: track.peerId,\n      peerName,\n      codec: trackStats.codec,\n    })\n  );\n};\n\nconst getRelevantStatsFromTrackReport = (trackReport?: RTCStatsReport) => {\n  let streamStats: RTCInboundRtpStreamStats | RTCOutboundRtpStreamStats | undefined;\n  // Valid by Webrtc spec, not in TS\n  // let remoteStreamStats: RTCRemoteInboundRtpStreamStats | RTCRemoteOutboundRtpStreamStats;\n  let remoteStreamStats: RTCRemoteInboundRtpStreamStats | undefined;\n\n  const mimeTypes: { [key: string]: string } = {}; // codecId -> mimeType\n  trackReport?.forEach(stat => {\n    switch (stat.type) {\n      case 'inbound-rtp':\n        streamStats = stat;\n        break;\n      case 'outbound-rtp':\n        streamStats = stat;\n        break;\n      case 'remote-inbound-rtp':\n        remoteStreamStats = stat;\n        break;\n      case 'codec':\n        mimeTypes[stat.id] = stat.mimeType;\n        break;\n      default:\n        break;\n    }\n  });\n\n  const mimeType = streamStats?.codecId ? mimeTypes[streamStats.codecId] : undefined;\n  let codec: string | undefined;\n  if (mimeType) {\n    codec = mimeType.substring(mimeType.indexOf('/') + 1);\n  }\n\n  return (\n    streamStats &&\n    Object.assign(streamStats, {\n      remote: remoteStreamStats,\n      codec: codec,\n    })\n  );\n};\n\nexport const getLocalPeerStatsFromReport = (\n  type: PeerConnectionType,\n  report: RTCStatsReport,\n  prevStats?: HMSPeerStats,\n): (RTCIceCandidatePairStats & { bitrate: number }) | undefined => {\n  const activeCandidatePair = getActiveCandidatePairFromReport(report);\n  const bitrate = computeBitrate(\n    (type === 'publish' ? 'bytesSent' : 'bytesReceived') as any,\n    activeCandidatePair,\n    prevStats && prevStats[type],\n  );\n\n  return activeCandidatePair && Object.assign(activeCandidatePair, { bitrate });\n};\n\nexport const getActiveCandidatePairFromReport = (report: RTCStatsReport): RTCIceCandidatePairStats | undefined => {\n  let activeCandidatePair: RTCIceCandidatePairStats | undefined;\n  report.forEach(stat => {\n    if (stat.type === 'transport') {\n      // TS doesn't have correct types for RTCStatsReports\n      // @ts-expect-error\n      activeCandidatePair = report.get(stat.selectedCandidatePairId);\n    }\n  });\n\n  // Fallback for Firefox.\n  if (!activeCandidatePair) {\n    report.forEach(stat => {\n      if (stat.type === 'candidate-pair' && stat.selected) {\n        activeCandidatePair = stat;\n      }\n    });\n  }\n\n  return activeCandidatePair;\n};\n\nexport const getPacketsLostAndJitterFromReport = (report?: RTCStatsReport): { packetsLost: number; jitter: number } => {\n  const result = { packetsLost: 0, jitter: 0 };\n  report?.forEach(stat => {\n    if (stat.packetsLost) {\n      result.packetsLost += stat.packetsLost;\n    }\n    if (stat.jitter > result.jitter) {\n      result.jitter = stat.jitter;\n    }\n  });\n\n  return result;\n};\n\nexport const union = <T>(arr1: T[], arr2: T[]): T[] => {\n  return Array.from(new Set(arr1.concat(arr2)));\n};\n\n/**\n * Ref: https://github.dev/peermetrics/webrtc-stats/blob/b5c1fed68325543e6f563c6d3f4450a4b51e12b7/src/utils.ts#L62\n */\nexport const computeBitrate = <T extends HMSTrackStats>(\n  statName: keyof T,\n  newReport?: Partial<T>,\n  oldReport?: Partial<T>,\n): number => computeStatRate(statName, newReport, oldReport) * 8; // Bytes to bits\n\nconst computeStatRate = <T extends HMSTrackStats>(\n  statName: keyof T,\n  newReport?: Partial<T>,\n  oldReport?: Partial<T>,\n): number => {\n  const newVal = newReport && newReport[statName];\n  const oldVal = oldReport ? oldReport[statName] : null;\n  const conditions = [newReport, oldReport, isPresent(newVal), isPresent(oldVal)];\n  if (conditions.every(condition => !!condition)) {\n    // Type not null checked in `isPresent`\n    // * 1000 - ms to s\n    return (\n      computeNumberRate(\n        newVal as unknown as number,\n        oldVal as unknown as number,\n        newReport?.timestamp,\n        oldReport?.timestamp,\n      ) * 1000\n    );\n  } else {\n    return 0;\n  }\n};\n\nexport const computeNumberRate = (newVal?: number, oldVal?: number, newTimestamp?: number, oldTimestamp?: number) => {\n  if (isPresent(newVal) && isPresent(oldVal) && newTimestamp && oldTimestamp) {\n    return ((newVal as number) - (oldVal as number)) / (newTimestamp - oldTimestamp);\n  } else {\n    return 0;\n  }\n};\n", "import { IStore } from '../sdk/store';\nimport { PeerConnectionType, HMSPeerStats, HMSTrackStats } from '../interfaces/webrtc-stats';\nimport {\n  union,\n  computeNumberRate,\n  getTrackStats,\n  getLocalPeerStatsFromReport,\n  getPacketsLostAndJitterFromReport,\n} from './utils';\nimport HMSLogger from '../utils/logger';\n\nexport class HMSWebrtcStats {\n  private readonly TAG = '[HMSWebrtcStats]';\n  private localPeerID?: string;\n  private peerStats: Record<string, HMSPeerStats> = {};\n  private trackStats: Record<string, HMSTrackStats> = {};\n\n  /**\n   * Removed localPeerID check in other places as it will be present before\n   * this is initialized\n   */\n  constructor(\n    private getStats: Record<PeerConnectionType, RTCPeerConnection['getStats'] | undefined>,\n    private store: IStore,\n  ) {\n    this.localPeerID = this.store.getLocalPeer()?.peerId;\n  }\n\n  getLocalPeerStats(): HMSPeerStats | undefined {\n    return this.peerStats[this.localPeerID!];\n  }\n\n  getTrackStats(trackId: string): HMSTrackStats | undefined {\n    return this.trackStats[trackId];\n  }\n\n  /**\n   * @internal\n   */\n  async updateStats() {\n    await this.updateLocalPeerStats();\n    await this.updateTrackStats();\n  }\n\n  private async updateLocalPeerStats() {\n    const prevLocalPeerStats = this.getLocalPeerStats();\n    let publishReport: RTCStatsReport | undefined;\n    try {\n      publishReport = await this.getStats.publish?.();\n    } catch (err) {\n      HMSLogger.w(this.TAG, 'Error in getting publish stats', err);\n    }\n    const publishStats: HMSPeerStats['publish'] | undefined =\n      publishReport && getLocalPeerStatsFromReport('publish', publishReport, prevLocalPeerStats);\n\n    let subscribeReport: RTCStatsReport | undefined;\n    try {\n      subscribeReport = await this.getStats.subscribe?.();\n    } catch (err) {\n      HMSLogger.w(this.TAG, 'Error in getting subscribe stats', err);\n    }\n    const baseSubscribeStats =\n      subscribeReport && getLocalPeerStatsFromReport('subscribe', subscribeReport, prevLocalPeerStats);\n    const { packetsLost, jitter } = getPacketsLostAndJitterFromReport(subscribeReport);\n    const packetsLostRate = computeNumberRate(\n      packetsLost,\n      prevLocalPeerStats?.subscribe?.packetsLost,\n      baseSubscribeStats?.timestamp,\n      prevLocalPeerStats?.subscribe?.timestamp,\n    );\n\n    const subscribeStats: HMSPeerStats['subscribe'] =\n      baseSubscribeStats && Object.assign(baseSubscribeStats, { packetsLostRate, jitter, packetsLost });\n\n    this.peerStats[this.localPeerID!] = { publish: publishStats, subscribe: subscribeStats };\n  }\n\n  private async updateTrackStats() {\n    const tracks = this.store.getTracksMap();\n    const trackIDs = union(Object.keys(this.trackStats), Object.keys(tracks));\n    for (const trackID of trackIDs) {\n      const track = tracks[trackID];\n      if (track) {\n        const peerName = track.peerId && this.store.getPeerById(track.peerId)?.name;\n        const prevTrackStats = this.getTrackStats(track.trackId);\n        const trackStats = await getTrackStats(this.getStats, track, peerName, prevTrackStats);\n        if (trackStats) {\n          this.trackStats[trackID] = trackStats;\n        }\n      } else {\n        delete this.trackStats[trackID];\n      }\n    }\n  }\n}\n", "import { EventBus } from '../events/EventBus';\nimport { HMSWebrtcStats } from './HMSWebrtcStats';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { RTC_STATS_MONITOR_INTERVAL } from '../utils/constants';\nimport { sleep } from '../utils/timer-utils';\n\nexport class HMSWebrtcInternals {\n  private readonly TAG = '[HMSWebrtcInternals]';\n  private readonly interval = RTC_STATS_MONITOR_INTERVAL;\n  private isMonitored = false;\n  private hmsStats?: HMSWebrtcStats;\n\n  constructor(\n    private readonly store: IStore,\n    private readonly eventBus: EventBus,\n    private publishConnection?: RTCPeerConnection,\n    private subscribeConnection?: RTCPeerConnection,\n  ) {}\n\n  getPublishPeerConnection() {\n    return this.publishConnection;\n  }\n\n  getSubscribePeerConnection() {\n    return this.subscribeConnection;\n  }\n\n  getCurrentStats() {\n    return this.hmsStats;\n  }\n\n  onStatsChange(statsChangeCb: (stats: HMSWebrtcStats) => void) {\n    this.eventBus.statsUpdate.subscribe(statsChangeCb);\n    return () => {\n      this.eventBus.statsUpdate.unsubscribe(statsChangeCb);\n    };\n  }\n\n  private handleStatsUpdate = async () => {\n    await this.hmsStats?.updateStats();\n    this.eventBus.statsUpdate.publish(this.hmsStats);\n  };\n\n  /**\n   *\n   * @internal\n   */\n  setPeerConnections({ publish, subscribe }: { publish?: RTCPeerConnection; subscribe?: RTCPeerConnection }) {\n    this.publishConnection = publish;\n    this.subscribeConnection = subscribe;\n\n    this.hmsStats = new HMSWebrtcStats(\n      {\n        publish: this.publishConnection?.getStats.bind(this.publishConnection),\n        subscribe: this.subscribeConnection?.getStats.bind(this.subscribeConnection),\n      },\n      this.store,\n    );\n  }\n\n  /**\n   * @internal\n   */\n  async start() {\n    if (this.isMonitored) {\n      HMSLogger.d(this.TAG, 'Already started');\n      return;\n    }\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d(this.TAG, 'Starting Webrtc Stats Monitor');\n    this.startLoop()\n      .then(() => HMSLogger.d(this.TAG, 'Stopping Webrtc Stats Monitor'))\n      .catch(e => HMSLogger.e(this.TAG, e.message));\n  }\n\n  private stop() {\n    this.isMonitored = false;\n  }\n\n  private async startLoop() {\n    while (this.isMonitored) {\n      await this.handleStatsUpdate();\n      await sleep(this.interval);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  cleanUp() {\n    this.stop();\n    this.eventBus.statsUpdate.removeAllListeners();\n  }\n}\n", "// @ts-nocheck\nimport { isBrowser } from './support';\n\nexport const getNetworkInfo = () => {\n  if (!isBrowser || typeof navigator.connection === 'undefined') {\n    return;\n  }\n\n  const connection = navigator.connection;\n  const networkInfo = {\n    downlink: connection.downlink,\n    downlinkMax: connection.downlinkMax,\n    effectiveType: connection.effectiveType,\n    rtt: connection.rtt,\n    saveData: connection.saveData,\n    type: connection.type,\n  };\n  return networkInfo;\n};\n", "import ITransportObserver from './ITransportObserver';\nimport ITransport from './ITransport';\nimport HMSPublishConnection from '../connection/publish';\nimport HMSSubscribeConnection from '../connection/subscribe';\nimport InitService from '../signal/init';\nimport { ISignalEventsObserver } from '../signal/ISignalEventsObserver';\nimport JsonRpcSignal from '../signal/jsonrpc';\nimport { HMSConnectionRole, HMSTrickle } from '../connection/model';\nimport { IPublishConnectionObserver } from '../connection/publish/IPublishConnectionObserver';\nimport ISubscribeConnectionObserver from '../connection/subscribe/ISubscribeConnectionObserver';\nimport { HMSTrack, HMSLocalTrack } from '../media/tracks';\nimport { HMSException } from '../error/HMSException';\nimport { PromiseCallbacks } from '../utils/promise';\nimport {\n  MAX_TRANSPORT_RETRIES,\n  RENEGOTIATION_CALLBACK_ID,\n  SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID,\n  SUBSCRIBE_TIMEOUT,\n} from '../utils/constants';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport HMSLogger from '../utils/logger';\nimport { HMSVideoTrackSettings, HMSAudioTrackSettings, HMSTrackSettings } from '../media/settings';\nimport { TrackState } from '../notification-manager';\nimport { TransportState } from './models/TransportState';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { JoinParameters } from './models/JoinParameters';\nimport { InitConfig, InitFlags } from '../signal/init/models';\nimport { TransportFailureCategory } from './models/TransportFailureCategory';\nimport { RetryScheduler } from './RetryScheduler';\nimport { userAgent } from '../utils/support';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { SignalAnalyticsTransport } from '../analytics/signal-transport/SignalAnalyticsTransport';\nimport { HMSPeer, HMSRoleChangeRequest, HLSConfig, HMSRole, HLSTimedMetadata } from '../interfaces';\nimport { TrackDegradationController } from '../degradation';\nimport { IStore } from '../sdk/store';\nimport { DeviceManager } from '../device-manager';\nimport {\n  HLSRequestParams,\n  HLSTimedMetadataParams,\n  HLSVariant,\n  MultiTrackUpdateRequestParams,\n  StartRTMPOrRecordingRequestParams,\n  TrackUpdateRequestParams,\n} from '../signal/interfaces';\nimport Message from '../sdk/models/HMSMessage';\nimport { ISignal } from '../signal/ISignal';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport { LocalTrackManager } from '../sdk/LocalTrackManager';\nimport { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';\nimport { EventBus } from '../events/EventBus';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';\nimport { getNetworkInfo } from '../utils/network-info';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\n\nconst TAG = '[HMSTransport]:';\n\n// @DISCUSS: action and extra are not used at all.\ninterface CallbackTriple {\n  promise: PromiseCallbacks<boolean>;\n  action: HMSAction;\n  extra: any;\n}\n\ninterface NegotiateJoinParams {\n  name: string;\n  data: string;\n  autoSubscribeVideo: boolean;\n  serverSubDegrade: boolean;\n}\n\nexport default class HMSTransport implements ITransport {\n  private state: TransportState = TransportState.Disconnected;\n  private trackStates: Map<string, TrackState> = new Map();\n  private publishConnection: HMSPublishConnection | null = null;\n  private subscribeConnection: HMSSubscribeConnection | null = null;\n  private initConfig?: InitConfig;\n  private endpoint!: string;\n  private joinParameters?: JoinParameters;\n  private retryScheduler: RetryScheduler;\n  private trackDegradationController?: TrackDegradationController;\n  private webrtcInternals?: HMSWebrtcInternals;\n  private maxSubscribeBitrate = 0;\n  private joinRetryCount = 0;\n\n  constructor(\n    private observer: ITransportObserver,\n    private deviceManager: DeviceManager,\n    private store: IStore,\n    private localTrackManager: LocalTrackManager,\n    private eventBus: EventBus,\n    private analyticsEventsService: AnalyticsEventsService,\n    private analyticsTimer: AnalyticsTimer,\n  ) {\n    this.webrtcInternals = new HMSWebrtcInternals(\n      this.store,\n      this.eventBus,\n      this.publishConnection?.nativeConnection,\n      this.subscribeConnection?.nativeConnection,\n    );\n\n    const onStateChange = async (state: TransportState, error?: HMSException) => {\n      if (state !== this.state) {\n        this.state = state;\n        await this.observer.onStateChange(this.state, error);\n      }\n    };\n    this.retryScheduler = new RetryScheduler(onStateChange, this.sendErrorAnalyticsEvent.bind(this));\n\n    this.eventBus.statsUpdate.subscribe(stats => {\n      const currentSubscribeBitrate = stats.getLocalPeerStats()?.subscribe?.bitrate || 0;\n      this.maxSubscribeBitrate = Math.max(this.maxSubscribeBitrate, currentSubscribeBitrate);\n    });\n  }\n\n  /**\n   * Map of callbacks used to wait for an event to fire.\n   * Used here for:\n   *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete\n   */\n  private readonly callbacks = new Map<string, CallbackTriple>();\n\n  private signalObserver: ISignalEventsObserver = {\n    onOffer: async (jsep: RTCSessionDescriptionInit) => {\n      try {\n        if (!this.subscribeConnection) {\n          return;\n        }\n        await this.subscribeConnection.setRemoteDescription(jsep);\n        HMSLogger.d(\n          TAG,\n          `[SUBSCRIBE] Adding ${this.subscribeConnection.candidates.length} ice-candidates`,\n          this.subscribeConnection.candidates,\n        );\n        for (const candidate of this.subscribeConnection.candidates) {\n          await this.subscribeConnection.addIceCandidate(candidate);\n        }\n        this.subscribeConnection.candidates.length = 0;\n        const answer = await this.subscribeConnection.createAnswer();\n        await this.subscribeConnection.setLocalDescription(answer);\n        this.signal.answer(answer);\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation DONE \u2705');\n      } catch (err) {\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation FAILED \u274C');\n        this.state = TransportState.Failed;\n        let ex: HMSException;\n        if (err instanceof HMSException) {\n          ex = err;\n        } else {\n          ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n        }\n\n        this.eventBus.analytics.publish(AnalyticsEventFactory.subscribeFail(ex));\n        throw ex;\n      }\n    },\n\n    onTrickle: async (trickle: HMSTrickle) => {\n      const connection =\n        trickle.target === HMSConnectionRole.Publish ? this.publishConnection : this.subscribeConnection;\n      if (!connection?.remoteDescription) {\n        // ICE candidates can't be added without any remote session description\n        connection?.candidates.push(trickle.candidate);\n      } else {\n        await connection.addIceCandidate(trickle.candidate);\n      }\n    },\n\n    onNotification: (message: any) => this.observer.onNotification(message),\n\n    onServerError: async (error: HMSException) => {\n      await this.observer.onStateChange(TransportState.Failed, error);\n    },\n\n    onFailure: (error: HMSException) => {\n      // @DISCUSS: Should we remove this? Pong failure would have already scheduled signal retry.\n      if (this.joinParameters) {\n        this.retryScheduler.schedule({\n          category: TransportFailureCategory.SignalDisconnect,\n          error,\n          task: this.retrySignalDisconnectTask,\n          originalState: this.state,\n        });\n      }\n    },\n\n    onOffline: async (reason: string) => {\n      HMSLogger.d(TAG, 'socket offline', TransportState[this.state]);\n      try {\n        if (this.state !== TransportState.Leaving && this.joinParameters) {\n          this.retryScheduler.schedule({\n            category: TransportFailureCategory.SignalDisconnect,\n            error: ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(HMSAction.RECONNECT_SIGNAL, reason),\n            task: this.retrySignalDisconnectTask,\n            originalState: this.state,\n          });\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    },\n\n    // this is called when socket connection is successful\n    onOnline: () => {\n      HMSLogger.d(TAG, 'socket online', TransportState[this.state]);\n      this.analyticsSignalTransport.flushFailedEvents(this.store.getLocalPeer()?.peerId);\n    },\n    // this is called when window.online event is triggered\n    onNetworkOnline: () => {\n      this.analyticsEventsService.flushFailedClientEvents();\n    },\n  };\n\n  private signal: ISignal = new JsonRpcSignal(this.signalObserver);\n  private analyticsSignalTransport = new SignalAnalyticsTransport(this.signal);\n\n  private publishConnectionObserver: IPublishConnectionObserver = {\n    onRenegotiationNeeded: async () => {\n      await this.performPublishRenegotiation();\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      HMSLogger.d('publisher ice connection state change, ', newState);\n\n      // @TODO: Uncomment this and remove connectionstatechange\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      HMSLogger.d('publisher connection state change, ', newState);\n\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n  };\n\n  private subscribeConnectionObserver: ISubscribeConnectionObserver = {\n    onApiChannelMessage: (message: string) => {\n      this.observer.onNotification(JSON.parse(message));\n    },\n\n    onTrackAdd: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackAdd', track);\n      this.observer.onTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackRemove', track);\n      this.observer.onTrackRemove(track);\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      HMSLogger.d('subscriber ice connection state change, ', newState);\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n\n      if (newState === 'connected') {\n        const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n        this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n        if (callback) {\n          callback.promise.resolve(true);\n        }\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      HMSLogger.d('subscriber connection state change, ', newState);\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n\n      if (newState === 'connected') {\n        const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n        this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n        if (callback) {\n          callback.promise.resolve(true);\n        }\n      }\n    },\n  };\n\n  async getLocalScreen(\n    videoSettings: HMSVideoTrackSettings,\n    audioSettings?: HMSAudioTrackSettings,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      return await this.localTrackManager.getLocalScreen(videoSettings, audioSettings);\n    } catch (error) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.publish({\n          error: error as Error,\n          devices: this.deviceManager.getDevices(),\n          settings: new HMSTrackSettings(videoSettings, audioSettings, false),\n        }),\n      );\n      throw error;\n    }\n  }\n\n  getWebrtcInternals() {\n    return this.webrtcInternals;\n  }\n\n  isFlagEnabled(flag: InitFlags) {\n    const config = this.initConfig?.config;\n    const flags = config?.enabledFlags || [];\n    return flags.includes(flag);\n  }\n\n  async preview(\n    token: string,\n    endpoint: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ): Promise<InitConfig | void> {\n    const initConfig = await this.connect(token, endpoint, peerId, customData, autoSubscribeVideo);\n    this.state = TransportState.Preview;\n    this.observer.onStateChange(this.state);\n    return initConfig;\n  }\n\n  async join(\n    authToken: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    initEndpoint: string,\n    autoSubscribeVideo = false,\n  ): Promise<void> {\n    HMSLogger.d(TAG, 'join: started \u23F0');\n    try {\n      if (!this.signal.isConnected || !this.initConfig) {\n        await this.connect(authToken, initEndpoint, peerId, customData, autoSubscribeVideo);\n      }\n\n      this.validateNotDisconnected('connect');\n\n      const isServerHandlingDegradation = this.isFlagEnabled(InitFlags.FLAG_SERVER_SUB_DEGRADATION);\n      if (this.initConfig) {\n        await this.waitForLocalRoleAvailability();\n        await this.createConnectionsAndNegotiateJoin(customData, autoSubscribeVideo, isServerHandlingDegradation);\n        await this.initRtcStatsMonitor();\n\n        HMSLogger.d(TAG, '\u2705 join: Negotiated over PUBLISH connection');\n      }\n    } catch (error) {\n      HMSLogger.e(TAG, `join: failed \u274C [token=${authToken}]`, error);\n      this.state = TransportState.Failed;\n      const ex = error as HMSException;\n      ex.isTerminal = ex.code === 500;\n      await this.observer.onStateChange(this.state, ex);\n      throw ex;\n    }\n\n    HMSLogger.i(TAG, '\u2705 join: successful');\n    this.state = TransportState.Joined;\n    this.observer.onStateChange(this.state);\n  }\n\n  async connect(\n    token: string,\n    endpoint: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ): Promise<InitConfig | void> {\n    this.setTransportStateForConnect();\n    this.joinParameters = new JoinParameters(\n      token,\n      peerId,\n      customData.name,\n      customData.metaData,\n      endpoint,\n      autoSubscribeVideo,\n    );\n    try {\n      const response = await this.internalConnect(token, endpoint, peerId);\n      return response;\n    } catch (error) {\n      const shouldRetry =\n        error instanceof HMSException &&\n        ([\n          ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n          ErrorCodes.WebSocketConnectionErrors.FAILED_TO_CONNECT,\n          ErrorCodes.InitAPIErrors.ENDPOINT_UNREACHABLE,\n        ].includes(error.code) ||\n          error.code.toString().startsWith('5') ||\n          error.code.toString().startsWith('429'));\n\n      if (shouldRetry) {\n        const task = async () => {\n          await this.internalConnect(token, endpoint, peerId);\n          return Boolean(this.initConfig && this.initConfig.endpoint);\n        };\n\n        await this.retryScheduler.schedule({\n          category: TransportFailureCategory.ConnectFailed,\n          error,\n          task,\n          originalState: this.state,\n          maxFailedRetries: MAX_TRANSPORT_RETRIES,\n          changeState: false,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async leave(): Promise<void> {\n    this.retryScheduler.reset();\n    this.joinParameters = undefined;\n    HMSLogger.d(TAG, 'leaving in transport');\n    try {\n      this.state = TransportState.Leaving;\n      this.webrtcInternals?.cleanUp();\n      this.trackDegradationController?.cleanUp();\n      await this.publishConnection?.close();\n      await this.subscribeConnection?.close();\n      try {\n        this.signal.leave();\n        HMSLogger.d(TAG, 'signal leave done');\n      } catch (err) {\n        HMSLogger.w(TAG, 'failed to send leave on websocket to server', err);\n      }\n      this.analyticsEventsService.flushFailedClientEvents();\n      this.analyticsEventsService.reset();\n      await this.signal.close();\n    } catch (err) {\n      this.eventBus.analytics.publish(AnalyticsEventFactory.disconnect(err as Error));\n      HMSLogger.e(TAG, 'leave: FAILED \u274C', err);\n    } finally {\n      this.state = TransportState.Disconnected;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  handleLocalRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const changedFromNonWebRTCToWebRTC = !this.doesRoleNeedWebRTC(oldRole) && this.doesRoleNeedWebRTC(newRole);\n    if (!changedFromNonWebRTCToWebRTC) {\n      return;\n    }\n\n    HMSLogger.i(\n      TAG,\n      'Local peer role updated to webrtc role, creating PeerConnections and performing inital publish negotiation \u23F3',\n    );\n    this.createPeerConnections();\n    await this.negotiateOnFirstPublish();\n  };\n\n  async publish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      try {\n        await this.publishTrack(track);\n      } catch (error) {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.publish({\n            devices: this.deviceManager.getDevices(),\n            error: error as Error,\n          }),\n        );\n      }\n    }\n  }\n\n  async unpublish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      await this.unpublishTrack(track);\n    }\n  }\n\n  async sendMessage(message: Message) {\n    return await this.signal.broadcast(message);\n  }\n\n  /**\n   * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and\n   * source. The hack won't work if there are multiple tracks with same source and type.\n   */\n  trackUpdate(track: HMSLocalTrack) {\n    const currentTrackStates = Array.from(this.trackStates.values());\n    const originalTrackState = currentTrackStates.find(\n      trackState => track.type === trackState.type && track.source === trackState.source,\n    );\n    if (originalTrackState) {\n      const newTrackState = new TrackState({\n        ...originalTrackState,\n        mute: !track.enabled,\n      });\n      this.trackStates.set(originalTrackState.track_id, newTrackState);\n      HMSLogger.d(TAG, 'Track Update', this.trackStates, track);\n      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));\n    }\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force = false) {\n    await this.signal.requestRoleChange({\n      requested_for: forPeer.peerId,\n      role: toRole,\n      force,\n    });\n  }\n\n  async acceptRoleChange(request: HMSRoleChangeRequest) {\n    await this.signal.acceptRoleChangeRequest({ role: request.role.name, token: request.token });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.signal.endRoom(lock, reason);\n  }\n\n  async removePeer(peerId: string, reason: string) {\n    await this.signal.removePeer({ requested_for: peerId, reason });\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    const signalParams: StartRTMPOrRecordingRequestParams = {\n      meeting_url: params.meetingURL,\n      record: params.record,\n    };\n\n    if (params.rtmpURLs?.length) {\n      signalParams.rtmp_urls = params.rtmpURLs;\n    }\n\n    if (params.resolution) {\n      signalParams.resolution = params.resolution;\n    }\n\n    await this.signal.startRTMPOrRecording(signalParams);\n  }\n\n  async stopRTMPOrRecording() {\n    await this.signal.stopRTMPAndRecording();\n  }\n\n  async startHLSStreaming(params?: HLSConfig) {\n    const hlsParams: HLSRequestParams = {};\n    if (params && params.variants && params.variants.length > 0) {\n      hlsParams.variants = params.variants.map(variant => {\n        const hlsVariant: HLSVariant = { meeting_url: variant.meetingURL };\n        if (variant.metadata) {\n          hlsVariant.metadata = variant.metadata;\n        }\n        return hlsVariant;\n      });\n    }\n    if (params?.recording) {\n      hlsParams.hls_recording = {\n        single_file_per_layer: params.recording.singleFilePerLayer,\n        hls_vod: params.recording.hlsVod,\n      };\n    }\n    await this.signal.startHLSStreaming(hlsParams);\n  }\n\n  async stopHLSStreaming(params?: HLSConfig) {\n    if (params) {\n      const hlsParams: HLSRequestParams = {\n        variants: params?.variants?.map(variant => {\n          const hlsVariant: HLSVariant = { meeting_url: variant.meetingURL };\n          if (variant.metadata) {\n            hlsVariant.metadata = variant.metadata;\n          }\n          return hlsVariant;\n        }),\n      };\n      await this.signal.stopHLSStreaming(hlsParams);\n    }\n    await this.signal.stopHLSStreaming();\n  }\n\n  async sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]) {\n    if (metadataList.length > 0) {\n      const hlsMtParams: HLSTimedMetadataParams = {\n        metadata_objs: metadataList,\n      };\n\n      await this.signal.sendHLSTimedMetadata(hlsMtParams);\n    }\n  }\n  async changeName(name: string) {\n    await this.signal.updatePeer({\n      name: name,\n    });\n  }\n\n  async changeMetadata(metadata: string) {\n    await this.signal.updatePeer({\n      data: metadata,\n    });\n  }\n\n  async changeTrackState(trackUpdateRequest: TrackUpdateRequestParams) {\n    await this.signal.requestTrackStateChange(trackUpdateRequest);\n  }\n\n  async changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams) {\n    await this.signal.requestMultiTrackStateChange(trackUpdateRequest);\n  }\n\n  private async publishTrack(track: HMSLocalTrack): Promise<void> {\n    track.publishedTrackId = track.getTrackIDBeingSent();\n    HMSLogger.d(TAG, `\u23F3 publishTrack: trackId=${track.trackId}, toPublishTrackId=${track.publishedTrackId}`, track);\n    this.trackStates.set(track.publishedTrackId, new TrackState(track));\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.PUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.setConnection(this.publishConnection!);\n    const simulcastLayers = this.store.getSimulcastLayers(track.source!);\n    stream.addTransceiver(track, simulcastLayers);\n    HMSLogger.time(`publish-${track.trackId}-${track.type}`);\n    await p;\n    HMSLogger.timeEnd(`publish-${track.trackId}-${track.type}`);\n    // add track to store after publish\n    this.store.addTrack(track);\n\n    // @ts-ignore\n    const maxBitrate = track.settings.maxBitrate;\n    if (maxBitrate) {\n      await stream\n        .setMaxBitrate(maxBitrate, track)\n        .then(() => {\n          HMSLogger.d(TAG, `Setting maxBitrate for ${track.source} ${track.type} to ${maxBitrate} kpbs`);\n        })\n        .catch(error => HMSLogger.e(TAG, 'Failed setting maxBitrate', error));\n    }\n\n    HMSLogger.d(TAG, `\u2705 publishTrack: trackId=${track.trackId}`, track, this.callbacks);\n  }\n\n  private async unpublishTrack(track: HMSLocalTrack): Promise<void> {\n    HMSLogger.d(TAG, `\u23F3 unpublishTrack: trackId=${track.trackId}`, track);\n    if (track.publishedTrackId && this.trackStates.has(track.publishedTrackId)) {\n      this.trackStates.delete(track.publishedTrackId);\n    } else {\n      // TODO: hotfix to unpublish replaced video track id, solve it properly\n      // it won't work when there are multiple regular video tracks, hmslocalvideotrack can store\n      // the original initial track id for a proper fix\n      const currentTrackStates = Array.from(this.trackStates.values());\n      const originalTrackState = currentTrackStates.find(\n        trackState => track.type === trackState.type && track.source === trackState.source,\n      );\n      if (originalTrackState) {\n        this.trackStates.delete(originalTrackState.track_id);\n      }\n    }\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.UNPUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.removeSender(track);\n    await p;\n    await track.cleanup();\n    // remove track from store on unpublish\n    this.store.removeTrack(track.trackId);\n    HMSLogger.d(TAG, `\u2705 unpublishTrack: trackId=${track.trackId}`, this.callbacks);\n  }\n\n  private waitForLocalRoleAvailability() {\n    if (this.store.hasRoleDetailsArrived()) {\n      return;\n    } else {\n      return new Promise<void>(resolve => {\n        this.eventBus.policyChange.subscribeOnce(() => resolve());\n      });\n    }\n  }\n\n  private async createConnectionsAndNegotiateJoin(\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n    isServerHandlingDegradation = true,\n  ) {\n    const isWebRTC = this.doesLocalPeerNeedWebRTC();\n    if (isWebRTC) {\n      this.createPeerConnections();\n    }\n\n    await this.negotiateJoinWithRetry({\n      name: customData.name,\n      data: customData.metaData,\n      autoSubscribeVideo,\n      serverSubDegrade: isServerHandlingDegradation,\n      isWebRTC,\n    });\n  }\n\n  private createPeerConnections() {\n    if (this.initConfig) {\n      if (!this.publishConnection) {\n        this.publishConnection = new HMSPublishConnection(\n          this.signal,\n          this.initConfig.rtcConfiguration,\n          this.publishConnectionObserver,\n          this,\n        );\n      }\n\n      if (!this.subscribeConnection) {\n        this.subscribeConnection = new HMSSubscribeConnection(\n          this.signal,\n          this.initConfig.rtcConfiguration,\n          this.subscribeConnectionObserver,\n        );\n      }\n    }\n  }\n\n  private async negotiateJoinWithRetry({\n    name,\n    data,\n    autoSubscribeVideo,\n    serverSubDegrade,\n    isWebRTC = true,\n  }: NegotiateJoinParams & { isWebRTC: boolean }) {\n    try {\n      await this.negotiateJoin({ name, data, autoSubscribeVideo, serverSubDegrade, isWebRTC });\n    } catch (error) {\n      HMSLogger.e(TAG, 'Join negotiation failed \u274C', error);\n      const hmsError =\n        error instanceof HMSException\n          ? error\n          : ErrorFactory.WebsocketMethodErrors.ServerErrors(\n              500,\n              HMSAction.JOIN,\n              `Websocket join error - ${(error as Error).message}`,\n            );\n      const shouldRetry = parseInt(`${hmsError.code / 100}`) === 5 || hmsError.code === 429;\n\n      if (shouldRetry) {\n        this.joinRetryCount = 0;\n        hmsError.isTerminal = false;\n        const task = async () => {\n          this.joinRetryCount++;\n          return await this.negotiateJoin({ name, data, autoSubscribeVideo, serverSubDegrade, isWebRTC });\n        };\n\n        await this.retryScheduler.schedule({\n          category: TransportFailureCategory.JoinWSMessageFailed,\n          error: hmsError,\n          task,\n          originalState: TransportState.Joined,\n          maxFailedRetries: 3,\n          changeState: false,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private async negotiateJoin({\n    name,\n    data,\n    autoSubscribeVideo,\n    serverSubDegrade,\n    isWebRTC = true,\n  }: NegotiateJoinParams & { isWebRTC: boolean }): Promise<boolean> {\n    if (isWebRTC) {\n      return await this.negotiateJoinWebRTC({ name, data, autoSubscribeVideo, serverSubDegrade });\n    } else {\n      return await this.negotiateJoinNonWebRTC({ name, data, autoSubscribeVideo, serverSubDegrade });\n    }\n  }\n\n  private async negotiateJoinWebRTC({\n    name,\n    data,\n    autoSubscribeVideo,\n    serverSubDegrade,\n  }: NegotiateJoinParams): Promise<boolean> {\n    HMSLogger.d(TAG, '\u23F3 join: Negotiating over PUBLISH connection');\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot negotiate');\n      return false;\n    }\n    const offer = await this.publishConnection.createOffer();\n    await this.publishConnection.setLocalDescription(offer);\n    const answer = await this.signal.join(name, data, !autoSubscribeVideo, serverSubDegrade, offer);\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n\n    this.publishConnection.initAfterJoin();\n    return !!answer;\n  }\n\n  private async negotiateJoinNonWebRTC({\n    name,\n    data,\n    autoSubscribeVideo,\n    serverSubDegrade,\n  }: NegotiateJoinParams): Promise<boolean> {\n    HMSLogger.d(TAG, '\u23F3 join: Negotiating Non-WebRTC');\n    const response = await this.signal.join(name, data, !autoSubscribeVideo, serverSubDegrade);\n    return !!response;\n  }\n\n  /**\n   * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer\n   */\n  private async negotiateOnFirstPublish() {\n    HMSLogger.d(TAG, '\u23F3 Negotiating offer over PUBLISH connection');\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot negotiate');\n      return false;\n    }\n    const offer = await this.publishConnection.createOffer(this.trackStates);\n    await this.publishConnection.setLocalDescription(offer);\n    const answer = await this.signal.offer(offer, this.trackStates);\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n\n    this.publishConnection.initAfterJoin();\n    return !!answer;\n  }\n\n  private async performPublishRenegotiation(constraints?: RTCOfferOptions) {\n    HMSLogger.d(TAG, `\u23F3 [role=PUBLISH] onRenegotiationNeeded START`, this.trackStates);\n    const callback = this.callbacks.get(RENEGOTIATION_CALLBACK_ID);\n    if (!callback) {\n      return;\n    }\n\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot renegotiate');\n      return;\n    }\n\n    try {\n      const offer = await this.publishConnection.createOffer(this.trackStates, constraints);\n      await this.publishConnection.setLocalDescription(offer);\n      HMSLogger.time(`renegotiation-offer-exchange`);\n      const answer = await this.signal.offer(offer, this.trackStates);\n      this.callbacks.delete(RENEGOTIATION_CALLBACK_ID);\n      HMSLogger.timeEnd(`renegotiation-offer-exchange`);\n      await this.publishConnection.setRemoteDescription(answer);\n      callback.promise.resolve(true);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded DONE \u2705`);\n    } catch (err) {\n      let ex: HMSException;\n      if (err instanceof HMSException) {\n        ex = err;\n      } else {\n        ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n      }\n\n      callback!.promise.reject(ex);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded FAILED \u274C`);\n    }\n  }\n\n  private async handleIceConnectionFailure(role: HMSConnectionRole) {\n    if (role === HMSConnectionRole.Publish) {\n      this.retryScheduler.schedule({\n        category: TransportFailureCategory.PublishIceConnectionFailed,\n        error: ErrorFactory.WebrtcErrors.ICEFailure(HMSAction.PUBLISH),\n        task: this.retryPublishIceFailedTask,\n        originalState: TransportState.Joined,\n      });\n    } else {\n      this.retryScheduler.schedule({\n        category: TransportFailureCategory.SubscribeIceConnectionFailed,\n        error: ErrorFactory.WebrtcErrors.ICEFailure(HMSAction.SUBSCRIBE),\n        task: this.retrySubscribeIceFailedTask,\n        originalState: TransportState.Joined,\n        maxFailedRetries: 1,\n      });\n    }\n  }\n\n  private async internalConnect(token: string, endpoint: string, peerId: string) {\n    HMSLogger.d(TAG, 'connect: started \u23F0');\n    const connectRequestedAt = new Date();\n    try {\n      this.analyticsTimer.start(TimedEvent.INIT);\n      this.initConfig = await InitService.fetchInitConfig(token, peerId, endpoint);\n      this.analyticsTimer.end(TimedEvent.INIT);\n      // if leave was called while init was going on, don't open websocket\n      this.validateNotDisconnected('post init');\n      await this.openSignal(token, peerId);\n      HMSLogger.d(TAG, 'Adding Analytics Transport: JsonRpcSignal');\n      this.analyticsEventsService.setTransport(this.analyticsSignalTransport);\n      this.analyticsEventsService.flush();\n      return this.initConfig;\n    } catch (error) {\n      if (this.state !== TransportState.Reconnecting) {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.connect(\n            error as Error,\n            this.getAdditionalAnalyticsProperties(),\n            connectRequestedAt,\n            new Date(),\n            endpoint,\n          ),\n        );\n      }\n      HMSLogger.d(TAG, '\u274C internal connect: failed', error);\n      throw error;\n    }\n  }\n\n  // leave could be called between any two async tasks, which would make\n  // the state disconnected instead of connecting, throw error for those cases.\n  private validateNotDisconnected(stage: string) {\n    if (this.state === TransportState.Disconnected) {\n      HMSLogger.w(TAG, 'aborting join as transport state is disconnected');\n      throw ErrorFactory.GenericErrors.ValidationFailed(`leave called before join could complete - stage=${stage}`);\n    }\n  }\n\n  private async openSignal(token: string, peerId: string) {\n    if (!this.initConfig) {\n      throw ErrorFactory.InitAPIErrors.InitConfigNotAvailable(HMSAction.INIT, 'Init Config not found');\n    }\n\n    HMSLogger.d(TAG, '\u23F3 internal connect: connecting to ws endpoint', this.initConfig.endpoint);\n    const url = new URL(this.initConfig.endpoint);\n    url.searchParams.set('peer', peerId);\n    url.searchParams.set('token', token);\n    url.searchParams.set('user_agent', userAgent);\n    this.endpoint = url.toString();\n    this.analyticsTimer.start(TimedEvent.WEBSOCKET_CONNECT);\n    await this.signal.open(this.endpoint);\n    this.analyticsTimer.end(TimedEvent.WEBSOCKET_CONNECT);\n    this.analyticsTimer.start(TimedEvent.ON_POLICY_CHANGE);\n    HMSLogger.d(TAG, '\u2705 internal connect: connected to ws endpoint');\n  }\n\n  private async initRtcStatsMonitor() {\n    this.webrtcInternals?.setPeerConnections({\n      publish: this.publishConnection?.nativeConnection,\n      subscribe: this.subscribeConnection?.nativeConnection,\n    });\n\n    // TODO: when server-side subscribe degradation is released, we can remove check on the client-side\n    //  as server will check in policy if subscribe degradation enabled from dashboard\n    if (this.store.getSubscribeDegradationParams()) {\n      if (!this.isFlagEnabled(InitFlags.FLAG_SERVER_SUB_DEGRADATION)) {\n        await this.webrtcInternals?.start();\n        this.trackDegradationController = new TrackDegradationController(this.store, this.eventBus);\n        this.eventBus.statsUpdate.subscribe(stats => {\n          this.trackDegradationController?.handleRtcStatsChange(stats.getLocalPeerStats()?.subscribe?.packetsLost || 0);\n        });\n      }\n\n      this.eventBus.trackDegraded.subscribe(track => {\n        this.eventBus.analytics.publish(AnalyticsEventFactory.degradationStats(track, true));\n        this.observer.onTrackDegrade(track);\n      });\n      this.eventBus.trackRestored.subscribe(track => {\n        this.eventBus.analytics.publish(AnalyticsEventFactory.degradationStats(track, false));\n        this.observer.onTrackRestore(track);\n      });\n    }\n  }\n\n  /**\n   * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything\n   * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role\n   */\n  private doesRoleNeedWebRTC(role: HMSRole) {\n    if (!this.isFlagEnabled(InitFlags.FLAG_NON_WEBRTC_DISABLE_OFFER)) {\n      return true;\n    }\n\n    const isPublishing = Boolean(role.publishParams.allowed && role.publishParams.allowed?.length > 0);\n    const isSubscribing = Boolean(\n      role.subscribeParams.subscribeToRoles && role.subscribeParams.subscribeToRoles?.length > 0,\n    );\n\n    return isPublishing || isSubscribing;\n  }\n\n  private doesLocalPeerNeedWebRTC() {\n    const localRole = this.store.getLocalPeer()?.role;\n    if (!localRole) {\n      return true;\n    }\n\n    return this.doesRoleNeedWebRTC(localRole);\n  }\n\n  private retryPublishIceFailedTask = async () => {\n    if (\n      this.publishConnection &&\n      (this.publishConnection.iceConnectionState !== 'connected' ||\n        this.publishConnection.connectionState !== 'connected')\n    ) {\n      const p = new Promise<boolean>((resolve, reject) => {\n        this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n      await this.performPublishRenegotiation({ iceRestart: true });\n      await p;\n    }\n\n    return true;\n  };\n\n  private retrySubscribeIceFailedTask = async () => {\n    if (\n      this.subscribeConnection &&\n      (this.subscribeConnection.iceConnectionState !== 'connected' ||\n        this.subscribeConnection.connectionState !== 'connected')\n    ) {\n      const p = new Promise<boolean>((resolve, reject) => {\n        // Use subscribe constant string\n        this.callbacks.set(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n\n      const timeout = new Promise(resolve => {\n        setTimeout(resolve, SUBSCRIBE_TIMEOUT, false);\n      });\n\n      return Promise.race([p, timeout]) as Promise<boolean>;\n    }\n\n    return true;\n  };\n\n  private retrySignalDisconnectTask = async () => {\n    HMSLogger.d(TAG, 'retrySignalDisconnectTask', { signalConnected: this.signal.isConnected });\n    // Check if ws is disconnected - otherwise if only publishIce fails\n    // and ws connect is success then we don't need to reconnect to WebSocket\n    if (!this.signal.isConnected) {\n      try {\n        await this.internalConnect(\n          this.joinParameters!.authToken,\n          this.joinParameters!.endpoint,\n          this.joinParameters!.peerId,\n        );\n      } catch (ex) {}\n    }\n\n    // Only retry publish failed task after joining the call - not needed in preview signal reconnect\n    const ok = this.store.getRoom().joinedAt\n      ? this.signal.isConnected && (await this.retryPublishIceFailedTask())\n      : this.signal.isConnected;\n    // Send track update to sync local track state changes during reconnection\n    this.signal.trackUpdate(this.trackStates);\n\n    return ok;\n  };\n\n  private setTransportStateForConnect() {\n    if (this.state === TransportState.Failed) {\n      this.state = TransportState.Disconnected;\n    }\n\n    if (this.state !== TransportState.Disconnected && this.state !== TransportState.Reconnecting) {\n      throw ErrorFactory.WebsocketMethodErrors.AlreadyJoined(\n        HMSAction.JOIN,\n        `Cannot join a meeting in ${this.state} state`,\n      );\n    }\n\n    if (this.state === TransportState.Disconnected) {\n      this.state = TransportState.Connecting;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  private sendErrorAnalyticsEvent(error: HMSException, category: TransportFailureCategory) {\n    const additionalProps = this.getAdditionalAnalyticsProperties();\n    let event: AnalyticsEvent;\n    switch (category) {\n      case TransportFailureCategory.ConnectFailed:\n        event = AnalyticsEventFactory.connect(error, additionalProps);\n        break;\n      case TransportFailureCategory.SignalDisconnect:\n        event = AnalyticsEventFactory.disconnect(error, additionalProps);\n        break;\n      case TransportFailureCategory.JoinWSMessageFailed:\n        event = AnalyticsEventFactory.join({\n          error,\n          time: this.analyticsTimer.getTimeTaken(TimedEvent.JOIN),\n          init_response_time: this.analyticsTimer.getTimeTaken(TimedEvent.INIT),\n          ws_connect_time: this.analyticsTimer.getTimeTaken(TimedEvent.WEBSOCKET_CONNECT),\n          on_policy_change_time: this.analyticsTimer.getTimeTaken(TimedEvent.ON_POLICY_CHANGE),\n          local_tracks_time: this.analyticsTimer.getTimeTaken(TimedEvent.LOCAL_TRACKS),\n          retries_join: this.joinRetryCount,\n        });\n        break;\n      case TransportFailureCategory.PublishIceConnectionFailed:\n        event = AnalyticsEventFactory.publish({ error });\n        break;\n      case TransportFailureCategory.SubscribeIceConnectionFailed:\n        event = AnalyticsEventFactory.subscribeFail(error);\n        break;\n    }\n    this.eventBus.analytics.publish(event!);\n  }\n\n  getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties {\n    const network_info = getNetworkInfo();\n    const document_hidden = typeof document !== 'undefined' && document.hidden;\n    const num_degraded_tracks = this.store.getRemoteVideoTracks().filter(track => track.degraded).length;\n    const publishBitrate = this.getWebrtcInternals()?.getCurrentStats()?.getLocalPeerStats()?.publish?.bitrate;\n    const subscribeBitrate = this.getWebrtcInternals()?.getCurrentStats()?.getLocalPeerStats()?.subscribe?.bitrate;\n\n    return {\n      network_info,\n      document_hidden,\n      num_degraded_tracks,\n      bitrate: {\n        publish: publishBitrate,\n        subscribe: subscribeBitrate,\n      },\n      max_sub_bitrate: this.maxSubscribeBitrate,\n      recent_pong_response_times: this.signal.getPongResponseTimes(),\n      transport_state: this.state,\n    };\n  }\n}\n", "import { ErrorFactory, HMSAction } from '../error/ErrorFactory';\n\nexport interface AuthToken {\n  roomId: string;\n  userId: string;\n  role: string;\n}\n\nexport default function decodeJWT(token: string): AuthToken {\n  if (token.length === 0) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(HMSAction.INIT, 'Token cannot be an empty string');\n  }\n\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `Expected 3 '.' separate fields - header, payload and signature respectively`,\n    );\n  }\n\n  const payloadStr = atob(parts[1]);\n  try {\n    const payload = JSON.parse(payloadStr);\n    return {\n      roomId: payload.room_id,\n      userId: payload.user_id,\n      role: payload.role,\n    } as AuthToken;\n  } catch (err) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `couldn't parse to json - ${(err as Error).message}`,\n    );\n  }\n}\n", "import { HMSHLS, HMSRecording, HMSRoom, HMSRoomType, HMSRTMP } from '../../interfaces/room';\nimport { IStore } from '../store/IStore';\n\nexport default class Room implements HMSRoom {\n  shareableLink!: string;\n  type!: HMSRoomType;\n  hasWaitingRoom!: boolean;\n  sessionId?: string;\n  startedAt?: Date;\n  recording: HMSRecording = { server: { running: false }, browser: { running: false }, hls: { running: false } };\n  rtmp: HMSRTMP = { running: false };\n  hls: HMSHLS = { running: false, variants: [] };\n  name?: string;\n  peerCount?: number;\n\n  public get localPeer() {\n    return this.store.getLocalPeer()!;\n  }\n\n  public get peers() {\n    return this.store.getPeers();\n  }\n\n  constructor(public id: string, private store: IStore) {}\n}\n", "import { v4 as uuid } from 'uuid';\nimport { HMSRemoteAudioTrack } from '../media/tracks';\nimport { DeviceManager } from '../device-manager';\nimport HMSLogger from '../utils/logger';\nimport { IStore } from '../sdk/store';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { HMSDeviceChangeEvent, HMSUpdateListener, HMSTrackUpdate } from '../interfaces';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { isMobile } from '../utils/support';\nimport { EventBus } from '../events/EventBus';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\n\n/**\n * Following are the errors thrown when autoplay is blocked in different browsers\n * Firefox - DOMException: The play method is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.\n * Safari - NotAllowedError: The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.\n * Chrome - DOMException: play() failed because the user didn't interact with the document first.\n * Brave - DOMException: play() can only be initiated by a user gesture.\n */\ntype AudioSinkState = {\n  autoplayFailed?: boolean;\n  initialized: boolean;\n  // this promise will be set for the first track. remaining tracks will be processed once it's know whether\n  // autoplay is allowed or not\n  autoplayCheckPromise?: Promise<void>;\n};\n\nconst INITIAL_STATE: AudioSinkState = {\n  autoplayFailed: undefined,\n  initialized: false,\n  autoplayCheckPromise: undefined,\n};\n\nexport class AudioSinkManager {\n  private audioSink?: HTMLElement;\n  private autoPausedTracks: Set<HMSRemoteAudioTrack> = new Set();\n  private TAG = '[AudioSinkManager]:';\n  private volume = 100;\n  private state = { ...INITIAL_STATE };\n  private listener?: HMSUpdateListener;\n\n  constructor(private store: IStore, private deviceManager: DeviceManager, private eventBus: EventBus) {\n    this.eventBus.audioTrackAdded.subscribe(this.handleTrackAdd);\n    this.eventBus.audioTrackRemoved.subscribe(this.handleTrackRemove);\n    this.eventBus.audioTrackUpdate.subscribe(this.handleTrackUpdate);\n    this.eventBus.deviceChange.subscribe(this.handleAudioDeviceChange);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n  }\n\n  private get outputDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  getVolume() {\n    return this.volume;\n  }\n\n  setVolume(value: number) {\n    this.store.updateAudioOutputVolume(value);\n    this.volume = value;\n  }\n\n  /**\n   *  This function is to be called only on user interaction when\n   *  autoplay error is received.\n   */\n  async unblockAutoplay() {\n    if (this.autoPausedTracks.size > 0) {\n      this.unpauseAudioTracks();\n    }\n  }\n\n  init(elementId?: string) {\n    if (this.state.initialized) {\n      return;\n    }\n    this.state.initialized = true;\n    const audioSink = document.createElement('div');\n    audioSink.id = `HMS-SDK-audio-sink-${uuid()}`;\n    const userElement = elementId && document.getElementById(elementId);\n    const audioSinkParent = userElement || document.body;\n    audioSinkParent.append(audioSink);\n\n    this.audioSink = audioSink;\n  }\n\n  cleanUp() {\n    this.audioSink?.remove();\n    this.audioSink = undefined;\n    this.eventBus.audioTrackAdded.unsubscribe(this.handleTrackAdd);\n    this.eventBus.audioTrackRemoved.unsubscribe(this.handleTrackRemove);\n    this.eventBus.audioTrackUpdate.unsubscribe(this.handleTrackUpdate);\n    this.eventBus.deviceChange.unsubscribe(this.handleAudioDeviceChange);\n    this.autoPausedTracks = new Set();\n    this.state = { ...INITIAL_STATE };\n  }\n\n  private handleAudioPaused = (event: any) => {\n    const audioEl = event.target as HTMLAudioElement;\n    //@ts-ignore\n    const track = audioEl.srcObject?.getAudioTracks()[0];\n    if (!track?.enabled) {\n      // No need to play if already disabled\n      return;\n    }\n    // this means the audio paused because of external factors(headset removal)\n    HMSLogger.d(this.TAG, 'Audio Paused', event.target.id);\n    const audioTrack = this.store.getTrackById(event.target.id);\n    if (audioTrack) {\n      if (isMobile()) {\n        // Play after a delay since mobile devices don't call onDevice change event\n        setTimeout(async () => {\n          if (audioTrack) {\n            await this.playAudioFor(audioTrack as HMSRemoteAudioTrack);\n          }\n        }, 500);\n      } else {\n        this.autoPausedTracks.add(audioTrack as HMSRemoteAudioTrack);\n      }\n    }\n  };\n\n  private handleTrackUpdate = ({ track, enabled }: { track: HMSRemoteAudioTrack; enabled: boolean }) => {\n    // @ts-ignore\n    if (window.HMS?.AUDIO_SINK) {\n      if (enabled) {\n        track.addSink();\n        this.playAudioFor(track);\n      } else {\n        track.removeSink();\n      }\n    }\n  };\n\n  private handleTrackAdd = async ({ track, peer }: { track: HMSRemoteAudioTrack; peer: HMSRemotePeer }) => {\n    const audioEl = document.createElement('audio');\n    audioEl.style.display = 'none';\n    audioEl.id = track.trackId;\n    audioEl.addEventListener('pause', this.handleAudioPaused);\n\n    track.setAudioElement(audioEl);\n    track.setVolume(this.volume);\n    HMSLogger.d(this.TAG, 'Audio track added', track.trackId);\n    this.audioSink?.append(audioEl);\n    this.outputDevice && (await track.setOutputDevice(this.outputDevice));\n    // @ts-ignore\n    if (window.HMS?.AUDIO_SINK) {\n      // No need to play if track is not enabled\n      track.enabled ? track.addSink() : track.removeSink();\n    } else {\n      audioEl.srcObject = new MediaStream([track.nativeTrack]);\n    }\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, peer);\n    await this.handleAutoplayError(track);\n  };\n\n  private handleAutoplayError = async (track: HMSRemoteAudioTrack) => {\n    /**\n     * if it's not known whether autoplay will succeed, wait for it to be known\n     */\n    if (this.state.autoplayFailed === undefined) {\n      if (!this.state.autoplayCheckPromise) {\n        // it's the first track, try to play it, that'll tell us whether autoplay is allowed\n        this.state.autoplayCheckPromise = new Promise<void>(resolve => {\n          this.playAudioFor(track).then(resolve);\n        });\n      }\n      // and wait for the result to be known\n      await this.state.autoplayCheckPromise;\n    }\n    /**\n     * Don't play the track if autoplay failed, add to paused list\n     */\n    if (this.state.autoplayFailed) {\n      this.autoPausedTracks.add(track);\n      return;\n    }\n    await this.playAudioFor(track);\n  };\n\n  private handleAudioDeviceChange = (event: HMSDeviceChangeEvent) => {\n    // if there is no selection that means this is an init request. No need to do anything\n    if (event.error || !event.selection || event.type === 'video') {\n      return;\n    }\n    this.unpauseAudioTracks();\n  };\n\n  /**\n   * try to play audio for the passed in track, assume autoplay error happened if play fails\n   * @param track\n   * @private\n   */\n  private async playAudioFor(track: HMSRemoteAudioTrack) {\n    const audioEl = track.getAudioElement();\n    if (!audioEl) {\n      HMSLogger.w(this.TAG, 'No audio element found on track', track.trackId);\n      return;\n    }\n    try {\n      await audioEl.play();\n      this.state.autoplayFailed = false;\n      this.autoPausedTracks.delete(track);\n      HMSLogger.d(this.TAG, 'Played track', track.trackId);\n    } catch (err) {\n      this.autoPausedTracks.add(track);\n      HMSLogger.e(this.TAG, 'Failed to play track', track.trackId, err as Error);\n      const error = err as Error;\n      if (!this.state.autoplayFailed && error.name === 'NotAllowedError') {\n        this.state.autoplayFailed = true;\n        const ex = ErrorFactory.TracksErrors.AutoplayBlocked(HMSAction.AUTOPLAY, '');\n        ex.addNativeError(error);\n        this.eventBus.analytics.publish(AnalyticsEventFactory.autoplayError());\n        this.eventBus.autoplayError.publish(ex);\n      }\n    }\n  }\n\n  private handleTrackRemove = (track: HMSRemoteAudioTrack) => {\n    this.autoPausedTracks.delete(track);\n    const audioEl = document.getElementById(track.trackId) as HTMLAudioElement;\n    if (audioEl) {\n      audioEl.removeEventListener('pause', this.handleAudioPaused);\n      audioEl.srcObject = null;\n      audioEl.remove();\n      track.setAudioElement(null);\n    }\n    // Reset autoplay error thrown because if all tracks are removed and a new track is added\n    // Autoplay error is thrown in safari\n    if (this.audioSink && this.audioSink.childElementCount === 0) {\n      this.state.autoplayCheckPromise = undefined;\n      this.state.autoplayFailed = undefined;\n    }\n    HMSLogger.d(this.TAG, 'Audio track removed', track.trackId);\n  };\n\n  private unpauseAudioTracks = async () => {\n    const promises: Promise<void>[] = [];\n    this.autoPausedTracks.forEach(track => {\n      promises.push(this.playAudioFor(track));\n    });\n    // Return after all pending tracks are played\n    await Promise.all(promises);\n  };\n}\n", "import type { DeviceMap } from '../interfaces/HMSDeviceManager';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { HMSAudioTrackSettingsBuilder, HMSVideoTrackSettingsBuilder } from '../media/settings';\nimport { HMSDeviceChangeEvent } from '../interfaces';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { DeviceStorageManager } from './DeviceStorage';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\n\nexport type SelectedDevices = {\n  audioInput?: MediaDeviceInfo;\n  videoInput?: MediaDeviceInfo;\n  audioOutput?: MediaDeviceInfo;\n};\n\ntype DeviceAndGroup = Partial<MediaTrackSettings>;\n\ninterface HMSDeviceManager extends DeviceMap {\n  outputDevice?: MediaDeviceInfo;\n  hasWebcamPermission: boolean;\n  hasMicrophonePermission: boolean;\n}\n\nexport class DeviceManager implements HMSDeviceManager {\n  audioInput: MediaDeviceInfo[] = [];\n  audioOutput: MediaDeviceInfo[] = [];\n  videoInput: MediaDeviceInfo[] = [];\n  outputDevice?: MediaDeviceInfo;\n  // true if user has allowed the permission\n  // false if user has denied the permission or prompt was never shown or ignored\n  // or if the camera/mic is not available in the device\n  hasWebcamPermission = false;\n  hasMicrophonePermission = false;\n\n  private TAG = '[Device Manager]:';\n  private initialized = false;\n  private videoInputChanged = false;\n  private audioInputChanged = false;\n\n  constructor(private store: IStore, private eventBus: EventBus) {\n    const isLocalTrackEnabled = ({ enabled, track }: { enabled: boolean; track: HMSLocalTrack }) =>\n      enabled && track.source === 'regular';\n    this.eventBus.localVideoEnabled.waitFor(isLocalTrackEnabled).then(async () => {\n      await this.enumerateDevices();\n      if (this.videoInputChanged) {\n        this.eventBus.deviceChange.publish({ devices: this.getDevices() } as HMSDeviceChangeEvent);\n      }\n    });\n    this.eventBus.localAudioEnabled.waitFor(isLocalTrackEnabled).then(async () => {\n      await this.enumerateDevices();\n      if (this.audioInputChanged) {\n        this.eventBus.deviceChange.publish({ devices: this.getDevices() } as HMSDeviceChangeEvent);\n      }\n    });\n  }\n\n  updateOutputDevice = (deviceId?: string) => {\n    const newDevice = this.audioOutput.find(device => device.deviceId === deviceId);\n    if (newDevice) {\n      this.outputDevice = newDevice;\n      this.store.updateAudioOutputDevice(newDevice);\n      DeviceStorageManager.updateSelection('audioOutput', { deviceId: newDevice.deviceId, groupId: newDevice.groupId });\n    }\n    return newDevice;\n  };\n\n  async init(force = false) {\n    if (this.initialized && !force) {\n      return;\n    }\n    !this.initialized && navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);\n    this.initialized = true;\n    await this.enumerateDevices();\n    this.logDevices('Init');\n    this.setOutputDevice();\n    this.eventBus.deviceChange.publish({\n      devices: this.getDevices(),\n    } as HMSDeviceChangeEvent);\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.deviceChange({\n        selection: this.getCurrentSelection(),\n        type: 'list',\n        devices: this.getDevices(),\n      }),\n    );\n  }\n\n  getDevices(): DeviceMap {\n    return {\n      audioInput: this.audioInput,\n      audioOutput: this.audioOutput,\n      videoInput: this.videoInput,\n    };\n  }\n\n  cleanUp() {\n    this.initialized = false;\n    this.audioInput = [];\n    this.audioOutput = [];\n    this.videoInput = [];\n    this.outputDevice = undefined;\n    navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);\n  }\n\n  getCurrentSelection = (): SelectedDevices => {\n    const localPeer = this.store.getLocalPeer();\n    const audioDevice = this.createIdentifier(localPeer?.audioTrack?.getMediaTrackSettings());\n    const videoDevice = this.createIdentifier(localPeer?.videoTrack?.getMediaTrackSettings());\n    const audioSelection = this.audioInput.find(device => {\n      const id = this.createIdentifier(device);\n      return id === audioDevice;\n    });\n    const videoSelection = this.videoInput.find(device => this.createIdentifier(device) === videoDevice);\n    return {\n      audioInput: audioSelection,\n      videoInput: videoSelection,\n      audioOutput: this.outputDevice,\n    };\n  };\n\n  private createIdentifier(deviceInfo?: DeviceAndGroup) {\n    if (!deviceInfo) {\n      return '';\n    }\n    return `${deviceInfo.deviceId}${deviceInfo.groupId}`;\n  }\n\n  private computeChange = (prevDevices: string[], currentDevices: MediaDeviceInfo[]) => {\n    if (prevDevices.length !== currentDevices.length) {\n      return true;\n    }\n    return currentDevices.some(device => !prevDevices.includes(this.createIdentifier(device)));\n  };\n\n  private enumerateDevices = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const prevVideoInput = this.videoInput.map(this.createIdentifier);\n      const prevAudioInput = this.audioInput.map(this.createIdentifier);\n      this.audioInput = [];\n      this.audioOutput = [];\n      this.videoInput = [];\n      devices.forEach(device => {\n        if (device.kind === 'audioinput' && device.label) {\n          this.hasMicrophonePermission = true;\n          this.audioInput.push(device as MediaDeviceInfo);\n        } else if (device.kind === 'audiooutput') {\n          this.audioOutput.push(device);\n        } else if (device.kind === 'videoinput' && device.label) {\n          this.hasWebcamPermission = true;\n          this.videoInput.push(device as MediaDeviceInfo);\n        }\n      });\n      this.videoInputChanged = this.computeChange(prevVideoInput, this.videoInput);\n      this.audioInputChanged = this.computeChange(prevAudioInput, this.audioInput);\n      DeviceStorageManager.setDevices({\n        videoInput: [...this.videoInput],\n        audioInput: [...this.audioInput],\n        audioOutput: [...this.audioOutput],\n      });\n      this.logDevices('Enumerate Devices');\n    } catch (error) {\n      HMSLogger.e(this.TAG, 'Failed enumerating devices', error);\n    }\n  };\n\n  private handleDeviceChange = async () => {\n    await this.enumerateDevices();\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.deviceChange({\n        selection: this.getCurrentSelection(),\n        type: 'list',\n        devices: this.getDevices(),\n      }),\n    );\n    this.logDevices('After Device Change');\n    const localPeer = this.store.getLocalPeer();\n    this.setOutputDevice(true);\n    await this.handleAudioInputDeviceChange(localPeer?.audioTrack);\n    await this.handleVideoInputDeviceChange(localPeer?.videoTrack);\n  };\n\n  /**\n   * Function to get the device after device change\n   * Chrome and Edge provide a default device from which we select the actual device\n   * Firefox and safari give 0th device as system default\n   * @returns {MediaDeviceInfo}\n   */\n  getNewAudioInputDevice() {\n    const defaultDevice = this.audioInput.find(device => device.deviceId === 'default');\n    if (defaultDevice) {\n      // Selecting a non-default device so that the deviceId comparision does not give\n      // false positives when device is removed, because the other available device\n      // get's the deviceId as default once this device is removed\n      const nextDevice = this.audioInput.find(device => {\n        return device.label !== defaultDevice.label && defaultDevice.label.includes(device.label);\n      });\n      return nextDevice;\n    }\n    return this.audioInput[0];\n  }\n\n  /**\n   * This method is to select the input/output from same group\n   * same group meaning both input/output are of same device\n   * This method might override the default coming from browser and system so as to select options from same\n   * device type. This is required in certain cases where browser's default is not correct.\n   * Algo:\n   * 1. find the non default input device if selected one is default by matching device label\n   * 2. find the corresponding output device which has the same group id or same label\n   * 3. select the default one if nothing was found\n   * 4. select the first option if there is no default\n   */\n  setOutputDevice(deviceChange = false) {\n    const inputDevice = this.getNewAudioInputDevice();\n    const prevSelection = this.createIdentifier(this.outputDevice);\n    this.outputDevice = undefined;\n    if (inputDevice?.groupId) {\n      // only check for label because if groupId check is added it will select speaker\n      // when an external earphone without microphone is added\n      this.outputDevice = this.audioOutput.find(\n        device => inputDevice.deviceId !== 'default' && device.label === inputDevice.label,\n      );\n    }\n    if (!this.outputDevice) {\n      // select default deviceId device if available, otherwise select 0th device\n      this.outputDevice = this.audioOutput.find(device => device.deviceId === 'default') || this.audioOutput[0];\n    }\n    this.store.updateAudioOutputDevice(this.outputDevice);\n    // send event only on device change and device is not same as previous\n    if (deviceChange && prevSelection !== this.createIdentifier(this.outputDevice)) {\n      this.eventBus.deviceChange.publish({\n        selection: this.outputDevice,\n        type: 'audioOutput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  }\n\n  private handleAudioInputDeviceChange = async (audioTrack?: HMSLocalAudioTrack) => {\n    if (!audioTrack) {\n      HMSLogger.d(this.TAG, 'No Audio track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.audioInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in AudioInput Device');\n      return;\n    }\n    const newSelection = this.getNewAudioInputDevice();\n    if (!newSelection || !newSelection.deviceId) {\n      HMSLogger.w(this.TAG, 'Audio device not found');\n      return;\n    }\n    const { settings } = audioTrack;\n    const newAudioTrackSettings = new HMSAudioTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await audioTrack.setSettings(newAudioTrackSettings, true);\n      this.eventBus.deviceChange.publish({\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'audioInput',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Audio Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Audio Device Change]', error);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioInput: newSelection },\n          devices: this.getDevices(),\n          error: error as HMSException,\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        error,\n        selection: newSelection,\n        type: 'audioInput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private handleVideoInputDeviceChange = async (videoTrack?: HMSLocalVideoTrack) => {\n    if (!videoTrack) {\n      HMSLogger.d(this.TAG, 'No video track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.videoInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in VideoInput Device');\n      return;\n    }\n    const newSelection = this.videoInput[0];\n    if (!newSelection || !newSelection.deviceId) {\n      HMSLogger.w(this.TAG, 'Video device not found');\n      return;\n    }\n    const { settings } = videoTrack;\n    const newVideoTrackSettings = new HMSVideoTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .maxFramerate(settings.maxFramerate)\n      .setWidth(settings.width)\n      .setHeight(settings.height)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await (videoTrack as HMSLocalVideoTrack).setSettings(newVideoTrackSettings, true);\n      // On replace track, enabled will be true. Need to be set to previous state\n      // videoTrack.setEnabled(enabled); // TODO: remove this once verified on qa.\n      this.eventBus.deviceChange.publish({\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'video',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Video Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Video Device Change]', error);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { videoInput: newSelection },\n          devices: this.getDevices(),\n          error: error as HMSException,\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        error: error as Error,\n        type: 'video',\n        selection: newSelection,\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private logDevices(label = '') {\n    HMSLogger.d(\n      this.TAG,\n      label,\n      JSON.stringify(\n        {\n          videoInput: [...this.videoInput],\n          audioInput: [...this.audioInput],\n          audioOutput: [...this.audioOutput],\n          selected: this.getCurrentSelection(),\n        },\n        null,\n        4,\n      ),\n    );\n  }\n}\n", "import { AudioSinkManager } from '../audio-sink-manager';\nimport { DeviceManager } from '.';\n\nexport interface IAudioOutputManager {\n  getDevice(): MediaDeviceInfo | undefined;\n  setDevice(deviceId: string): MediaDeviceInfo | undefined;\n  getVolume(): number;\n  setVolume(value: number): void;\n}\n\nexport class AudioOutputManager implements IAudioOutputManager {\n  constructor(private deviceManager: DeviceManager, private audioSinkManager: AudioSinkManager) {}\n\n  getVolume() {\n    return this.audioSinkManager.getVolume();\n  }\n\n  setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    this.audioSinkManager.setVolume(value);\n  }\n\n  getDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  setDevice(deviceId?: string) {\n    return this.deviceManager.updateOutputDevice(deviceId);\n  }\n\n  async unblockAutoplay() {\n    await this.audioSinkManager.unblockAutoplay();\n  }\n}\n", "import { HMSAnalyticsLevel } from './AnalyticsEventLevel';\nimport { ANALYTICS_BUFFER_SIZE } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsTransport } from './AnalyticsTransport';\nimport { IStore } from '../sdk/store';\nimport { HTTPAnalyticsTransport } from './HTTPAnalyticsTransport';\n\nconst TAG = 'AnalyticsEventsService';\n\nexport class AnalyticsEventsService {\n  private bufferSize = ANALYTICS_BUFFER_SIZE;\n\n  private transport: AnalyticsTransport | null = null;\n  private pendingEvents: AnalyticsEvent[] = [];\n\n  level: HMSAnalyticsLevel = HMSAnalyticsLevel.INFO;\n\n  constructor(private store: IStore) {}\n\n  setTransport(transport: AnalyticsTransport) {\n    this.transport = transport;\n  }\n\n  reset() {\n    this.transport = null;\n    this.pendingEvents = [];\n  }\n\n  queue(event: AnalyticsEvent) {\n    if (event.level >= this.level) {\n      this.pendingEvents.push(event);\n\n      if (this.pendingEvents.length > this.bufferSize) {\n        const removedEvent = this.pendingEvents.shift();\n        HMSLogger.d(TAG, 'Max buffer size reached', 'Removed event to accommodate new events', removedEvent);\n      }\n    }\n    return this;\n  }\n\n  flushFailedClientEvents() {\n    HTTPAnalyticsTransport.flushFailedEvents();\n  }\n\n  // eslint-disable-next-line complexity\n  flush() {\n    try {\n      while (this.pendingEvents.length > 0) {\n        const event = this.pendingEvents.shift();\n        if (event) {\n          event.metadata.peer.peer_id = this.store.getLocalPeer()?.peerId;\n          if (this.transport && this.transport.transportProvider.isConnected) {\n            this.transport.sendEvent(event);\n          } else {\n            this.sendClientEventOnHTTP(event);\n          }\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(TAG, 'Flush Failed', error);\n    }\n  }\n\n  private sendClientEventOnHTTP(event: AnalyticsEvent) {\n    const room = this.store.getRoom();\n    const localPeer = this.store.getLocalPeer();\n    event.metadata.token = this.store.getConfig()?.authToken;\n    event.metadata.peer = {\n      session_id: room.sessionId,\n      room_id: room.id,\n      room_name: room.name,\n      template_id: room.templateId,\n      joined_at: room.joinedAt?.getTime(),\n      session_started_at: room.startedAt?.getTime(),\n      role: localPeer?.role?.name,\n      user_name: localPeer?.name,\n      user_data: localPeer?.metadata,\n    };\n    HTTPAnalyticsTransport.sendEvent(event);\n  }\n}\n", "import { HMSTrack } from '../..';\nimport { HMSTrackType } from '../../media/tracks';\nimport { HMSPeer } from '../models/peer';\nimport { IStore } from './IStore';\n\n/**\n * Function passed as argument to the sort method of the list.\n * @returns a negative value if first argument is less than second argument, zero if they're equal and a positive value otherwise\n *\n * @see Array.sort\n */\ntype ComparatorFn<T> = (a: T, b: T) => number;\n\ninterface PeerComparators {\n  videoEnabled: ComparatorFn<HMSPeer>;\n  audioEnabled: ComparatorFn<HMSPeer>;\n  screenShare: ComparatorFn<HMSPeer>;\n  audioLevel: ComparatorFn<HMSPeer | undefined>;\n  rolePriority: ComparatorFn<HMSPeer>;\n}\n\ninterface TrackComparators {\n  video: ComparatorFn<HMSTrack>;\n  audio: ComparatorFn<HMSTrack>;\n  enabled: ComparatorFn<HMSTrack>;\n  audioLevel: ComparatorFn<HMSTrack>;\n  peerAudioLevel: ComparatorFn<HMSTrack>;\n  screenShare: ComparatorFn<HMSTrack>;\n  rolePriority: ComparatorFn<HMSTrack>;\n}\n\ninterface IComparator {\n  getPeerComparators: () => PeerComparators;\n  getTrackComparators: () => TrackComparators;\n}\n\n/**\n * Used to sort list of items(peers/tracks) based on common use cases.\n * Usage: peerList.sort(comparator.getPeerComparators().audioLevel);\n */\nexport class Comparator implements IComparator {\n  constructor(private readonly store: IStore) {}\n\n  getPeerComparators(): PeerComparators {\n    return {\n      videoEnabled: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<boolean>(Boolean(peerA.videoTrack?.enabled), Boolean(peerB.videoTrack?.enabled)),\n\n      audioEnabled: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<boolean>(Boolean(peerA.audioTrack?.enabled), Boolean(peerB.audioTrack?.enabled)),\n\n      screenShare: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<boolean>(\n          peerA.auxiliaryTracks.some(track => track.source === 'screen'),\n          peerB.auxiliaryTracks.some(track => track.source === 'screen'),\n        ),\n\n      audioLevel: (peerA?: HMSPeer, peerB?: HMSPeer) =>\n        this.primitiveComparator<number>(\n          this.store.getSpeakers().find(speaker => speaker.peer && speaker.peer.peerId === peerA?.peerId)?.audioLevel ||\n            -1,\n          this.store.getSpeakers().find(speaker => speaker.peer && speaker.peer.peerId === peerB?.peerId)?.audioLevel ||\n            -1,\n        ),\n\n      rolePriority: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<number>(peerA.role?.priority || 0, peerB.role?.priority || 0),\n    };\n  }\n\n  getTrackComparators(): TrackComparators {\n    return {\n      video: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<boolean>(trackA.type === HMSTrackType.VIDEO, trackB.type === HMSTrackType.VIDEO),\n\n      audio: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<boolean>(trackA.type === HMSTrackType.AUDIO, trackB.type === HMSTrackType.AUDIO),\n\n      enabled: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<boolean>(Boolean(trackA.enabled), Boolean(trackB.enabled)),\n\n      peerAudioLevel: (trackA: HMSTrack, trackB: HMSTrack) => {\n        const peerA = this.store.getPeerByTrackId(trackA.trackId);\n        const peerB = this.store.getPeerByTrackId(trackB.trackId);\n        return this.getPeerComparators().audioLevel(peerA, peerB);\n      },\n\n      /**\n       * Only HMSAudioTracks comparable as speaker objects have only HMSAudioTracks\n       */\n      audioLevel: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<number>(\n          this.store.getSpeakers().find(speaker => speaker.track.trackId === trackA.trackId)?.audioLevel || 0,\n          this.store.getSpeakers().find(speaker => speaker.track.trackId === trackB.trackId)?.audioLevel || 0,\n        ),\n\n      screenShare: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator(trackA.source === 'screen', trackB.source === 'screen'),\n\n      rolePriority: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<number>(\n          this.store.getPeerByTrackId(trackA.trackId)?.role?.priority || 0,\n          this.store.getPeerByTrackId(trackB.trackId)?.role?.priority || 0,\n        ),\n    };\n  }\n\n  /**\n   * @returns a negative value if a is less than b, zero if they're equal and a positive value otherwise\n   */\n  primitiveComparator = <T>(a: T, b: T): number => {\n    return a === b ? 0 : Number(a) - Number(b);\n  };\n\n  stringComparator = (a: string, b: string) => (a === b ? 0 : a < b ? -1 : 1);\n}\n", "import { ENV, IStore, KnownRoles, TrackStateEntry } from './IStore';\nimport HMSRoom from '../models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from '../models/peer';\nimport { HMSSpeaker } from '../../interfaces';\nimport { IErrorListener } from '../../interfaces/error-listener';\nimport {\n  HMSTrack,\n  HMSVideoTrack,\n  HMSAudioTrack,\n  HMSTrackType,\n  HMSTrackSource,\n  HMSRemoteVideoTrack,\n  HMSLocalTrack,\n} from '../../media/tracks';\nimport {\n  SimulcastLayer,\n  SimulcastLayers,\n  SimulcastDimensions,\n  simulcastMapping,\n  RID,\n  SimulcastLayerDefinition,\n} from '../../interfaces/simulcast-layers';\nimport { Comparator } from './Comparator';\nimport { HMSConfig, PublishParams } from '../../interfaces';\nimport { SelectedDevices } from '../../device-manager';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HTTPAnalyticsTransport } from '../../analytics/HTTPAnalyticsTransport';\n\nclass Store implements IStore {\n  private readonly comparator: Comparator = new Comparator(this);\n  private room?: HMSRoom;\n  private knownRoles: KnownRoles = {};\n  private localPeerId?: string;\n  private peers: Record<string, HMSPeer> = {};\n  private tracks: Record<string, HMSTrack> = {};\n  // Not used currently. Will be used exclusively for preview tracks.\n  // private previewTracks: Record<string, HMSTrack> = {};\n  private peerTrackStates: Record<string, TrackStateEntry> = {};\n  private speakers: HMSSpeaker[] = [];\n  private videoLayers: SimulcastLayers | null = null;\n  private screenshareLayers: SimulcastLayers | null = null;\n  private config?: HMSConfig;\n  private publishParams?: PublishParams;\n  private errorListener?: IErrorListener;\n  private roleDetailsArrived = false;\n  private env: ENV = ENV.PROD;\n\n  getConfig() {\n    return this.config;\n  }\n\n  getEnv() {\n    return this.env;\n  }\n\n  getPublishParams() {\n    return this.publishParams;\n  }\n\n  getComparator() {\n    return this.comparator;\n  }\n\n  getRoom() {\n    return this.room!;\n  }\n\n  getPolicyForRole(role: string) {\n    return this.knownRoles[role];\n  }\n\n  getKnownRoles() {\n    return this.knownRoles;\n  }\n\n  getLocalPeer() {\n    if (this.localPeerId && this.peers[this.localPeerId]) {\n      return this.peers[this.localPeerId] as HMSLocalPeer;\n    }\n    return undefined;\n  }\n\n  getRemotePeers() {\n    return Object.values(this.peers).filter(peer => !peer.isLocal) as HMSRemotePeer[];\n  }\n\n  getPeers(): HMSPeer[] {\n    return Object.values(this.peers);\n  }\n\n  getPeerById(peerId: string) {\n    if (this.peers[peerId]) {\n      return this.peers[peerId];\n    }\n    return undefined;\n  }\n\n  getTracksMap() {\n    return this.tracks;\n  }\n\n  getTracks() {\n    return Object.values(this.tracks);\n  }\n\n  getVideoTracks() {\n    return this.getTracks().filter(track => track.type === HMSTrackType.VIDEO) as HMSVideoTrack[];\n  }\n\n  getRemoteVideoTracks() {\n    return this.getTracks().filter(track => track instanceof HMSRemoteVideoTrack) as HMSRemoteVideoTrack[];\n  }\n\n  getAudioTracks() {\n    return this.getTracks().filter(track => track.type === HMSTrackType.AUDIO) as HMSAudioTrack[];\n  }\n\n  getPeerTracks(peerId?: string) {\n    const peer = peerId ? this.peers[peerId] : undefined;\n    const tracks: HMSTrack[] = [];\n    peer?.videoTrack && tracks.push(peer.videoTrack);\n    peer?.audioTrack && tracks.push(peer.audioTrack);\n    return tracks.concat(peer?.auxiliaryTracks || []);\n  }\n\n  getLocalPeerTracks() {\n    return this.getPeerTracks(this.localPeerId) as HMSLocalTrack[];\n  }\n\n  getTrackById(trackId: string) {\n    const track = this.tracks[trackId];\n    if (track) {\n      return track;\n    }\n    const localPeer = this.getLocalPeer();\n    /**\n     * handle case of audio level coming from server for local peer's track where local peer\n     * didn't initially gave audio permission. So track.firstTrackId is that of dummy track and\n     * this.tracks[trackId] doesn't exist.\n     * Example repro which this solves -\n     * - call preview with audio muted, unmute audio in preview then join the room, now initial\n     * track id is that from dummy track but the track id which server knows will be different\n     */\n    if (localPeer) {\n      if (localPeer.audioTrack?.isPublishedTrackId(trackId)) {\n        return localPeer.audioTrack;\n      } else if (localPeer.videoTrack?.isPublishedTrackId(trackId)) {\n        return localPeer.videoTrack;\n      }\n    }\n    return undefined;\n  }\n\n  getPeerByTrackId(trackId: string) {\n    const track = this.tracks[trackId];\n    return track.peerId ? this.peers[track.peerId] : undefined;\n  }\n\n  getSpeakers() {\n    return this.speakers;\n  }\n\n  getSpeakerPeers() {\n    return this.speakers.map(speaker => speaker.peer);\n  }\n\n  setRoom(room: HMSRoom) {\n    this.room = room;\n  }\n\n  setKnownRoles(knownRoles: KnownRoles) {\n    this.knownRoles = knownRoles;\n    this.roleDetailsArrived = true;\n    this.updatePeersPolicy();\n  }\n\n  hasRoleDetailsArrived(): boolean {\n    return this.roleDetailsArrived;\n  }\n\n  // eslint-disable-next-line complexity\n  setConfig(config: HMSConfig) {\n    DeviceStorageManager.rememberDevices(Boolean(config.rememberDeviceSelection));\n    if (config.rememberDeviceSelection) {\n      const devices: SelectedDevices | undefined = DeviceStorageManager.getSelection();\n      if (devices) {\n        if (!config.settings) {\n          config.settings = {};\n        }\n        if (devices.audioInput?.deviceId) {\n          config.settings.audioInputDeviceId = config.settings.audioInputDeviceId || devices.audioInput.deviceId;\n        }\n        if (devices.audioOutput?.deviceId) {\n          config.settings.audioOutputDeviceId = config.settings.audioOutputDeviceId || devices.audioOutput.deviceId;\n        }\n        if (devices.videoInput?.deviceId) {\n          config.settings.videoDeviceId = config.settings.videoDeviceId || devices.videoInput.deviceId;\n        }\n      }\n    }\n    this.config = config;\n    this.setEnv();\n  }\n\n  setPublishParams(params: PublishParams) {\n    this.publishParams = params;\n  }\n\n  addPeer(peer: HMSPeer) {\n    this.peers[peer.peerId] = peer;\n    if (peer.isLocal) {\n      this.localPeerId = peer.peerId;\n    }\n  }\n\n  /**\n   * @param {HMSTrack} track the published track that has to be added\n   *\n   * Note: Only use this method to add published tracks not preview traks\n   */\n  addTrack(track: HMSTrack) {\n    this.tracks[track.trackId] = track;\n  }\n\n  getTrackState(trackId: string) {\n    return this.peerTrackStates[trackId];\n  }\n\n  setTrackState(trackStateEntry: TrackStateEntry) {\n    this.peerTrackStates[trackStateEntry.trackInfo.track_id] = trackStateEntry;\n  }\n\n  removePeer(peerId: string) {\n    if (this.localPeerId === peerId) {\n      this.localPeerId = undefined;\n    }\n    delete this.peers[peerId];\n  }\n\n  removeTrack(trackId: string) {\n    delete this.tracks[trackId];\n  }\n\n  updateSpeakers(speakers: HMSSpeaker[]) {\n    this.speakers = speakers;\n  }\n\n  updateAudioOutputVolume(value: number) {\n    this.getAudioTracks().forEach(track => track.setVolume(value));\n  }\n\n  updateAudioOutputDevice(device: MediaDeviceInfo) {\n    this.getAudioTracks().forEach(track => {\n      track.setOutputDevice(device);\n    });\n  }\n\n  getSubscribeDegradationParams() {\n    const params = this.getLocalPeer()?.role?.subscribeParams.subscribeDegradation;\n    if (params && Object.keys(params).length > 0) {\n      return params;\n    }\n    return undefined;\n  }\n\n  getSimulcastLayers(source: HMSTrackSource): SimulcastLayer[] {\n    if (source === 'screen') {\n      return this.screenshareLayers?.layers || [];\n    }\n    return this.videoLayers?.layers || [];\n  }\n\n  getSimulcastDimensions(source: HMSTrackSource): SimulcastDimensions {\n    const layers = source === 'screen' ? this.screenshareLayers : this.videoLayers;\n    const width = layers?.width;\n    const height = layers?.height;\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Convert maxBitrate from kbps to bps\n   * @internal\n   * @param simulcastLayers\n   * @returns {SimulcastLayers}\n   */\n  private convertSimulcastLayers(simulcastLayers: SimulcastLayers) {\n    return {\n      ...simulcastLayers,\n      layers: (simulcastLayers.layers || []).map(layer => {\n        return {\n          ...layer,\n          maxBitrate: layer.maxBitrate * 1000,\n        };\n      }),\n    };\n  }\n\n  setVideoSimulcastLayers(simulcastLayers: SimulcastLayers): void {\n    this.videoLayers = this.convertSimulcastLayers(simulcastLayers);\n  }\n\n  setScreenshareSimulcastLayers(simulcastLayers: SimulcastLayers): void {\n    this.screenshareLayers = this.convertSimulcastLayers(simulcastLayers);\n  }\n\n  getSimulcastDefinitionsForPeer(peer: HMSPeer, source: HMSTrackSource) {\n    if (!peer.role) {\n      return [];\n    }\n\n    const publishParams = this.getPolicyForRole(peer.role.name).publishParams;\n    let simulcastLayers: SimulcastLayers | undefined;\n    if (source === 'regular') {\n      simulcastLayers = publishParams.videoSimulcastLayers;\n    } else if (source === 'screen') {\n      simulcastLayers = publishParams.screenSimulcastLayers;\n    }\n    const width = simulcastLayers?.width;\n    const height = simulcastLayers?.height;\n    return (\n      simulcastLayers?.layers?.map(value => {\n        const layer = simulcastMapping[value.rid as RID];\n        const resolution = {\n          width: width && value.scaleResolutionDownBy ? width / value.scaleResolutionDownBy : undefined,\n          height: height && value.scaleResolutionDownBy ? height / value.scaleResolutionDownBy : undefined,\n        };\n        return {\n          layer,\n          resolution,\n        } as SimulcastLayerDefinition;\n      }) || []\n    );\n  }\n\n  cleanUp() {\n    const tracks = this.getTracks();\n    for (const track of tracks) {\n      track.cleanup();\n    }\n    this.room = undefined;\n    this.config = undefined;\n    this.localPeerId = undefined;\n    this.roleDetailsArrived = false;\n  }\n\n  setErrorListener(listener: IErrorListener) {\n    this.errorListener = listener;\n  }\n\n  private updatePeersPolicy() {\n    this.getPeers().forEach(peer => {\n      if (!peer.role) {\n        this.errorListener?.onError(ErrorFactory.GenericErrors.InvalidRole(HMSAction.VALIDATION, ''));\n        return;\n      }\n      peer.role = this.getPolicyForRole(peer.role.name);\n    });\n  }\n\n  private setEnv() {\n    const endPoint = this.config?.initEndpoint!;\n    const url = endPoint.split('https://')[1];\n    let env: ENV = ENV.PROD;\n    if (url.startsWith(ENV.PROD)) {\n      env = ENV.PROD;\n    } else if (url.startsWith(ENV.QA)) {\n      env = ENV.QA;\n    } else if (url.startsWith(ENV.DEV)) {\n      env = ENV.DEV;\n    }\n    this.env = env;\n    HTTPAnalyticsTransport.setEnv(env);\n  }\n}\n\nexport { Store };\n", "import { HMSRole } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport { HMSLocalTrack } from '../media/tracks';\nimport ITransport from '../transport/ITransport';\nimport { IStore } from './store';\n\nexport type PublishConfig = {\n  publishAudio?: boolean;\n  publishVideo?: boolean;\n};\n\nexport default class RoleChangeManager {\n  constructor(\n    private store: IStore,\n    private transport: ITransport,\n    private publish: (settings: InitialSettings, publishConfig?: PublishConfig) => void,\n    private removeAuxiliaryTrack: (trackId: string) => void,\n    private listener?: HMSUpdateListener,\n  ) {}\n\n  public handleLocalPeerRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const localPeer = this.store.getLocalPeer();\n\n    if (!localPeer) {\n      return;\n    }\n\n    const wasPublishing = new Set(oldRole.publishParams.allowed || []);\n    const isPublishing = new Set(newRole.publishParams.allowed || []);\n\n    const removeVideo = this.removeTrack(wasPublishing, isPublishing, 'video');\n    const removeAudio = this.removeTrack(wasPublishing, isPublishing, 'audio');\n    const removeScreen = this.removeTrack(wasPublishing, isPublishing, 'screen');\n\n    await this.removeVideoTracks(removeVideo);\n    await this.removeAudioTrack(removeAudio);\n    await this.removeScreenTracks(removeScreen);\n    this.store.setPublishParams(newRole.publishParams);\n\n    const initialSettings = this.store.getConfig()?.settings || {\n      isAudioMuted: true,\n      isVideoMuted: true,\n      audioInputDeviceId: 'default',\n      videoDeviceId: 'default',\n      audioOutputDeviceId: 'default',\n    };\n    // call publish with new settings, local track manager will diff policies\n    await this.publish({ ...initialSettings, isAudioMuted: true, isVideoMuted: true });\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, localPeer);\n  };\n\n  private async removeVideoTracks(removeVideo: boolean) {\n    if (!removeVideo) {\n      return;\n    }\n    const localPeer = this.store.getLocalPeer();\n    // TODO check auxillary tracks for regular audio and video too\n    if (localPeer?.videoTrack) {\n      // TODO: stop processed track and cleanup plugins loop non async\n      // vb can throw change role off otherwise\n      await this.transport.unpublish([localPeer.videoTrack]);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, localPeer.videoTrack, localPeer);\n      localPeer.videoTrack = undefined;\n    }\n    await this.removeAuxTracks(track => track.source !== 'screen' && track.type === 'video');\n  }\n\n  private async removeAudioTrack(removeAudio: boolean) {\n    if (!removeAudio) {\n      return;\n    }\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.audioTrack) {\n      await this.transport.unpublish([localPeer.audioTrack]);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, localPeer.audioTrack, localPeer);\n      localPeer.audioTrack = undefined;\n    }\n    await this.removeAuxTracks(track => track.source !== 'screen' && track.type === 'audio');\n  }\n\n  private async removeScreenTracks(removeScreen: boolean) {\n    if (!removeScreen) {\n      return;\n    }\n    await this.removeAuxTracks(track => track.source === 'screen');\n  }\n\n  private async removeAuxTracks(predicate: (track: HMSLocalTrack) => boolean) {\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.auxiliaryTracks) {\n      const localAuxTracks = [...localPeer.auxiliaryTracks];\n      for (const track of localAuxTracks) {\n        if (predicate(track)) {\n          await this.removeAuxiliaryTrack(track.trackId);\n        }\n      }\n    }\n  }\n\n  private removeTrack(wasPublishing: Set<string>, isPublishing: Set<string>, type: string) {\n    return wasPublishing.has(type) && !isPublishing.has(type);\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\n\n/**\n * Typed Event Emitter Reference:\n * https://rjzaworski.com/2019/10/event-emitters-in-typescript#a-typescript-event-emitter-interface\n */\n\nexport type EventMap = Record<string, any>;\n\nexport type EventKey<T extends EventMap> = string & keyof T;\nexport type EventReceiver<T> = (params: T) => void;\n\n// interface Emitter<T extends EventMap> {\n//   on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n// }\n\nexport abstract class TypedEventEmitter<T extends EventMap> extends EventEmitter {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.on(eventName, fn);\n  }\n\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.off(eventName, fn);\n  }\n\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]) {\n    return super.emit(eventName, params);\n  }\n\n  listeners<K extends EventKey<T>>(eventName: K): EventReceiver<T[K]>[] {\n    return super.listeners(eventName) as EventReceiver<T[K]>[];\n  }\n}\n", "import HMSLogger from '../utils/logger';\n\nexport class AudioContextManager {\n  private audioContext: AudioContext;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private source: MediaElementAudioSourceNode;\n\n  constructor(element: HTMLMediaElement) {\n    this.audioContext = new AudioContext();\n    this.source = this.audioContext.createMediaElementSource(element);\n    this.source.connect(this.audioContext.destination);\n  }\n\n  /**\n   * Resume AudioContext if it is suspended\n   * Note: when the browser tab is muted by default, AudioContext will be in suspended state\n   * It has to be resumed for the video/audio to be played.\n   */\n  resumeContext() {\n    if (this.audioContext.state === 'suspended') {\n      HMSLogger.d(this.TAG, 'AudioContext is resumed');\n      this.audioContext.resume();\n    }\n  }\n\n  getAudioTrack() {\n    // Always create a destinationNode to get new audio track id\n    if (this.destinationNode) {\n      this.source.disconnect(this.destinationNode);\n    }\n    this.destinationNode = this.audioContext.createMediaStreamDestination();\n    this.source.connect(this.destinationNode);\n    return this.destinationNode.stream.getAudioTracks()[0];\n  }\n\n  cleanup() {\n    if (this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n    }\n  }\n\n  private get TAG() {\n    return 'AudioContextManager';\n  }\n}\n", "import HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { AudioContextManager } from './AudioContextManager';\n\n/**\n * This class handles audio playlist management\n * - An audio element and audio context which processes audio from audio element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the audio element created in the constructor\n *  - oncanplaythrough event of the audio element\n *    - resume the audio context if it is suspended\n *    - play the audio element\n *    - Get audio track from the audio context manager\n *    - The track is passed to playlist manager to publish\n */\nexport class PlaylistAudioManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private audioElement: HTMLAudioElement | null = null;\n  private track?: MediaStreamTrack;\n  private audioContextManager!: AudioContextManager;\n  // This is to handle audio playing when seekTo is called when audio is paused\n  private seeked = false;\n\n  async play(url: string) {\n    this.audioElement = this.getAudioElement();\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.audioElement = this.getAudioElement();\n      this.audioElement.src = url;\n      this.seeked = false;\n      this.audioElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user seeks jumps to any mid track timestamp\n      this.audioElement.oncanplaythrough = async () => {\n        try {\n          if (!this.audioElement) {\n            return;\n          }\n          this.audioContextManager.resumeContext();\n          // Create audio track only once and reuse, it will be updated with current content\n          if (!this.track) {\n            await this.audioElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            this.track = audioTrack;\n            resolve([audioTrack]);\n          } else {\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.audioElement.play();\n              resolve([this.track]);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing audio', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.audioElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.track ? [this.track.id] : [];\n  }\n\n  getElement() {\n    return this.audioElement;\n  }\n\n  stop() {\n    this.audioElement?.pause();\n    this.audioElement?.removeAttribute('src');\n    this.audioElement = null;\n    this.audioContextManager?.cleanup();\n    this.track = undefined;\n  }\n\n  private getAudioElement() {\n    if (this.audioElement) {\n      return this.audioElement;\n    }\n    const audioElement = document.createElement('audio');\n    audioElement.crossOrigin = 'anonymous';\n    audioElement.addEventListener('timeupdate', event => this.emit('progress', event));\n    audioElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(audioElement);\n    return audioElement;\n  }\n\n  private get TAG() {\n    return 'PlaylistAudioManager';\n  }\n}\n", "import HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { AudioContextManager } from './AudioContextManager';\n\n/**\n * This class handles video playlist management\n * - An video element, canvas and audio context which processes audio from video element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the video element created in the constructor\n *  - oncanplaythrough event of the video element\n *    - resume the audio context if it is suspended\n *    - set width/height on canvas\n *    - captureStream on canvas element if not already captured\n *    - play the video element\n *    - on video element is played, it is drawn to canvas\n *    - Get audio track from the audio context manager\n *    - add audioTrack to canvas stream\n *    - The audio and video tracks are passed to playlist manager to publish\n */\nexport class PlaylistVideoManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private videoElement: HTMLVideoElement | null = null;\n  private canvasContext: CanvasRenderingContext2D | null = null;\n  private canvas!: HTMLCanvasElement;\n  private timer: any;\n  private tracks: MediaStreamTrack[] = [];\n  private audioContextManager!: AudioContextManager;\n  private DEFAUL_FPS = 24;\n  // This is to handle video playing when seekTo is called when video is paused\n  private seeked = false;\n\n  play(url: string) {\n    this.videoElement = this.getVideoElement();\n    this.createCanvas();\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.videoElement = this.getVideoElement();\n      this.videoElement.src = url;\n      this.seeked = false;\n      this.videoElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user jumps to any mid track timestamp using seekTo\n      this.videoElement.oncanplaythrough = async () => {\n        try {\n          if (!this.videoElement) {\n            return;\n          }\n          this.canvas.width = this.videoElement.videoWidth;\n          this.canvas.height = this.videoElement.videoHeight;\n          // Capture stream only once and reuse the same tracks. it will be autoupdated with the selected video\n          if (this.tracks.length === 0) {\n            this.clearCanvasAndTracks();\n            //@ts-ignore\n            const stream = this.canvas.captureStream();\n            if (!stream) {\n              HMSLogger.e(this.TAG, 'Browser does not support captureStream');\n              return;\n            }\n            this.videoElement.onplay = this.drawImage;\n            this.audioContextManager.resumeContext();\n            await this.videoElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            stream.addTrack(audioTrack);\n            stream.getTracks().forEach((track: MediaStreamTrack) => {\n              this.tracks.push(track);\n            });\n            resolve(this.tracks);\n          } else {\n            // No need to capture canvas stream/get audio track. They wull be auto updated\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.videoElement.play();\n              resolve(this.tracks);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n              // This event will be called on seekTo when paused. Just draw the one frame on canvas.\n              this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing video', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.videoElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.tracks.map(track => track.id);\n  }\n\n  getElement() {\n    return this.videoElement;\n  }\n\n  stop() {\n    this.videoElement?.pause();\n    this.videoElement?.removeAttribute('src');\n    this.videoElement = null;\n    this.audioContextManager?.cleanup();\n    this.clearCanvasAndTracks();\n  }\n\n  private clearCanvasAndTracks() {\n    this.tracks = [];\n    // clear canvas before playing new video\n    this.canvasContext?.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    clearTimeout(this.timer);\n  }\n\n  private drawImage = () => {\n    if (this.videoElement && !this.videoElement.paused && !this.videoElement.ended) {\n      this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n      this.timer = setTimeout(() => {\n        this.drawImage();\n      }, 1000 / this.DEFAUL_FPS);\n    }\n  };\n\n  private getVideoElement() {\n    if (this.videoElement) {\n      return this.videoElement;\n    }\n    const videoElement = document.createElement('video');\n    videoElement.crossOrigin = 'anonymous';\n    videoElement.addEventListener('timeupdate', event => this.emit('progress', event));\n    videoElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(videoElement);\n    return videoElement;\n  }\n\n  private createCanvas() {\n    if (!this.canvas) {\n      this.canvas = document.createElement('canvas');\n      this.canvasContext = this.canvas.getContext('2d');\n    }\n  }\n\n  private get TAG() {\n    return 'PlaylistVideoManager';\n  }\n}\n", "import { HMSSdk } from '../sdk';\nimport { HMSPlaylistItem, HMSPlaylistType, HMSPlaylistManager, HMSPlaylistProgressEvent } from '../interfaces';\nimport { PlaylistAudioManager } from './PlaylistAudioManager';\nimport { PlaylistVideoManager } from './PlaylistVideoManager';\nimport HMSLogger from '../utils/logger';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { EventBus } from '../events/EventBus';\nimport { HMSLocalTrack } from '../media/tracks';\n\ntype PlaylistManagerState<T> = {\n  audio: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n    isAutoplayOn: boolean;\n  };\n  video: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n    isAutoplayOn: boolean;\n  };\n};\n\nconst INITIAL_STATE: PlaylistManagerState<any> = {\n  audio: {\n    list: [],\n    currentIndex: -1,\n    isAutoplayOn: true,\n  },\n  video: {\n    list: [],\n    currentIndex: -1,\n    isAutoplayOn: true,\n  },\n};\n\nexport class PlaylistManager\n  extends TypedEventEmitter<{\n    newTrackStart: HMSPlaylistItem<any>;\n    playlistEnded: HMSPlaylistType;\n    currentTrackEnded: HMSPlaylistItem<any>;\n  }>\n  implements HMSPlaylistManager\n{\n  private state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n  private audioManager: PlaylistAudioManager;\n  private videoManager: PlaylistVideoManager;\n\n  constructor(private sdk: HMSSdk, private eventBus: EventBus) {\n    super();\n    this.audioManager = new PlaylistAudioManager();\n    this.videoManager = new PlaylistVideoManager();\n    this.addListeners();\n  }\n\n  getList<T>(type: HMSPlaylistType = HMSPlaylistType.audio): HMSPlaylistItem<T>[] {\n    return this.state[type].list;\n  }\n\n  setList<T>(list: HMSPlaylistItem<T>[]): void {\n    if (!list || list.length === 0) {\n      HMSLogger.w(this.TAG, `Please pass in a list of HMSPlaylistItem's`);\n      return;\n    }\n    list.forEach((item: HMSPlaylistItem<T>) => {\n      if (!this.state[item.type].list.includes(item)) {\n        this.state[item.type].list.push(item);\n      }\n    });\n  }\n\n  async clearList(type: HMSPlaylistType): Promise<void> {\n    if (this.isPlaying(type)) {\n      await this.stop(type);\n    }\n    this.state[type].list = [];\n  }\n\n  async removeItem(id: string, type: HMSPlaylistType): Promise<boolean> {\n    const { list, currentIndex } = this.state[type];\n    const index = list.findIndex(playItem => id === playItem.id);\n    if (index > -1) {\n      // stop if the item is playing\n      if (currentIndex === index && this.isPlaying(type)) {\n        await this.stop(type);\n      }\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  seek(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      const updatedValue = Math.max(element.currentTime + value, 0);\n      element.currentTime = Math.min(updatedValue, element.duration);\n    }\n  }\n\n  seekTo(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    if (value < 0) {\n      throw Error('value cannot be negative');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.currentTime = Math.min(value, element.duration);\n    }\n  }\n\n  setVolume(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.volume = value * 0.01;\n    }\n  }\n\n  getVolume(type: HMSPlaylistType = HMSPlaylistType.audio): number {\n    const element = this.getElement(type);\n    if (element) {\n      return element.volume * 100;\n    }\n    return 0;\n  }\n\n  getCurrentTime(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element?.currentTime || 0;\n  }\n\n  getCurrentIndex(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return this.state[type].currentIndex;\n  }\n\n  getCurrentProgress(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    const activeUrl = list[currentIndex]?.url;\n    const element = this.getElement(type);\n    if (!activeUrl || !element) {\n      return 0;\n    }\n    return Math.floor(100 * (element.currentTime / element.duration));\n  }\n\n  getCurrentSelection(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      return undefined;\n    }\n    return list[currentIndex];\n  }\n\n  isPlaying(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return !!element && !element.paused;\n  }\n\n  setIsAutoplayOn(type: HMSPlaylistType = HMSPlaylistType.audio, autoplay: boolean) {\n    this.state[type].isAutoplayOn = autoplay;\n  }\n\n  getPlaybackRate(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element ? element.playbackRate : 1.0;\n  }\n\n  setPlaybackRate(type: HMSPlaylistType = HMSPlaylistType.audio, value: number) {\n    if (value < 0.25 || value > 2.0) {\n      throw Error('Please pass a value between 0.25 and 2.0');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.playbackRate = value;\n    }\n  }\n\n  async setEnabled(\n    enabled: boolean,\n    { id, type = HMSPlaylistType.audio }: { id: string; type: HMSPlaylistType },\n  ): Promise<void> {\n    const list = this.state[type].list;\n    const currentIndex = list.findIndex(item => item.id === id);\n    if (!id || currentIndex === -1) {\n      HMSLogger.w(this.TAG, 'Pass a valid id');\n      return;\n    }\n    const url = this.state[type].list[currentIndex].url;\n    if (enabled) {\n      await this.play(url, type);\n    } else {\n      await this.pause(url, type);\n    }\n    this.state[type].currentIndex = currentIndex;\n    this.setDuration(type);\n  }\n\n  async playNext(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex >= list.length - 1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached end of playlist');\n    }\n    await this.play(list[currentIndex + 1].url, type);\n    this.state[type].currentIndex = currentIndex + 1;\n    this.setDuration(type);\n  }\n\n  async playPrevious(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex <= 0) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached start of playlist');\n    }\n    await this.play(list[currentIndex - 1].url, type);\n    this.state[type].currentIndex = currentIndex - 1;\n    this.setDuration(type);\n  }\n\n  async stop(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    manager.getElement()?.pause(); //pause local video/audio and remove tracks in next step\n    await this.removeTracks(type);\n    manager.stop();\n    this.state[type].currentIndex = -1;\n  }\n\n  cleanup() {\n    this.state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n    this.eventBus.localAudioEnabled.unsubscribe(this.handlePausePlaylist);\n    this.eventBus.localVideoEnabled.unsubscribe(this.handlePausePlaylist);\n    this.audioManager.stop();\n    this.videoManager.stop();\n  }\n\n  onProgress(fn: (progress: HMSPlaylistProgressEvent) => void) {\n    this.videoManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.video,\n          progress: this.getCurrentProgress(HMSPlaylistType.video),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n    this.audioManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.audio,\n          progress: this.getCurrentProgress(HMSPlaylistType.audio),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n  }\n\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('newTrackStart', fn);\n  }\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void) {\n    this.on('playlistEnded', fn);\n  }\n\n  onCurrentTrackEnded<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('currentTrackEnded', fn);\n  }\n\n  private getElement(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return type === HMSPlaylistType.audio ? this.audioManager.getElement() : this.videoManager.getElement();\n  }\n\n  private async removeTracks(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const tracks = manager.getTracks();\n    for (const trackId of tracks) {\n      await this.removeTrack(trackId);\n    }\n  }\n\n  private async play(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const element = manager.getElement();\n    if (this.isItemCurrentlyPlaying(url, type)) {\n      HMSLogger.w(this.TAG, `The ${type} is currently playing`);\n      return;\n    }\n    if (element?.src.includes(url)) {\n      await element.play();\n    } else {\n      element?.pause();\n      const tracks: MediaStreamTrack[] = await manager.play(url);\n      for (const track of tracks) {\n        await this.addTrack(track, type === HMSPlaylistType.audio ? 'audioplaylist' : 'videoplaylist');\n      }\n    }\n  }\n\n  private isItemCurrentlyPlaying(url: string, type: HMSPlaylistType): boolean {\n    const element = this.getElement(type);\n    return !!(element && !element.paused && element.src.includes(url));\n  }\n\n  private setDuration(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    const { list, currentIndex } = this.state[type];\n    if (list[currentIndex]) {\n      list[currentIndex].duration = element?.duration || 0;\n    }\n    this.emit('newTrackStart', list[currentIndex]);\n  }\n\n  private async pause(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const el = this.getElement(type);\n    if (el && !el.paused && el.src.includes(url)) {\n      el.pause();\n      HMSLogger.d(this.TAG, 'paused url', url);\n    } else {\n      HMSLogger.w(this.TAG, 'The passed in url is not currently playing');\n    }\n  }\n\n  private handlePausePlaylist = async ({ enabled, track }: { enabled: boolean; track: HMSLocalTrack }) => {\n    if (enabled) {\n      return;\n    }\n    let type: HMSPlaylistType | undefined = undefined;\n    if (track.source === 'audioplaylist') {\n      type = HMSPlaylistType.audio;\n    }\n    if (track.source === 'videoplaylist') {\n      type = HMSPlaylistType.video;\n    }\n    if (!type) {\n      return;\n    }\n    this.getElement(type)?.pause();\n  };\n\n  private addListeners() {\n    this.audioManager.on('ended', () => this.handleEnded(HMSPlaylistType.audio));\n    this.videoManager.on('ended', () => this.handleEnded(HMSPlaylistType.video));\n    this.eventBus.localAudioEnabled.subscribe(this.handlePausePlaylist);\n    this.eventBus.localAudioEnabled.subscribe(this.handlePausePlaylist);\n  }\n\n  /**\n   * Remove tracks if reached the end of list otherwise play next\n   * @param {HMSPlaylistType} type\n   */\n  private async handleEnded(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex, isAutoplayOn } = this.state[type];\n    if (currentIndex === list.length - 1) {\n      await this.stop(type);\n      this.emit('playlistEnded', type);\n    } else {\n      if (isAutoplayOn) {\n        this.playNext(type);\n      } else {\n        // when autoplay not allowed, pause the media element\n        await this.pause(list[currentIndex].url, type);\n      }\n    }\n    this.emit('currentTrackEnded', list[currentIndex]);\n  }\n\n  private addTrack = async (track: MediaStreamTrack, source: string) => {\n    await this.sdk.addTrack(track, source);\n    HMSLogger.d(this.TAG, 'Playlist track added', track);\n  };\n\n  private removeTrack = async (trackId: string) => {\n    await this.sdk.removeTrack(trackId);\n    HMSLogger.d(this.TAG, 'Playlist track removed', trackId);\n  };\n\n  private get TAG() {\n    return 'PlaylistManager';\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\nimport { HMSDeviceChangeEvent, HMSRole } from '../interfaces';\nimport { HMSEvents } from '../utils/constants';\nimport { HMSInternalEvent } from './HMSInternalEvent';\nimport { HMSRemoteAudioTrack, HMSLocalAudioTrack, HMSRemoteVideoTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { HMSWebrtcStats } from '../rtc-stats';\nimport { ITrackAudioLevelUpdate } from '../utils/track-audio-level-monitor';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport { PolicyParams } from '../notification-manager';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { HMSException } from '../error/HMSException';\n\nexport class EventBus {\n  private eventEmitter: EventEmitter = new EventEmitter();\n  readonly deviceChange = new HMSInternalEvent<HMSDeviceChangeEvent>(HMSEvents.DEVICE_CHANGE, this.eventEmitter);\n  readonly localAudioEnabled = new HMSInternalEvent<{ enabled: boolean; track: HMSLocalAudioTrack }>(\n    HMSEvents.LOCAL_AUDIO_ENABLED,\n    this.eventEmitter,\n  );\n  readonly localVideoEnabled = new HMSInternalEvent<{ enabled: boolean; track: HMSLocalVideoTrack }>(\n    HMSEvents.LOCAL_VIDEO_ENABLED,\n    this.eventEmitter,\n  );\n\n  /**\n   * Emitter which processes raw RTC stats from rtcStatsUpdate and calls client callback\n   */\n  readonly statsUpdate = new HMSInternalEvent<HMSWebrtcStats>(HMSEvents.STATS_UPDATE, this.eventEmitter);\n\n  readonly trackDegraded = new HMSInternalEvent<HMSRemoteVideoTrack>(HMSEvents.TRACK_DEGRADED, this.eventEmitter);\n  readonly trackRestored = new HMSInternalEvent<HMSRemoteVideoTrack>(HMSEvents.TRACK_RESTORED, this.eventEmitter);\n\n  /**\n   * Emits audio level updates for audio tracks(used with local track in preview)\n   */\n  readonly trackAudioLevelUpdate = new HMSInternalEvent<ITrackAudioLevelUpdate>(\n    HMSEvents.TRACK_AUDIO_LEVEL_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioPluginFailed = new HMSInternalEvent<HMSException>(HMSEvents.AUDIO_PLUGIN_FAILED, this.eventEmitter);\n\n  readonly localAudioSilence = new HMSInternalEvent<{ track: HMSLocalAudioTrack }>(\n    HMSEvents.LOCAL_AUDIO_SILENCE,\n    this.eventEmitter,\n  );\n\n  readonly analytics = new HMSInternalEvent<AnalyticsEvent>(HMSEvents.ANALYTICS, this.eventEmitter);\n\n  readonly policyChange = new HMSInternalEvent<PolicyParams>(HMSEvents.POLICY_CHANGE, this.eventEmitter);\n\n  readonly localRoleUpdate = new HMSInternalEvent<{ oldRole: HMSRole; newRole: HMSRole }>(\n    HMSEvents.LOCAL_ROLE_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackUpdate = new HMSInternalEvent<{ track: HMSRemoteAudioTrack; enabled: boolean }>(\n    HMSEvents.AUDIO_TRACK_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackAdded = new HMSInternalEvent<{ track: HMSRemoteAudioTrack; peer: HMSRemotePeer }>(\n    HMSEvents.AUDIO_TRACK_ADDED,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackRemoved = new HMSInternalEvent<HMSRemoteAudioTrack>(\n    HMSEvents.AUDIO_TRACK_REMOVED,\n    this.eventEmitter,\n  );\n\n  readonly autoplayError = new HMSInternalEvent<HMSException>(HMSEvents.AUTOPLAY_ERROR, this.eventEmitter);\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\nimport type { WaitForFilter, WaitForOptions } from 'eventemitter2';\n\nexport class HMSInternalEvent<T> {\n  constructor(private eventName: string, private eventEmitter: EventEmitter) {}\n\n  publish = (event?: T) => {\n    this.eventEmitter.emit(this.eventName, event);\n  };\n  subscribe = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.on(this.eventName, fn);\n  };\n  subscribeOnce = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.once(this.eventName, fn);\n  };\n  unsubscribe = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.off(this.eventName, fn);\n  };\n  waitFor = (predicate: WaitForFilter) => {\n    return this.eventEmitter.waitFor(this.eventName, {\n      filter: predicate,\n    } as WaitForOptions);\n  };\n  removeAllListeners = () => {\n    this.eventEmitter.removeAllListeners(this.eventName);\n  };\n}\n", "import AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { EventBus } from '../events/EventBus';\nimport { HMSUpdateListener } from '../interfaces';\nimport { NetworkHealth, ScoreMap } from '../signal/init/models';\nimport HMSLogger from '../utils/logger';\nimport { sleep } from '../utils/timer-utils';\n\nexport class NetworkTestManager {\n  private TAG = 'NetworkTestManager';\n  private controller = new AbortController();\n  private score?: number;\n  constructor(private eventBus: EventBus, private listener?: HMSUpdateListener) {}\n\n  start = async (networkHealth: NetworkHealth) => {\n    if (!networkHealth) {\n      return;\n    }\n    const { url, timeout, scoreMap } = networkHealth;\n    const signal = this.controller.signal;\n\n    const startTime = Date.now();\n    let downloadedSize = 0;\n    const timeoutPromise = sleep(timeout).then(() => {\n      this.controller.abort();\n    });\n    try {\n      const res = await fetch(`${url}?${Date.now()}`, { signal });\n      const reader = res.body?.getReader();\n      if (!reader) {\n        throw Error('unable to process request');\n      }\n      const readData = async () => {\n        if (!reader) {\n          return;\n        }\n        try {\n          let completed = false;\n          while (!completed) {\n            const { value, done } = await reader.read();\n            completed = done;\n            if (value) {\n              downloadedSize += value.byteLength;\n              this.sendScore({ scoreMap, downloadedSize, startTime });\n            }\n          }\n        } catch (error) {\n          HMSLogger.e(this.TAG, error);\n        }\n      };\n\n      return Promise.race([readData(), timeoutPromise])\n        .then(() => {\n          this.sendScore({ scoreMap, downloadedSize, startTime, finished: true });\n        })\n        .catch(error => {\n          HMSLogger.e(this.TAG, error);\n          this.updateScoreToListener(0);\n          this.eventBus.analytics.publish(\n            AnalyticsEventFactory.previewNetworkQuality({ error: (error as Error).message }),\n          );\n        });\n    } catch (error) {\n      HMSLogger.e(this.TAG, error);\n      if ((error as Error).name !== 'AbortError') {\n        this.updateScoreToListener(0);\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.previewNetworkQuality({ error: (error as Error).message }),\n        );\n      }\n    }\n  };\n\n  stop = () => {\n    if (!this.controller.signal.aborted) {\n      this.controller.abort();\n    }\n  };\n\n  private sendScore = ({\n    scoreMap,\n    downloadedSize,\n    startTime,\n    finished = false,\n  }: {\n    scoreMap: ScoreMap;\n    downloadedSize: number;\n    startTime: number;\n    finished?: boolean;\n  }) => {\n    const totalTimeInSecs = (Date.now() - startTime) / 1000;\n    const sizeInKB = downloadedSize / 1024;\n    const bitrate = (sizeInKB / totalTimeInSecs) * 8;\n    let calculatedScore = -1;\n    for (const score in scoreMap) {\n      const thresholds = scoreMap[score];\n      if (bitrate >= thresholds.low && (!thresholds.high || bitrate <= thresholds.high)) {\n        calculatedScore = Number(score);\n      }\n    }\n    this.updateScoreToListener(calculatedScore);\n    if (finished) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.previewNetworkQuality({ score: calculatedScore, downLink: bitrate.toFixed(2) }),\n      );\n    }\n  };\n\n  private updateScoreToListener(newQualityScore: number) {\n    if (newQualityScore === this.score) {\n      return;\n    }\n    this.score = newQualityScore;\n    this.listener?.onNetworkQuality?.(newQualityScore);\n  }\n}\n", "import {\n  HMSChangeMultiTrackStateParams,\n  HMSConfig,\n  HMSConnectionQualityListener,\n  HMSDeviceChangeEvent,\n  HMSMessageInput,\n  HMSPlaylistType,\n  HMSRole,\n  HMSRoleChangeRequest,\n  HMSVideoCodec,\n  ScreenShareConfig,\n} from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport HMSInterface from '../interfaces/hms';\nimport HMSTransport from '../transport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport { HMSAudioListener, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport HMSLogger, { HMSLogLevel } from '../utils/logger';\nimport decodeJWT from '../utils/jwt';\nimport { HMSNotificationMethod, NotificationManager, PeerLeaveRequestNotification } from '../notification-manager';\nimport {\n  HMSLocalAudioTrack,\n  HMSLocalTrack,\n  HMSLocalVideoTrack,\n  HMSRemoteTrack,\n  HMSRemoteVideoTrack,\n  HMSTrackSource,\n  HMSTrackType,\n} from '../media/tracks';\nimport { HMSException } from '../error/HMSException';\nimport HMSRoom from './models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from './models/peer';\nimport Message from './models/HMSMessage';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport { HMSAudioTrackSettingsBuilder, HMSVideoTrackSettingsBuilder } from '../media/settings';\nimport { AudioSinkManager } from '../audio-sink-manager';\nimport { AudioOutputManager, DeviceManager } from '../device-manager';\nimport { HMSAnalyticsLevel } from '../analytics/AnalyticsEventLevel';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport { TransportState } from '../transport/models/TransportState';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { HMSPreviewListener } from '../interfaces/preview-listener';\nimport { IErrorListener } from '../interfaces/error-listener';\nimport { IStore, Store } from './store';\nimport { DeviceChangeListener } from '../interfaces/device-change-listener';\nimport RoleChangeManager from './RoleChangeManager';\nimport { HMSLeaveRoomRequest } from '../interfaces/leave-room-request';\nimport { DeviceStorageManager } from '../device-manager/DeviceStorage';\nimport { LocalTrackManager } from './LocalTrackManager';\nimport { PlaylistManager } from '../playlist-manager';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport { isNode } from '../utils/support';\nimport { EventBus } from '../events/EventBus';\nimport { HLSConfig, HLSTimedMetadata } from '../interfaces/hls-config';\nimport { validateMediaDevicesExistence, validateRTCPeerConnection } from '../utils/validations';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport { InitConfig } from '../signal/init/models';\nimport { NetworkTestManager } from './NetworkTestManager';\nimport { HMSAudioContextHandler } from '../utils/media';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\n\n// @DISCUSS: Adding it here as a hotfix\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nconst INITIAL_STATE = {\n  published: false,\n  isInitialised: false,\n  isReconnecting: false,\n  isPreviewInProgress: false,\n  deviceManagersInitialised: false,\n};\n\nexport class HMSSdk implements HMSInterface {\n  private transport!: HMSTransport;\n  private TAG = '[HMSSdk]:';\n  private listener?: HMSUpdateListener;\n  private errorListener?: IErrorListener;\n  private deviceChangeListener?: DeviceChangeListener;\n  private audioListener?: HMSAudioListener;\n  private store!: IStore;\n  private notificationManager!: NotificationManager;\n  private deviceManager!: DeviceManager;\n  private audioSinkManager!: AudioSinkManager;\n  private playlistManager!: PlaylistManager;\n  private audioOutput!: AudioOutputManager;\n  private transportState: TransportState = TransportState.Disconnected;\n  private roleChangeManager?: RoleChangeManager;\n  private localTrackManager!: LocalTrackManager;\n  private analyticsEventsService!: AnalyticsEventsService;\n  private analyticsTimer = new AnalyticsTimer();\n  private eventBus!: EventBus;\n  private networkTestManager!: NetworkTestManager;\n  private sdkState = { ...INITIAL_STATE };\n\n  private initStoreAndManagers() {\n    if (this.sdkState.isInitialised) {\n      /**\n       * Set listener after both join and preview, since they can have different listeners\n       */\n      this.notificationManager.setListener(this.listener);\n      this.audioSinkManager.setListener(this.listener);\n      return;\n    }\n\n    this.sdkState.isInitialised = true;\n    this.store = new Store();\n    this.eventBus = new EventBus();\n    this.networkTestManager = new NetworkTestManager(this.eventBus, this.listener);\n    this.playlistManager = new PlaylistManager(this, this.eventBus);\n    this.notificationManager = new NotificationManager(this.store, this.eventBus, this.listener, this.audioListener);\n    this.deviceManager = new DeviceManager(this.store, this.eventBus);\n    this.audioSinkManager = new AudioSinkManager(this.store, this.deviceManager, this.eventBus);\n    this.audioOutput = new AudioOutputManager(this.deviceManager, this.audioSinkManager);\n    this.audioSinkManager.setListener(this.listener);\n    this.eventBus.autoplayError.subscribe(this.handleAutoplayError);\n    this.localTrackManager = new LocalTrackManager(\n      this.store,\n      this.observer,\n      this.deviceManager,\n      this.eventBus,\n      this.analyticsTimer,\n    );\n    this.analyticsEventsService = new AnalyticsEventsService(this.store);\n    this.transport = new HMSTransport(\n      this.observer,\n      this.deviceManager,\n      this.store,\n      this.localTrackManager,\n      this.eventBus,\n      this.analyticsEventsService,\n      this.analyticsTimer,\n    );\n\n    /**\n     * Note: Subscribe to events here right after creating stores and managers\n     * to not miss events that are published before the handlers are subscribed.\n     */\n    this.eventBus.analytics.subscribe(this.sendAnalyticsEvent);\n    this.eventBus.deviceChange.subscribe(this.handleDeviceChange);\n    this.eventBus.audioPluginFailed.subscribe(this.handleAudioPluginError);\n  }\n\n  private validateJoined(name: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, `Not connected - ${name}`);\n    }\n  }\n\n  async refreshDevices() {\n    this.validateJoined('refreshDevices');\n    await this.deviceManager.init(true);\n  }\n\n  getWebrtcInternals() {\n    return this.transport?.getWebrtcInternals();\n  }\n\n  getPlaylistManager(): PlaylistManager {\n    return this.playlistManager;\n  }\n\n  getRecordingState() {\n    return this.store.getRoom()?.recording;\n  }\n\n  getRTMPState() {\n    return this.store.getRoom()?.rtmp;\n  }\n\n  getHLSState() {\n    return this.store.getRoom()?.hls;\n  }\n\n  private handleAutoplayError = (error: HMSException) => {\n    this.errorListener?.onError?.(error);\n  };\n\n  private get localPeer(): HMSLocalPeer | undefined {\n    return this.store?.getLocalPeer();\n  }\n\n  private observer: ITransportObserver = {\n    onNotification: (message: any) => {\n      if (message.method === HMSNotificationMethod.PEER_LEAVE_REQUEST) {\n        this.handlePeerLeaveRequest(message.params as PeerLeaveRequestNotification);\n        return;\n      }\n\n      if (message.method === HMSNotificationMethod.POLICY_CHANGE) {\n        this.analyticsTimer.end(TimedEvent.ON_POLICY_CHANGE);\n      }\n\n      this.notificationManager.handleNotification(message, this.sdkState.isReconnecting);\n    },\n\n    onTrackAdd: (track: HMSRemoteTrack) => {\n      this.notificationManager.handleTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSRemoteTrack) => {\n      this.notificationManager.handleTrackRemove(track);\n    },\n\n    onTrackDegrade: (track: HMSRemoteVideoTrack) => {\n      HMSLogger.d(this.TAG, 'Sending Track Update Track Degraded', track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_DEGRADED, track, this.store?.getPeerByTrackId(track.trackId)!);\n    },\n\n    onTrackRestore: (track: HMSRemoteVideoTrack) => {\n      HMSLogger.d(this.TAG, 'Sending Track Update Track Restored', track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_RESTORED, track, this.store?.getPeerByTrackId(track.trackId)!);\n    },\n\n    onFailure: (exception: HMSException) => {\n      this.errorListener?.onError(exception);\n    },\n\n    onStateChange: async (state: TransportState, error?: HMSException) => {\n      switch (state) {\n        case TransportState.Preview:\n        case TransportState.Joined:\n          if (this.transportState === TransportState.Reconnecting) {\n            this.listener?.onReconnected();\n          }\n          break;\n        case TransportState.Failed:\n          await this.leave();\n\n          this.errorListener?.onError?.(error!);\n          this.sdkState.isReconnecting = false;\n          break;\n        case TransportState.Reconnecting:\n          this.sdkState.isReconnecting = true;\n          this.listener?.onReconnecting(error!);\n          break;\n      }\n\n      this.transportState = state;\n      HMSLogger.d(this.TAG, 'Transport State Change', this.transportState);\n    },\n  };\n\n  private handlePeerLeaveRequest = (message: PeerLeaveRequestNotification) => {\n    const peer = message.requested_by ? this.store.getPeerById(message.requested_by) : undefined;\n    const request: HMSLeaveRoomRequest = {\n      roomEnded: message.room_end,\n      reason: message.reason,\n      requestedBy: peer,\n    };\n    this.listener?.onRemovedFromRoom(request);\n    this.leave();\n  };\n\n  async preview(config: HMSConfig, listener: HMSPreviewListener) {\n    validateMediaDevicesExistence();\n    validateRTCPeerConnection();\n\n    if (this.sdkState.isPreviewInProgress) {\n      return Promise.reject(\n        ErrorFactory.GenericErrors.PreviewAlreadyInProgress(HMSAction.PREVIEW, 'Preview already called'),\n      );\n    }\n\n    this.analyticsTimer.start(TimedEvent.PREVIEW);\n    this.setUpPreview(config, listener);\n\n    // Request permissions and populate devices before waiting for policy\n    if (config.alwaysRequestPermissions) {\n      this.localTrackManager.requestPermissions().then(async () => {\n        await this.initDeviceManagers();\n      });\n    }\n\n    let initSuccessful = false;\n    let networkTestFinished = false;\n    const timerId = setTimeout(() => {\n      // If init or network is not done by 3s send -1\n      if (!initSuccessful || !networkTestFinished) {\n        this.listener?.onNetworkQuality?.(-1);\n      }\n    }, 3000);\n    return new Promise<void>((resolve, reject) => {\n      const policyHandler = async () => {\n        const tracks = await this.localTrackManager.getTracksToPublish(config.settings || defaultSettings);\n        tracks.forEach(track => this.setLocalPeerTrack(track));\n        this.localPeer?.audioTrack && this.initPreviewTrackAudioLevelMonitor();\n        await this.initDeviceManagers();\n        this.sdkState.isPreviewInProgress = false;\n        this.analyticsTimer.end(TimedEvent.PREVIEW);\n        listener.onPreview(this.store.getRoom(), tracks);\n        this.sendPreviewAnalyticsEvent();\n        resolve();\n      };\n\n      this.eventBus.policyChange.subscribeOnce(policyHandler);\n      this.transport\n        .preview(\n          config.authToken,\n          config.initEndpoint!,\n          this.localPeer!.peerId,\n          { name: config.userName, metaData: config.metaData || '' },\n          config.autoVideoSubscribe,\n        )\n        .then((initConfig: InitConfig | void) => {\n          initSuccessful = true;\n          clearTimeout(timerId);\n          if (initConfig && config.captureNetworkQualityInPreview) {\n            this.networkTestManager.start(initConfig.config?.networkHealth).then(() => {\n              networkTestFinished = true;\n            });\n          }\n        })\n        .catch(ex => {\n          this.analyticsTimer.end(TimedEvent.PREVIEW);\n          this.errorListener?.onError(ex as HMSException);\n          this.sendPreviewAnalyticsEvent(ex);\n          this.sdkState.isPreviewInProgress = false;\n          reject(ex as HMSException);\n        });\n    });\n  }\n\n  private handleDeviceChange = (event: HMSDeviceChangeEvent) => {\n    HMSLogger.d(this.TAG, 'Device Change event', event);\n    this.deviceChangeListener?.onDeviceChange?.(event);\n    if (event.error && event.type) {\n      const track = event.type.includes('audio') ? this.localPeer?.audioTrack : this.localPeer?.videoTrack;\n      this.errorListener?.onError(event.error);\n      if (\n        [\n          ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n          ErrorCodes.TracksErrors.DEVICE_IN_USE,\n          ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        ].includes(event.error.code) &&\n        track\n      ) {\n        track.setEnabled(false);\n        this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_MUTED, track, this.localPeer!);\n      }\n    }\n  };\n\n  private handleAudioPluginError = (error: HMSException) => {\n    HMSLogger.e(this.TAG, 'Audio Plugin Error event', error);\n    this.errorListener?.onError(error);\n  };\n\n  join(config: HMSConfig, listener: HMSUpdateListener) {\n    validateMediaDevicesExistence();\n    validateRTCPeerConnection();\n\n    if (this.sdkState.isPreviewInProgress) {\n      throw ErrorFactory.GenericErrors.NotReady(HMSAction.JOIN, \"Preview is in progress, can't join\");\n    }\n\n    this.analyticsTimer.start(TimedEvent.JOIN);\n\n    const isPreviewCalled = this.transportState === TransportState.Preview;\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    this.networkTestManager?.stop();\n    this.localPeer?.audioTrack?.destroyAudioLevelMonitor();\n    this.listener = listener;\n    this.commonSetup(config, roomId, listener);\n    this.removeDevicesFromConfig(config);\n    this.store.setConfig(config);\n\n    if (!this.localPeer) {\n      this.createAndAddLocalPeerToStore(config, role, userId);\n    } else {\n      this.localPeer.name = config.userName;\n      this.localPeer.role = this.store.getPolicyForRole(role);\n      this.localPeer.customerUserId = userId;\n      this.localPeer.metadata = config.metaData || '';\n    }\n\n    this.roleChangeManager = new RoleChangeManager(\n      this.store,\n      this.transport,\n      this.publish.bind(this),\n      this.removeTrack.bind(this),\n      this.listener,\n    );\n    this.eventBus.localRoleUpdate.subscribe(this.handleLocalRoleUpdate);\n\n    HMSLogger.d(this.TAG, 'SDK Store', this.store);\n    HMSLogger.d(this.TAG, `\u23F3 Joining room ${roomId}`);\n\n    HMSLogger.time(`join-room-${roomId}`);\n    this.transport\n      .join(\n        config.authToken,\n        this.localPeer!.peerId,\n        { name: config.userName, metaData: config.metaData || '' },\n        config.initEndpoint!,\n        config.autoVideoSubscribe,\n      )\n      .then(async () => {\n        HMSLogger.d(this.TAG, `\u2705 Joined room ${roomId}`);\n        HMSAudioContextHandler.resumeContext();\n        this.notifyJoin();\n        this.sendJoinAnalyticsEvent(isPreviewCalled);\n        if (this.store.getPublishParams() && !this.sdkState.published && !isNode) {\n          await this.publish(config.settings || defaultSettings);\n        }\n      })\n      .catch(error => {\n        this.analyticsTimer.end(TimedEvent.JOIN);\n        this.listener?.onError(error as HMSException);\n        this.sendJoinAnalyticsEvent(isPreviewCalled, error);\n        HMSLogger.e(this.TAG, 'Unable to join room', error);\n      })\n      .then(() => {\n        HMSLogger.timeEnd(`join-room-${roomId}`);\n      });\n  }\n\n  private stringifyMetadata(config: HMSConfig) {\n    if (config.metaData && typeof config.metaData !== 'string') {\n      JSON.stringify(config.metaData);\n    }\n  }\n\n  private cleanUp() {\n    this.cleanDeviceManagers();\n    this.eventBus.analytics.unsubscribe(this.sendAnalyticsEvent);\n    this.analyticsTimer.cleanUp();\n    DeviceStorageManager.cleanup();\n    this.playlistManager.cleanup();\n    HMSLogger.cleanUp();\n    this.sdkState = { ...INITIAL_STATE };\n    /**\n     * when leave is called after preview itself without join.\n     * Store won't have the tracks in this case\n     */\n    if (this.localPeer) {\n      this.localPeer.audioTrack?.cleanup();\n      this.localPeer.audioTrack = undefined;\n      this.localPeer.videoTrack?.cleanup();\n      this.localPeer.videoTrack = undefined;\n    }\n    this.store.cleanUp();\n    this.listener = undefined;\n    if (this.roleChangeManager) {\n      this.eventBus.localRoleUpdate.unsubscribe(this.roleChangeManager.handleLocalPeerRoleUpdate);\n    }\n  }\n\n  async leave() {\n    const room = this.store.getRoom();\n    if (room) {\n      const roomId = room.id;\n      this.networkTestManager?.stop();\n      HMSLogger.d(this.TAG, `\u23F3 Leaving room ${roomId}`);\n      // browsers often put limitation on amount of time a function set on window onBeforeUnload can take in case of\n      // tab refresh or close. Therefore prioritise the leave action over anything else, if tab is closed/refreshed\n      // we would want leave to succeed to stop stucked peer for others. The followup cleanup however is important\n      // for cases where uses stays on the page post leave.\n      await this.transport?.leave();\n      this.cleanUp();\n      HMSLogger.d(this.TAG, `\u2705 Left room ${roomId}`);\n    }\n  }\n\n  getLocalPeer() {\n    return this.store.getLocalPeer();\n  }\n\n  getPeers() {\n    const peers = this.store.getPeers();\n    if (peers.length < 50) {\n      // the log is too big and frequent for large rooms\n      HMSLogger.d(this.TAG, `Got peers`, peers);\n    }\n    return peers;\n  }\n\n  getAudioOutput() {\n    return this.audioOutput;\n  }\n\n  sendMessage(type: string, message: string) {\n    this.sendMessageInternal({ message, type });\n  }\n\n  async sendBroadcastMessage(message: string, type?: string) {\n    return await this.sendMessageInternal({ message, type });\n  }\n\n  async sendGroupMessage(message: string, roles: HMSRole[], type?: string) {\n    const knownRoles = this.store.getKnownRoles();\n    const recipientRoles =\n      roles.filter(role => {\n        return knownRoles[role.name];\n      }) || [];\n    if (recipientRoles.length === 0) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No valid role is present', roles);\n    }\n    return await this.sendMessageInternal({ message, recipientRoles: roles, type });\n  }\n\n  async sendDirectMessage(message: string, peer: HMSPeer, type?: string) {\n    const recipientPeer = this.store.getPeerById(peer.peerId);\n    if (!recipientPeer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer - peer not present in the room', peer);\n    }\n    if (this.localPeer?.peerId === peer.peerId) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Cannot send message to self');\n    }\n    return await this.sendMessageInternal({ message, recipientPeer: peer, type });\n  }\n\n  private async sendMessageInternal({ recipientRoles, recipientPeer, type = 'chat', message }: HMSMessageInput) {\n    if (message.replace(/\\u200b/g, ' ').trim() === '') {\n      HMSLogger.w(this.TAG, 'sendMessage', 'Ignoring empty message send');\n      throw ErrorFactory.GenericErrors.ValidationFailed('Empty message not allowed');\n    }\n    const hmsMessage = new Message({\n      sender: this.localPeer!,\n      type,\n      message,\n      recipientPeer,\n      recipientRoles,\n      time: new Date(),\n    });\n    HMSLogger.d(this.TAG, 'Sending Message: ', hmsMessage);\n    const response = await this.transport.sendMessage(hmsMessage);\n    hmsMessage.time = new Date(response.timestamp);\n    return hmsMessage;\n  }\n\n  async startScreenShare(onStop: () => void, config: ScreenShareConfig = { audioOnly: false, videoOnly: false }) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams) {\n      return;\n    }\n\n    const { allowed } = publishParams;\n    const canPublishScreen = allowed && allowed.includes('screen');\n\n    if (!canPublishScreen) {\n      HMSLogger.e(this.TAG, `Role ${this.localPeer?.role} cannot share screen`);\n      return;\n    }\n\n    if (this.localPeer?.auxiliaryTracks?.find(track => track.source === 'screen')) {\n      throw Error('Cannot share multiple screens');\n    }\n\n    const tracks = await this.getScreenshareTracks(onStop, config);\n    if (!this.localPeer) {\n      HMSLogger.d(this.TAG, 'Screenshared when not connected');\n      tracks.forEach(track => {\n        track.cleanup();\n      });\n      return;\n    }\n    await this.transport.publish(tracks);\n    tracks.forEach(track => {\n      track.peerId = this.localPeer?.peerId;\n      this.localPeer?.auxiliaryTracks.push(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    });\n  }\n\n  private async stopEndedScreenshare(onStop: () => void) {\n    HMSLogger.d(this.TAG, `\u2705 Screenshare ended natively`);\n    await this.stopScreenShare();\n    onStop();\n  }\n\n  async stopScreenShare() {\n    HMSLogger.d(this.TAG, `\u2705 Screenshare ended from app`);\n    const screenTracks = this.localPeer?.auxiliaryTracks.filter(t => t.source === 'screen');\n    if (screenTracks) {\n      for (const track of screenTracks) {\n        await this.removeTrack(track.trackId);\n      }\n    }\n  }\n\n  async addTrack(track: MediaStreamTrack, source: HMSTrackSource = 'regular'): Promise<void> {\n    if (!track) {\n      HMSLogger.w(this.TAG, 'Please pass a valid MediaStreamTrack');\n      return;\n    }\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot addTrack');\n    }\n    const isTrackPresent = this.localPeer.auxiliaryTracks.find(t => t.trackId === track.id);\n    if (isTrackPresent) {\n      return;\n    }\n\n    const type = track.kind;\n    const nativeStream = new MediaStream([track]);\n    const stream = new HMSLocalStream(nativeStream);\n\n    const TrackKlass = type === 'audio' ? HMSLocalAudioTrack : HMSLocalVideoTrack;\n    const hmsTrack = new TrackKlass(stream, track, source, this.eventBus);\n    this.setPlaylistSettings({\n      track,\n      hmsTrack,\n      source,\n    });\n\n    await this.transport?.publish([hmsTrack]);\n    hmsTrack.peerId = this.localPeer?.peerId;\n    this.localPeer?.auxiliaryTracks.push(hmsTrack);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, hmsTrack, this.localPeer!);\n  }\n\n  async removeTrack(trackId: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot removeTrack');\n    }\n    const trackIndex = this.localPeer.auxiliaryTracks.findIndex(t => t.trackId === trackId);\n    if (trackIndex > -1) {\n      const track = this.localPeer.auxiliaryTracks[trackIndex];\n      await this.transport!.unpublish([track]);\n      // Stop local playback when playlist track is removed\n      if (track.source === 'audioplaylist') {\n        this.playlistManager.stop(HMSPlaylistType.audio);\n      } else if (track.source === 'videoplaylist') {\n        this.playlistManager.stop(HMSPlaylistType.video);\n      }\n      this.localPeer.auxiliaryTracks.splice(trackIndex, 1);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, this.localPeer);\n    } else {\n      HMSLogger.w(this.TAG, `No track found for ${trackId}`);\n    }\n  }\n\n  setAnalyticsLevel(level: HMSAnalyticsLevel) {\n    this.analyticsEventsService.level = level;\n  }\n\n  setLogLevel(level: HMSLogLevel) {\n    HMSLogger.level = level;\n  }\n\n  addAudioListener(audioListener: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.notificationManager.setAudioListener(audioListener);\n  }\n\n  addConnectionQualityListener(qualityListener: HMSConnectionQualityListener) {\n    this.notificationManager.setConnectionQualityListener(qualityListener);\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force = false) {\n    if (!forPeer.role || forPeer.role.name === toRole) {\n      return;\n    }\n\n    await this.transport?.changeRole(forPeer, toRole, force);\n  }\n\n  async acceptChangeRole(request: HMSRoleChangeRequest) {\n    await this.transport?.acceptRoleChange(request);\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot end room');\n    }\n    await this.transport?.endRoom(lock, reason);\n    await this.leave();\n  }\n\n  async removePeer(peer: HMSRemotePeer, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot remove peer');\n    }\n\n    if (!this.store.getPeerById(peer.peerId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer, given peer not present in room', peer);\n    }\n    await this.transport?.removePeer(peer.peerId, reason);\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start streaming or recording',\n      );\n    }\n    try {\n      await this.transport?.startRTMPOrRecording(params);\n    } catch (error) {\n      this.sendAnalyticsEvent(AnalyticsEventFactory.RTMPError(error as Error));\n      throw error;\n    }\n  }\n\n  async stopRTMPAndRecording() {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop streaming or recording',\n      );\n    }\n    try {\n      await this.transport?.stopRTMPOrRecording();\n    } catch (error) {\n      this.sendAnalyticsEvent(AnalyticsEventFactory.RTMPError(error as Error, false));\n      throw error;\n    }\n  }\n\n  async startHLSStreaming(params?: HLSConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start HLS streaming',\n      );\n    }\n    try {\n      await this.transport?.startHLSStreaming(params);\n    } catch (error) {\n      this.sendAnalyticsEvent(AnalyticsEventFactory.HLSError(error as Error));\n      throw error;\n    }\n  }\n\n  async stopHLSStreaming(params?: HLSConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop HLS streaming',\n      );\n    }\n    try {\n      await this.transport?.stopHLSStreaming(params);\n    } catch (error) {\n      this.sendAnalyticsEvent(AnalyticsEventFactory.HLSError(error as Error, false));\n      throw error;\n    }\n  }\n\n  async sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]) {\n    this.validateJoined('sendHLSTimedMetadata');\n    await this.transport?.sendHLSTimedMetadata(metadataList);\n  }\n\n  async changeName(name: string) {\n    this.validateJoined('changeName');\n    await this.transport?.changeName(name);\n    this.notificationManager.updateLocalPeer({ name });\n  }\n\n  async changeMetadata(metadata: string) {\n    this.validateJoined('changeMetadata');\n    await this.transport?.changeMetadata(metadata);\n    this.notificationManager.updateLocalPeer({ metadata });\n  }\n\n  getRoles(): HMSRole[] {\n    return Object.values(this.store.getKnownRoles());\n  }\n\n  async changeTrackState(forRemoteTrack: HMSRemoteTrack, enabled: boolean) {\n    if (forRemoteTrack.type === HMSTrackType.VIDEO && forRemoteTrack.source !== 'regular') {\n      HMSLogger.w(this.TAG, `Muting non-regular video tracks is currently not supported`);\n      return;\n    }\n\n    if (forRemoteTrack.enabled === enabled) {\n      HMSLogger.w(this.TAG, `Aborting change track state, track already has enabled - ${enabled}`, forRemoteTrack);\n      return;\n    }\n\n    if (!this.store.getTrackById(forRemoteTrack.trackId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No track found for change track state', forRemoteTrack);\n    }\n\n    const peer = this.store.getPeerByTrackId(forRemoteTrack.trackId);\n\n    if (!peer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No peer found for change track state', forRemoteTrack);\n    }\n\n    await this.transport?.changeTrackState({\n      requested_for: peer.peerId,\n      track_id: forRemoteTrack.trackId,\n      stream_id: forRemoteTrack.stream.id,\n      mute: !enabled,\n    });\n  }\n\n  async changeMultiTrackState(params: HMSChangeMultiTrackStateParams) {\n    if (typeof params.enabled !== 'boolean') {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Pass a boolean for enabled');\n    }\n    const { enabled, roles, type, source } = params;\n    await this.transport?.changeMultiTrackState({\n      value: !enabled,\n      type,\n      source,\n      roles: roles?.map(role => role?.name),\n    });\n  }\n\n  private async publish(initialSettings: InitialSettings) {\n    const tracks = await this.localTrackManager.getTracksToPublish(initialSettings);\n    await this.setAndPublishTracks(tracks);\n    this.sdkState.published = true;\n  }\n\n  private handleLocalRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    await this.transport.handleLocalRoleUpdate({ oldRole, newRole });\n    await this.roleChangeManager?.handleLocalPeerRoleUpdate({ oldRole, newRole });\n  };\n\n  private async setAndPublishTracks(tracks: HMSLocalTrack[]) {\n    for (const track of tracks) {\n      await this.transport.publish([track]);\n      this.setLocalPeerTrack(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    }\n    await this.initDeviceManagers();\n  }\n\n  private setLocalPeerTrack(track: HMSLocalTrack) {\n    track.peerId = this.localPeer?.peerId;\n    switch (track.type) {\n      case HMSTrackType.AUDIO:\n        this.localPeer!.audioTrack = track as HMSLocalAudioTrack;\n        break;\n\n      case HMSTrackType.VIDEO:\n        this.localPeer!.videoTrack = track as HMSLocalVideoTrack;\n        break;\n    }\n  }\n\n  private async initDeviceManagers() {\n    // No need to initialise and add listeners if already initialised in preview\n    if (this.sdkState.deviceManagersInitialised) {\n      return;\n    }\n    this.sdkState.deviceManagersInitialised = true;\n    await this.deviceManager.init();\n    this.deviceManager.updateOutputDevice(DeviceStorageManager.getSelection()?.audioOutput?.deviceId);\n    this.audioSinkManager.init(this.store.getConfig()?.audioSinkElementId);\n  }\n\n  private cleanDeviceManagers() {\n    this.eventBus.deviceChange.unsubscribe(this.handleDeviceChange);\n    this.eventBus.audioPluginFailed.unsubscribe(this.handleAudioPluginError);\n    this.eventBus.autoplayError.unsubscribe(this.handleAutoplayError);\n    this.deviceManager.cleanUp();\n    this.audioSinkManager.cleanUp();\n  }\n\n  private initPreviewTrackAudioLevelMonitor() {\n    const localAudioTrack = this.localPeer?.audioTrack;\n    localAudioTrack?.initAudioLevelMonitor();\n    this.eventBus.trackAudioLevelUpdate.subscribe(audioLevelUpdate => {\n      const hmsSpeakers =\n        audioLevelUpdate && audioLevelUpdate.track.trackId === localAudioTrack?.trackId\n          ? [{ audioLevel: audioLevelUpdate.audioLevel, peer: this.localPeer!, track: localAudioTrack! }]\n          : [];\n      this.store.updateSpeakers(hmsSpeakers);\n      this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    });\n    this.eventBus.localAudioSilence.subscribe(this.sendAudioPresenceFailed);\n  }\n\n  private notifyJoin() {\n    const localPeer = this.store.getLocalPeer();\n    const room = this.store.getRoom();\n    room.joinedAt = new Date();\n    if (localPeer) {\n      localPeer.joinedAt = room.joinedAt;\n    }\n\n    if (localPeer?.role) {\n      this.analyticsTimer.end(TimedEvent.JOIN);\n      this.listener?.onJoin(room);\n    } else {\n      this.eventBus.policyChange.subscribeOnce(() => {\n        this.analyticsTimer.end(TimedEvent.JOIN);\n        this.listener?.onJoin(room);\n      });\n    }\n  }\n\n  /**\n   * Init store and other managers, setup listeners, create local peer, room\n   * @param {HMSConfig} config\n   * @param {HMSPreviewListener} listener\n   */\n  private setUpPreview(config: HMSConfig, listener: HMSPreviewListener) {\n    this.listener = listener as unknown as HMSUpdateListener;\n    this.sdkState.isPreviewInProgress = true;\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    this.commonSetup(config, roomId, listener);\n    this.store.setConfig(config);\n    this.createAndAddLocalPeerToStore(config, role, userId);\n    HMSLogger.d(this.TAG, 'SDK Store', this.store);\n  }\n\n  /**\n   * Set bitrate and dimensions for playlist track\n   */\n  private async setPlaylistSettings({\n    track,\n    hmsTrack,\n    source,\n  }: {\n    track: MediaStreamTrack;\n    hmsTrack: HMSLocalAudioTrack | HMSLocalVideoTrack;\n    source: string;\n  }) {\n    if (source === 'videoplaylist') {\n      const settings: { maxBitrate?: number; width?: number; height?: number } = {};\n      if (track.kind === 'audio') {\n        settings.maxBitrate = 64;\n      } else {\n        settings.maxBitrate = 1000;\n        const { width, height } = track.getSettings();\n        settings.width = width;\n        settings.height = height;\n      }\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings(settings);\n    } else if (source === 'audioplaylist') {\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings({ maxBitrate: 64 });\n    }\n  }\n\n  /**\n   * @param {HMSConfig} config\n   * @param {string} role\n   * @param {string} userId\n   */\n  private createAndAddLocalPeerToStore(config: HMSConfig, role: string, userId: string) {\n    const policy = this.store.getPolicyForRole(role);\n    const localPeer = new HMSLocalPeer({\n      name: config.userName || '',\n      customerUserId: userId,\n      metadata: config.metaData || '',\n      role: policy,\n    });\n\n    this.store.addPeer(localPeer);\n  }\n\n  /**\n   * init managers and set listeners - common for join and preview\n   * @param {HMSConfig} config\n   * @param {string} roomId\n   * @param {HMSPreviewListener | HMSUpdateListener} listener\n   */\n  private commonSetup(config: HMSConfig, roomId: string, listener: HMSPreviewListener | HMSUpdateListener) {\n    this.stringifyMetadata(config);\n    if (!config.initEndpoint) {\n      config.initEndpoint = 'https://prod-init.100ms.live';\n    }\n    this.errorListener = listener;\n    this.deviceChangeListener = listener;\n    this.initStoreAndManagers();\n\n    this.store.setErrorListener(this.errorListener);\n    if (!this.store.getRoom()) {\n      this.store.setRoom(new HMSRoom(roomId, this.store));\n    }\n  }\n\n  /**\n   * Remove deviceId's passed in config for join if preview was already called\n   * @param {HMSConfig} config\n   */\n  private removeDevicesFromConfig(config: HMSConfig) {\n    const storedConfig = this.store.getConfig();\n    if (storedConfig && config.settings) {\n      // preview was called\n      delete config.settings.audioOutputDeviceId;\n      delete config.settings.videoDeviceId;\n      delete config.settings.audioInputDeviceId;\n    }\n  }\n\n  /**\n   * Get screenshare based on policy and audioOnly flag\n   * @param {PublishParams} publishParams\n   * @param {function} onStop\n   * @param config\n   * @returns\n   */\n  private async getScreenshareTracks(onStop: () => void, config: ScreenShareConfig) {\n    const { video, audio } = this.getScreenshareSettings(config.videoOnly);\n    const [videoTrack, audioTrack] = await this.transport!.getLocalScreen(video, audio);\n\n    const handleEnded = () => {\n      this.stopEndedScreenshare(onStop);\n    };\n\n    const tracks = [];\n    if (config.audioOnly) {\n      videoTrack.nativeTrack.stop();\n      if (!audioTrack) {\n        throw Error('Select share audio when sharing screen');\n      }\n      tracks.push(audioTrack);\n      audioTrack.nativeTrack.onended = handleEnded;\n    } else {\n      tracks.push(videoTrack);\n      videoTrack.nativeTrack.onended = handleEnded;\n      // audio track is not always available\n      if (audioTrack) {\n        tracks.push(audioTrack);\n      }\n    }\n    return tracks;\n  }\n\n  private getScreenshareSettings = (videoOnly: boolean) => {\n    const { screen } = this.store.getPublishParams()!;\n    const dimensions = this.store.getSimulcastDimensions('screen');\n\n    return {\n      video: new HMSVideoTrackSettingsBuilder()\n        // Don't cap maxBitrate for screenshare.\n        // If publish params doesn't have bitRate value - don't set maxBitrate.\n        .maxBitrate(screen.bitRate, false)\n        .codec(screen.codec as HMSVideoCodec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(dimensions?.width || screen.width)\n        .setHeight(dimensions?.height || screen.height)\n        .build(),\n      audio: videoOnly ? undefined : new HMSAudioTrackSettingsBuilder().build(),\n    };\n  };\n\n  private sendAudioPresenceFailed = () => {\n    const error = ErrorFactory.TracksErrors.NoAudioDetected(HMSAction.PREVIEW);\n    this.sendAnalyticsEvent(\n      AnalyticsEventFactory.audioDetectionFail(error, this.deviceManager.getCurrentSelection().audioInput),\n    );\n    // @TODO: start sending if error is less frequent\n    // this.listener?.onError(error);\n  };\n\n  private sendJoinAnalyticsEvent = (is_preview_called = false, error?: HMSException) => {\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.join({\n        error,\n        ...this.analyticsTimer.getTimes(\n          TimedEvent.INIT,\n          TimedEvent.WEBSOCKET_CONNECT,\n          TimedEvent.ON_POLICY_CHANGE,\n          TimedEvent.LOCAL_TRACKS,\n        ),\n        time: this.analyticsTimer.getTimeTaken(TimedEvent.JOIN),\n        is_preview_called,\n      }),\n    );\n  };\n\n  private sendPreviewAnalyticsEvent = (error?: HMSException) => {\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.preview({\n        error,\n        ...this.analyticsTimer.getTimes(\n          TimedEvent.INIT,\n          TimedEvent.WEBSOCKET_CONNECT,\n          TimedEvent.ON_POLICY_CHANGE,\n          TimedEvent.LOCAL_TRACKS,\n        ),\n        time: this.analyticsTimer.getTimeTaken(TimedEvent.PREVIEW),\n      }),\n    );\n  };\n\n  private sendAnalyticsEvent = (event: AnalyticsEvent) => {\n    this.analyticsEventsService.queue(event).flush();\n  };\n}\n", "import { HMSAction } from '../error/ErrorFactory';\nimport { HMSException } from '../error/HMSException';\nimport { HMSAudioTrackSettingsBuilder } from '../media/settings/HMSAudioTrackSettings';\nimport { HMSVideoTrackSettingsBuilder } from '../media/settings/HMSVideoTrackSettings';\nimport { getLocalStream } from './media';\nimport { getAudioTrack, getVideoTrack } from './track';\n\n// Errors out when there's any device error, returns false when there are no device errors.\nexport async function validateDeviceAV() {\n  const videoTrackSettings = new HMSVideoTrackSettingsBuilder().build();\n  const audioTrackSettings = new HMSAudioTrackSettingsBuilder().build();\n  /**\n   * Check audio failure.\n   * If audio failure - check AV failure.\n   * If AV failure - throw AV failure.\n   * If AV passed - throw audio failure.\n   *\n   * If audio passed - check video failure.\n   * If video failure - throw video failure.\n   * If video passed - no error - return false.\n   */\n  try {\n    const track = await getAudioTrack(audioTrackSettings);\n    track.stop();\n  } catch (audioError) {\n    if (isHMSDeviceError(audioError)) {\n      const stream = await getLocalStream({ audio: false, video: true });\n      stream.getTracks().forEach(track => track.stop());\n      throw audioError;\n    }\n  }\n\n  const track = await getVideoTrack(videoTrackSettings);\n  track.stop();\n  return false;\n}\n\nfunction isHMSDeviceError(error: any) {\n  return error instanceof HMSException && error.action === HMSAction.TRACK;\n}\n"],
  "mappings": "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",
  "names": []
}
