import { ISignal } from '../ISignal';
import { ISignalEventsObserver } from '../ISignalEventsObserver';
import { Track, AcceptRoleChangeParams, RequestForRoleChangeParams, TrackUpdateRequestParams, RemovePeerRequest, MultiTrackUpdateRequestParams, StartRTMPOrRecordingRequestParams, UpdatePeerRequestParams, HLSRequestParams, BroadcastResponse, HLSTimedMetadataParams } from '../interfaces';
import { HMSConnectionRole } from '../../connection/model';
import AnalyticsEvent from '../../analytics/AnalyticsEvent';
import Message from '../../sdk/models/HMSMessage';
import { Queue } from '../../utils/queue';
export default class JsonRpcSignal implements ISignal {
    readonly TAG = "[ SIGNAL ]: ";
    readonly observer: ISignalEventsObserver;
    readonly pongResponseTimes: Queue<number>;
    /**
     * Sometimes before [join] is completed, there could be a lot of trickles
     * Sending [HMSTrickle]` before [join] web socket message leads to
     * error: [500] no rtc transport exists for this Peer
     *
     * We keep a list of pending trickles and send them immediately after [join]
     * is done.
     */
    private isJoinCompleted;
    private pendingTrickle;
    private socket;
    private callbacks;
    private _isConnected;
    private id;
    get isConnected(): boolean;
    setIsConnected(newValue: boolean, reason?: string): void;
    constructor(observer: ISignalEventsObserver);
    getPongResponseTimes(): number[];
    private internalCall;
    private notify;
    open(uri: string): Promise<void>;
    close(): Promise<void>;
    join(name: string, data: string, disableVidAutoSub: boolean, serverSubDegrade: boolean, offer?: RTCSessionDescriptionInit): Promise<RTCSessionDescriptionInit>;
    trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit): void;
    offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit>;
    answer(desc: RTCSessionDescriptionInit): void;
    trackUpdate(tracks: Map<string, Track>): void;
    broadcast(message: Message): Promise<BroadcastResponse>;
    leave(): void;
    endRoom(lock: boolean, reason: string): Promise<void>;
    sendEvent(event: AnalyticsEvent): void;
    ping(timeout: number): Promise<number>;
    requestRoleChange(params: RequestForRoleChangeParams): Promise<void>;
    acceptRoleChangeRequest(params: AcceptRoleChangeParams): Promise<void>;
    requestTrackStateChange(params: TrackUpdateRequestParams): Promise<void>;
    requestMultiTrackStateChange(params: MultiTrackUpdateRequestParams): Promise<void>;
    removePeer(params: RemovePeerRequest): Promise<void>;
    startRTMPOrRecording(params: StartRTMPOrRecordingRequestParams): Promise<void>;
    stopRTMPAndRecording(): Promise<void>;
    startHLSStreaming(params: HLSRequestParams): Promise<void>;
    stopHLSStreaming(params?: HLSRequestParams): Promise<void>;
    sendHLSTimedMetadata(params?: HLSTimedMetadataParams): Promise<void>;
    updatePeer(params: UpdatePeerRequestParams): Promise<void>;
    private onCloseHandler;
    private onMessageHandler;
    private handleResponseWithId;
    private handleResponseWithMethod;
    private pingPongLoop;
    private call;
}
